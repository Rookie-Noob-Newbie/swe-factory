#!/bin/bash
set -uxo pipefail
cd /testbed

# Ensure we are on the correct commit
git checkout f43a5470128a1f94210dace36244503148c1f42f

# Apply the test patch
git apply -v - <<'EOF_114329324912'
[CONTENT OF TEST PATCH]
EOF_114329324912

# Build the project and compile the test binary
# According to context retrieval, `make check` compiles and runs all tests.
# However, we only want to run the specific test files.
# The Makefile's `check` target runs ct/_ctcheck, which is generated from all *-test.c files.
# To run only specific tests, we can modify the ct/gen script or directly build and run with specific test objects.
# Simpler approach: Build the project, then compile and link only the target test objects.
# Step 1: Build the main object files required for linking tests.
make CFLAGS="-g" || make  # try with debug flags, fallback to default

# Determine the OS-specific object file (as per Makefile logic).
# The Makefile uses $(OS) which is derived from uname -s, with default to freebsd if not darwin.
OS=$(uname -s | tr '[:upper:]' '[:lower:]')
if [ "$OS" != "darwin" ]; then
    OS="freebsd"
fi

# Compile the main objects needed for tests (as per Makefile: ct/_ctcheck depends on ct/_ctcheck.o ct/ct.o $(OFILES) $(TOFILES))
# OFILES: $(OS).o conn.o file.o heap.o job.o ms.o net.o primes.o prot.o sd-daemon.o serv.o time.o tube.o util.o vers.o walg.o
# Let's compile them individually with the same flags used by the Makefile.
CFLAGS="-Wall -Werror -Wformat=2"
mkdir -p obj
for src in "$OS.c" conn.c file.c heap.c job.c ms.c net.c primes.c prot.c sd-daemon.c serv.c time.c tube.c util.c vers.c walg.c; do
    # Note: vers.c is generated by vers.sh, but should already exist after make.
    # We'll rely on the existing compiled objects from `make` step, but ensure they are present.
    if [ ! -f "$src" ]; then
        # Some files might have .c extension, others might be OS-specific.
        # The Makefile uses $(OS).c -> $(OS).o, but source might be darwin.c or freebsd.c.
        # We'll just trust that `make` already built them.
        continue
    fi
done

# Now compile the specific test files provided by the user.
# The user specified target test files: (list from initial prompt, but none provided? Actually the user provided none in the message.
# Wait, the initial user message says "Target test files:" but then is empty.
# However, the context retrieval agent identified test files: heap-test.c, job-test.c, integ-test.c, util-test.c.
# Since the user didn't list specific ones, we assume we need to run all identified test files? But the instruction says "execute the given test files".
# The user message says: "Target test files:" and then blank line. Possibly a mistake.
# We'll assume we need to run the tests identified by the context retrieval agent: heap-test.c, job-test.c, integ-test.c, util-test.c.
# However, the instruction says: "You must execute only the specified target test files"
# Since none are specified, perhaps we should run all tests? But instruction also says "Avoid running all tests! Just run the target test files."
# This is ambiguous. For safety, we will run the tests that are likely intended: the four test files identified.
# We'll create a custom test runner that compiles and links only these.

# Step: Compile ct/ct.o (the testing framework)
gcc $CFLAGS -I. -c ct/ct.c -o ct/ct.o

# Step: Compile each target test file
TARGET_TESTS="heap-test job-test integ-test util-test"
TEST_OBJS=""
for test in $TARGET_TESTS; do
    gcc $CFLAGS -I. -c "$test.c" -o "$test.o"
    TEST_OBJS="$TEST_OBJS $test.o"
done

# Step: Compile ct/_ctcheck.c (the test runner) but we need to generate it first.
# The ct/gen script generates ct/_ctcheck.c from the test object files.
# We'll run it with only our target test objects.
# First, ensure ct/gen is executable.
chmod +x ct/gen
# The ct/gen script expects a list of .o files as arguments? Looking at the Makefile:
# ct/_ctcheck.c: $(TOFILES) ct/gen
#	ct/gen $(TOFILES) > $@
# So we can generate it with our test objects.
./ct/gen $TEST_OBJS > ct/_ctcheck.c

# Step: Compile ct/_ctcheck.c
gcc $CFLAGS -I. -c ct/_ctcheck.c -o ct/_ctcheck.o

# Step: Link everything together into a test binary.
# We need the main object files (OFILES). Let's collect them.
OFILES="$OS.o conn.o file.o heap.o job.o ms.o net.o primes.o prot.o sd-daemon.o serv.o time.o tube.o util.o vers.o walg.o"
# Check if they exist in current directory (likely after make). If not, look in objs or build directory.
# We'll use the ones built by make, which are in the root.
LINK_OBJS="ct/_ctcheck.o ct/ct.o $OFILES $TEST_OBJS"
gcc $LINK_OBJS -o custom_ctcheck

# Step: Run the custom test binary.
./custom_ctcheck
rc=$?

# Clean up: remove generated objects and binary to avoid interference with later steps.
rm -f ct/_ctcheck.o ct/_ctcheck.c custom_ctcheck $TEST_OBJS

echo "OMNIGRIL_EXIT_CODE=$rc"

# Reset the repository to original state (remove patch changes)
git checkout f43a5470128a1f94210dace36244503148c1f42f -- .