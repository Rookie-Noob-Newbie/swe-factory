{"instance_id": "beanstalkd__beanstalkd-149", "repo": "beanstalkd/beanstalkd", "pull_number": 149, "base_commit": "37db4e00abadd134a81578834158f72bf1062aa3", "patch": "diff --git a/doc/protocol.md b/doc/protocol.md\n--- a/doc/protocol.md\n+++ b/doc/protocol.md\n@@ -138,7 +138,7 @@ use <tube>\\r\\n\n \n * `USING <tube>\\r\\n` -- `<tube>` is the name of the tube now being used.\n \n-#### Worker Commands\n+### Worker Commands\n \n A process that wants to consume jobs from the queue uses those commands:\n \n@@ -227,6 +227,28 @@ The client expects one line of response, which may be:\n * `BURIED\\r\\n` if the server ran out of memory trying to grow the priority queue data structure.\n * `NOT_FOUND\\r\\n` if the job does not exist or is not reserved by the client.\n \n+#### `bury` command\n+The bury command puts a job into the \"buried\" state. Buried jobs are put into a FIFO linked list and will not be touched by the server again until a client kicks them with the `kick`\" command.\n+\n+The bury command looks like this:\n+\n+```\n+bury <id> <pri>\\r\\n\n+```\n+\n+##### `bury` options\n+\n+* `<id>` is the job id to release.\n+* `<pri>` is a new priority to assign to the job.\n+\n+##### `bury` responses\n+\n+There are two possible responses:\n+\n+* `BURIED\\r\\n` to indicate success.\n+* `NOT_FOUND\\r\\n` if the job does not exist or is not reserved by the client.\n+\n+\n #### `touch` command\n \n The `touch` command allows a worker to request more time to work on a job. This is useful for jobs that potentially take a long time, but you still want the benefits of a TTR pulling a job away from an unresponsive worker.  A worker may periodically tell the server that it's still alive and processing a job (e.g. it may do this on `DEADLINE_SOON`).\n", "test_patch": "", "problem_statement": "[protocol.md] add bury description\nI forgot to include `bury` command in `protocol.md`. Here's the fix bf4dd7a", "version": "", "language": "C", "created_at": "2012-10-19T02:09:33Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-274", "repo": "beanstalkd/beanstalkd", "pull_number": 274, "base_commit": "86231ba548862c755796489dcfb500770620a5b2", "patch": "diff --git a/util.c b/util.c\n--- a/util.c\n+++ b/util.c\n@@ -99,15 +99,15 @@ usage(int code)\n     fprintf(stderr, \"Use: %s [OPTIONS]\\n\"\n             \"\\n\"\n             \"Options:\\n\"\n-            \" -b DIR   wal directory\\n\"\n+            \" -b DIR   write-ahead log directory\\n\"\n             \" -f MS    fsync at most once every MS milliseconds\"\n                        \" (use -f0 for \\\"always fsync\\\")\\n\"\n             \" -F       never fsync (default)\\n\"\n             \" -l ADDR  listen on address (default is 0.0.0.0)\\n\"\n             \" -p PORT  listen on port (default is \" Portdef \")\\n\"\n             \" -u USER  become user and group\\n\"\n             \" -z BYTES set the maximum job size in bytes (default is %d)\\n\"\n-            \" -s BYTES set the size of each wal file (default is %d)\\n\"\n+            \" -s BYTES set the size of each write-ahead log file (default is %d)\\n\"\n             \"            (will be rounded up to a multiple of 512 bytes)\\n\"\n             \" -c       compact the binlog (default)\\n\"\n             \" -n       do not compact the binlog\\n\"\n", "test_patch": "", "problem_statement": "CLI/usability: wal => write-ahead log\nMany users might not know what \"WAL\" stands for. This will make it more\nexplicit.", "version": "", "language": "C", "created_at": "2015-08-17T11:21:33Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-417", "repo": "beanstalkd/beanstalkd", "pull_number": 417, "base_commit": "f3460ecc202b5b7956ff74c7e5e79c696ec20e52", "patch": "diff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -1,10 +1,29 @@\n git:\n     quiet: true\n+    depth: 5\n \n language: c\n \n compiler:\n     - clang\n     - gcc\n \n-script: make check\n+os:\n+    - linux\n+    - osx\n+\n+before_install:\n+    - $CC --version\n+    - export MAKEJOBS=\"-j$(getconf _NPROCESSORS_ONLN)\"\n+    - export TRAVIS_COMMIT_LOG=`git log --format=fuller -2`\n+\n+script:\n+    - make $MAKEJOBS || ( echo \"Build failure. Verbose build follows.\" && make V=1 ; false )\n+    - make check $MAKEJOBS VERBOSE=1\n+\n+after_script:\n+    - printf \"$TRAVIS_COMMIT_RANGE\\n\"\n+    - printf \"$TRAVIS_COMMIT_LOG\\n\"\n+\n+after_success:\n+    - if [[ ! -z \"${CODECOV_TOKEN}\" ]]; then (bash <(curl -s https://codecov.io/bash) || echo \"Codecov did not collect coverage reports\"); fi;\n", "test_patch": "", "problem_statement": "Added enhanced Travis CI config\nAdded enhanced Travis CI config \r\n\r\nNeeds to be done:\r\n- [x] Setup Travis CI cron jobs: https://travis-ci.org/beanstalkd/beanstalkd/settings\r\n- [x] Setup CodeCov: https://codecov.io\r\n- [x] Rename REDAME -> README.md, add badge\r\n```md\r\n[![Build Status](https://travis-ci.org/beanstalkd/beanstalkd.svg?branch=master)](https://travis-ci.org/beanstalkd/beanstalkd)\r\n```\r\n\r\nRefs: https://github.com/beanstalkd/beanstalkd/issues/396", "version": "", "language": "C", "created_at": "2019-06-26T19:16:57Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-416", "repo": "beanstalkd/beanstalkd", "pull_number": 416, "base_commit": "eaf43d4791130a1dea4f4cf49f842e9aebf650d8", "patch": "diff --git a/README b/README\n--- a/README\n+++ b/README\n@@ -1,5 +1,5 @@\n This is beanstalkd, a fast, general-purpose work queue.\n-See http://kr.github.io/beanstalkd/ for general info.\n+See https://beanstalkd.github.io/ for general info.\n \n Please note that this project is released with a Contributor\n Code of Conduct. By participating in this project you agree\n\ndiff --git a/doc/beanstalkd.1 b/doc/beanstalkd.1\n--- a/doc/beanstalkd.1\n+++ b/doc/beanstalkd.1\n@@ -109,7 +109,7 @@ sd\\-daemon(5), sd_listen_fds(5)\n Files \\fBREADME\\fR and \\fBdoc/protocol\\.txt\\fR in the \\fBbeanstalkd\\fR distribution\\.\n .\n .P\n-\\fIhttp://kr\\.github\\.com/beanstalkd/\\fR\n+\\fIhttps://beanstalkd\\.github\\.io/\\fR\n .\n .SH \"AUTHOR\"\n \\fBBeanstalkd\\fR is written and maintained by Keith Rarick with the help of many others\\.\n\ndiff --git a/doc/beanstalkd.1.html b/doc/beanstalkd.1.html\n--- a/doc/beanstalkd.1.html\n+++ b/doc/beanstalkd.1.html\n@@ -157,7 +157,7 @@ <h2 id=\"SEE-ALSO\">SEE ALSO</h2>\n <p>Files <code>README</code> and <code>doc/protocol.txt</code> in the <code>beanstalkd</code>\n distribution.</p>\n \n-<p><a href=\"http://kr.github.com/beanstalkd/\" data-bare-link=\"true\">http://kr.github.com/beanstalkd/</a></p>\n+<p><a href=\"https://beanstalkd.github.io/\" data-bare-link=\"true\">https://beanstalkd.github.io/</a></p>\n \n <h2 id=\"AUTHOR\">AUTHOR</h2>\n \n\ndiff --git a/doc/beanstalkd.ronn b/doc/beanstalkd.ronn\n--- a/doc/beanstalkd.ronn\n+++ b/doc/beanstalkd.ronn\n@@ -105,7 +105,7 @@ sd-daemon(5), sd_listen_fds(5)\n Files `README` and `doc/protocol.txt` in the `beanstalkd`\n distribution.\n \n-<http://kr.github.com/beanstalkd/>\n+<https://beanstalkd.github.io/>\n \n ## AUTHOR\n \n\ndiff --git a/pkg/README.md b/pkg/README.md\n--- a/pkg/README.md\n+++ b/pkg/README.md\n@@ -0,0 +1,8 @@\n+How to make a release:\n+\n+1. Check out master\n+2. Tag the commit to release devX.Y: git tag dev1.11\n+3. Write a change log in file News (don't commit it)\n+4. Run pkg/dist.sh and follow the intructions.\n+5. Push tags and beanstalkd.github.io\n+6. Run pkg/mail.sh\n\ndiff --git a/pkg/Readme b/pkg/Readme\n--- a/pkg/Readme\n+++ b/pkg/Readme\n@@ -1,8 +0,0 @@\n-How to make a release:\n-\n-1. Check out master\n-2. Tag the commit to release devX.Y (e.g. dev1.9)\n-3. Write a change log in file News (don't commit it)\n-4. Run pkg/dist.sh\n-5. Push tags and gh-pages\n-6. Run pkg/mail.sh\n\ndiff --git a/pkg/bloghead.in b/pkg/bloghead.in\n--- a/pkg/bloghead.in\n+++ b/pkg/bloghead.in\n@@ -2,7 +2,7 @@\n layout: post\n title: Beanstalkd @VERSION@ Release Notes\n version: @VERSION@\n-dist: https://github.com/kr/beanstalkd/archive/v@VERSION@.tar.gz\n+dist: https://github.com/beanstalkd/beanstalkd/archive/v@VERSION@.tar.gz\n file: beanstalkd-@VERSION@.tar.gz\n ---\n \n\ndiff --git a/pkg/dist.sh b/pkg/dist.sh\n--- a/pkg/dist.sh\n+++ b/pkg/dist.sh\n@@ -41,12 +41,8 @@ tree=`git write-tree`\n commit=`git commit-tree $tree -p dev$ver -m \"release $ver\"`\n git tag -m \"beanstalkd version $ver\" v$ver $commit\n \n-git rev-parse --verify gh-pages >/dev/null\n-parent=`git rev-parse --verify gh-pages`\n-git read-tree $parent\n-postobj=`(exp <pkg/bloghead.in; git cat-file blob v$ver:News)|mkobj`\n-post=_posts/`date +%Y-%m-%d`-$ver-release-notes.md\n-git update-index --add --cacheinfo 100644 $postobj $post\n-tree=`git write-tree`\n-commit=`git commit-tree $tree -p $parent -m \"announce release $ver\"`\n-git update-ref -m \"commit: announce release $ver\" refs/heads/gh-pages $commit $parent\n+postcont=`(exp <pkg/bloghead.in; git cat-file blob v$ver:News)`\n+postfile=`date +%Y-%m-%d`-$ver-release-notes.md\n+echo \"$postcont\" >$postfile\n+echo \"Now, run these commands to update the blog:\"\n+echo \"(mv $postfile ../beanstalkd.github.io/_posts/ && cd ../beanstalkd.github.io && git add . && git commit -m \\\"announce release $ver\\\")\"\n\ndiff --git a/pkg/newstail.in b/pkg/newstail.in\n--- a/pkg/newstail.in\n+++ b/pkg/newstail.in\n@@ -1,21 +1,20 @@\n-\n-Full list of changes (includes authorship information):  \n-<http://github.com/kr/beanstalkd/compare/v@PARENT@...v@VERSION@>\n+Full list of changes (includes authorship information):\n+<http://github.com/beanstalkd/beanstalkd/compare/v@PARENT@...v@VERSION@>\n \n Our Urls\n --------\n \n-Download the @VERSION@ tarball directly:  \n-<https://github.com/kr/beanstalkd/archive/v@VERSION@.tar.gz>\n+Download the @VERSION@ tarball directly:\n+<https://github.com/beanstalkd/beanstalkd/archive/v@VERSION@.tar.gz>\n \n-Learn all about beanstalk:  \n-<http://kr.github.com/beanstalkd/>\n+Learn all about beanstalk:\n+<https://beanstalkd.github.io/>\n \n-Talk about beanstalk development or use at:  \n-<http://groups.google.com/group/beanstalk-talk>\n+Talk about beanstalk development or use at:\n+<https://groups.google.com/group/beanstalk-talk>\n \n Bugs\n ----\n \n-Please report any bugs to:  \n-<http://github.com/kr/beanstalkd/issues>\n+Please report any bugs to:\n+<http://github.com/beanstalkd/beanstalkd/issues>\n", "test_patch": "", "problem_statement": "fix release script to allow releases\nSince gh-page was moved into separate repository,\r\nmake the proccess of releasing semi-manual for website.\r\n\r\nFix links to the new site everywhere.", "version": "", "language": "C", "created_at": "2019-06-26T16:49:59Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-437", "repo": "beanstalkd/beanstalkd", "pull_number": 437, "base_commit": "af31bed9ed4e8bad97b2935f3089125ee00d0352", "patch": "diff --git a/file.c b/file.c\n--- a/file.c\n+++ b/file.c\n@@ -423,7 +423,7 @@ warnpos(File *f, int adj, char *fmt, ...)\n     va_list ap;\n \n     off = lseek(f->fd, 0, SEEK_CUR);\n-    fprintf(stderr, \"%s:%u: \", f->path, off+adj);\n+    fprintf(stderr, \"%s:%d: \", f->path, off+adj);\n     va_start(ap, fmt);\n     vfprintf(stderr, fmt, ap);\n     va_end(ap);\n\ndiff --git a/main.c b/main.c\n--- a/main.c\n+++ b/main.c\n@@ -17,14 +17,26 @@ su(const char *user)\n \n     errno = 0;\n     pwent = getpwnam(user);\n-    if (errno) twarn(\"getpwnam(\\\"%s\\\")\", user), exit(32);\n-    if (!pwent) twarnx(\"getpwnam(\\\"%s\\\"): no such user\", user), exit(33);\n+    if (errno) {\n+        twarn(\"getpwnam(\\\"%s\\\")\", user);\n+        exit(32);\n+    }\n+    if (!pwent) {\n+        twarnx(\"getpwnam(\\\"%s\\\"): no such user\", user);\n+        exit(33);\n+    }\n \n     r = setgid(pwent->pw_gid);\n-    if (r == -1) twarn(\"setgid(%d \\\"%s\\\")\", pwent->pw_gid, user), exit(34);\n+    if (r == -1) {\n+        twarn(\"setgid(%d \\\"%s\\\")\", pwent->pw_gid, user);\n+        exit(34);\n+    }\n \n     r = setuid(pwent->pw_uid);\n-    if (r == -1) twarn(\"setuid(%d \\\"%s\\\")\", pwent->pw_uid, user), exit(34);\n+    if (r == -1) {\n+        twarn(\"setuid(%d \\\"%s\\\")\", pwent->pw_uid, user);\n+        exit(34);\n+    }\n }\n \n \n@@ -37,14 +49,23 @@ set_sig_handlers()\n     sa.sa_handler = SIG_IGN;\n     sa.sa_flags = 0;\n     r = sigemptyset(&sa.sa_mask);\n-    if (r == -1) twarn(\"sigemptyset()\"), exit(111);\n+    if (r == -1) {\n+        twarn(\"sigemptyset()\");\n+        exit(111);\n+    }\n \n     r = sigaction(SIGPIPE, &sa, 0);\n-    if (r == -1) twarn(\"sigaction(SIGPIPE)\"), exit(111);\n+    if (r == -1) {\n+        twarn(\"sigaction(SIGPIPE)\");\n+        exit(111);\n+    }\n \n     sa.sa_handler = enter_drain_mode;\n     r = sigaction(SIGUSR1, &sa, 0);\n-    if (r == -1) twarn(\"sigaction(SIGUSR1)\"), exit(111);\n+    if (r == -1) {\n+        twarn(\"sigaction(SIGUSR1)\");\n+        exit(111);\n+    }\n }\n \n int\n@@ -62,7 +83,11 @@ main(int argc, char **argv)\n     }\n \n     r = make_server_socket(srv.addr, srv.port);\n-    if (r == -1) twarnx(\"make_server_socket()\"), exit(111);\n+    if (r == -1) {\n+        twarnx(\"make_server_socket()\");\n+        exit(111);\n+    }\n+\n     srv.sock.fd = r;\n \n     prot_init();\n@@ -84,10 +109,10 @@ main(int argc, char **argv)\n         r = prot_replay(&srv, &list);\n         if (!r) {\n             twarnx(\"failed to replay log\");\n-            return 1;\n+            exit(1);\n         }\n     }\n \n     srvserve(&srv);\n-    return 0;\n+    exit(0);\n }\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -229,7 +229,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n static char bucket[BUCKET_BUF_SIZE];\n \n static uint ready_ct = 0;\n-static struct stats global_stat = {0, 0, 0, 0, 0};\n+static struct stats global_stat = {0, 0, 0, 0, 0, 0, 0};\n \n static tube default_tube;\n \n@@ -435,7 +435,7 @@ process_queue()\n static job\n delay_q_peek()\n {\n-    int i;\n+    size_t i;\n     tube t;\n     job j = NULL, nj;\n \n@@ -487,10 +487,8 @@ enqueue_job(Server *s, job j, int64 delay, char update_store)\n static int\n bury_job(Server *s, job j, char update_store)\n {\n-    int z;\n-\n     if (update_store) {\n-        z = walresvupdate(&s->wal, j);\n+        int z = walresvupdate(&s->wal, j);\n         if (!z) return 0;\n         j->walresv += z;\n     }\n@@ -1183,7 +1181,6 @@ static void\n dispatch_cmd(Conn *c)\n {\n     int r, i, timeout = -1;\n-    int z;\n     uint count;\n     job j = 0;\n     byte type;\n@@ -1375,7 +1372,7 @@ dispatch_cmd(Conn *c)\n         /* We want to update the delay deadline on disk, so reserve space for\n          * that. */\n         if (delay) {\n-            z = walresvupdate(&c->srv->wal, j);\n+            int z = walresvupdate(&c->srv->wal, j);\n             if (!z) return reply_serr(c, MSG_OUT_OF_MEMORY);\n             j->walresv += z;\n         }\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -185,6 +185,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n     \"binlog-records-migrated: %\" PRId64 \"\\n\" \\\n     \"binlog-records-written: %\" PRId64 \"\\n\" \\\n     \"binlog-max-size: %d\\n\" \\\n+    \"draining: %s\\n\" \\\n     \"id: %s\\n\" \\\n     \"hostname: %s\\n\" \\\n     \"\\r\\n\"\n@@ -929,6 +930,7 @@ fmt_stats(char *buf, size_t size, void *x)\n             srv->wal.nmig,\n             srv->wal.nrec,\n             srv->wal.filesize,\n+            drain_mode ? \"true\" : \"false\",\n             id,\n             node_info.nodename);\n }\n", "test_patch": "", "problem_statement": "improve readability of the code in some places\nThis is a start in a series of patches to fix\r\nwarnings from \"cppcheck --enable=all --inconclusive --std=posix .\"", "version": "", "language": "C", "created_at": "2019-07-03T20:51:06Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-450", "repo": "beanstalkd/beanstalkd", "pull_number": 450, "base_commit": "5762ec25820608f58553f5887006bfd02d10a3f2", "patch": "diff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -16,13 +16,17 @@ int verbose = 0;\n static void\n on_watch(ms a, tube t, size_t i)\n {\n+    UNUSED_PARAMETER(a);\n+    UNUSED_PARAMETER(i);\n     tube_iref(t);\n     t->watching_ct++;\n }\n \n static void\n on_ignore(ms a, tube t, size_t i)\n {\n+    UNUSED_PARAMETER(a);\n+    UNUSED_PARAMETER(i);\n     t->watching_ct--;\n     tube_dref(t);\n }\n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -60,6 +60,8 @@ typedef int(FAlloc)(int, int);\n /* Maximum value (uint32) allowed in pri, delay and ttr parameters */\n #define MAX_UINT32 4294967295\n \n+#define UNUSED_PARAMETER(x) (void)(x)\n+\n extern const char version[];\n extern int verbose;\n extern struct Server srv;\n\ndiff --git a/main.c b/main.c\n--- a/main.c\n+++ b/main.c\n@@ -12,11 +12,8 @@\n static void\n su(const char *user) \n {\n-    int r;\n-    struct passwd *pwent;\n-\n     errno = 0;\n-    pwent = getpwnam(user);\n+    struct passwd *pwent = getpwnam(user);\n     if (errno) {\n         twarn(\"getpwnam(\\\"%s\\\")\", user);\n         exit(32);\n@@ -26,7 +23,7 @@ su(const char *user)\n         exit(33);\n     }\n \n-    r = setgid(pwent->pw_gid);\n+    int r = setgid(pwent->pw_gid);\n     if (r == -1) {\n         twarn(\"setgid(%d \\\"%s\\\")\", pwent->pw_gid, user);\n         exit(34);\n@@ -43,12 +40,11 @@ su(const char *user)\n static void\n set_sig_handlers()\n {\n-    int r;\n     struct sigaction sa;\n \n     sa.sa_handler = SIG_IGN;\n     sa.sa_flags = 0;\n-    r = sigemptyset(&sa.sa_mask);\n+    int r = sigemptyset(&sa.sa_mask);\n     if (r == -1) {\n         twarn(\"sigemptyset()\");\n         exit(111);\n@@ -71,8 +67,7 @@ set_sig_handlers()\n int\n main(int argc, char **argv)\n {\n-    int r;\n-    struct job list = {};\n+    UNUSED_PARAMETER(argc);\n \n     progname = argv[0];\n     setlinebuf(stdout);\n@@ -82,7 +77,7 @@ main(int argc, char **argv)\n         printf(\"pid %d\\n\", getpid());\n     }\n \n-    r = make_server_socket(srv.addr, srv.port);\n+    int r = make_server_socket(srv.addr, srv.port);\n     if (r == -1) {\n         twarnx(\"make_server_socket()\");\n         exit(111);\n@@ -92,7 +87,8 @@ main(int argc, char **argv)\n \n     prot_init();\n \n-    if (srv.user) su(srv.user);\n+    if (srv.user)\n+        su(srv.user);\n     set_sig_handlers();\n \n     if (srv.wal.use) {\n@@ -104,6 +100,7 @@ main(int argc, char **argv)\n             exit(10);\n         }\n \n+        struct job list = {};\n         list.prev = list.next = &list;\n         walinit(&srv.wal, &list);\n         r = prot_replay(&srv, &list);\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -1654,8 +1654,9 @@ conn_timeout(Conn *c)\n }\n \n void\n-enter_drain_mode(int sig)\n+enter_drain_mode(int signum)\n {\n+    UNUSED_PARAMETER(signum);\n     drain_mode = 1;\n }\n \n@@ -1918,13 +1919,11 @@ prottick(Server *s)\n void\n h_accept(const int fd, const short which, Server *s)\n {\n-    Conn *c;\n-    int cfd, flags, r;\n-    socklen_t addrlen;\n+    UNUSED_PARAMETER(which);\n     struct sockaddr_in6 addr;\n \n-    addrlen = sizeof addr;\n-    cfd = accept(fd, (struct sockaddr *)&addr, &addrlen);\n+    socklen_t addrlen = sizeof addr;\n+    int cfd = accept(fd, (struct sockaddr *)&addr, &addrlen);\n     if (cfd == -1) {\n         if (errno != EAGAIN && errno != EWOULDBLOCK) twarn(\"accept()\");\n         update_conns();\n@@ -1934,7 +1933,7 @@ h_accept(const int fd, const short which, Server *s)\n         printf(\"accept %d\\n\", cfd);\n     }\n \n-    flags = fcntl(cfd, F_GETFL, 0);\n+    int flags = fcntl(cfd, F_GETFL, 0);\n     if (flags < 0) {\n         twarn(\"getting flags\");\n         close(cfd);\n@@ -1945,7 +1944,7 @@ h_accept(const int fd, const short which, Server *s)\n         return;\n     }\n \n-    r = fcntl(cfd, F_SETFL, flags | O_NONBLOCK);\n+    int r = fcntl(cfd, F_SETFL, flags | O_NONBLOCK);\n     if (r < 0) {\n         twarn(\"setting O_NONBLOCK\");\n         close(cfd);\n@@ -1956,7 +1955,7 @@ h_accept(const int fd, const short which, Server *s)\n         return;\n     }\n \n-    c = make_conn(cfd, STATE_WANTCOMMAND, default_tube, default_tube);\n+    Conn *c = make_conn(cfd, STATE_WANTCOMMAND, default_tube, default_tube);\n     if (!c) {\n         twarnx(\"make_conn() failed\");\n         close(cfd);\n\ndiff --git a/sd-daemon.c b/sd-daemon.c\n--- a/sd-daemon.c\n+++ b/sd-daemon.c\n@@ -43,9 +43,12 @@\n \n #include \"sd-daemon.h\"\n \n+#define UNUSED_PARAMETER(x) (void)(x)\n+\n int sd_listen_fds(int unset_environment) {\n \n #if defined(DISABLE_SYSTEMD) || !defined(__linux__)\n+        UNUSED_PARAMETER(unset_environment);\n         return 0;\n #else\n         int r, fd;\n@@ -326,6 +329,8 @@ int sd_is_socket_unix(int fd, int type, int listening, const char *path, size_t\n \n int sd_notify(int unset_environment, const char *state) {\n #if defined(DISABLE_SYSTEMD) || !defined(__linux__) || !defined(SOCK_CLOEXEC)\n+        UNUSED_PARAMETER(unset_environment);\n+        UNUSED_PARAMETER(state);\n         return 0;\n #else\n         int fd = -1, r;\n@@ -394,6 +399,8 @@ int sd_notify(int unset_environment, const char *state) {\n \n int sd_notifyf(int unset_environment, const char *format, ...) {\n #if defined(DISABLE_SYSTEMD) || !defined(__linux__)\n+        UNUSED_PARAMETER(unset_environment);\n+        UNUSED_PARAMETER(format);\n         return 0;\n #else\n         va_list ap;\n\ndiff --git a/serv.c b/serv.c\n--- a/serv.c\n+++ b/serv.c\n@@ -4,11 +4,9 @@\n #include \"dat.h\"\n \n struct Server srv = {\n-    Portdef,\n-    NULL,\n-    NULL,\n-    {\n-        Filesizedef,\n+    .port = Portdef,\n+    .wal = {\n+        .filesize = Filesizedef,\n     },\n };\n \n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -27,7 +27,7 @@ static byte fallocpat[3];\n static int\n wrapfalloc(int fd, int size)\n {\n-    static int c = 0;\n+    static size_t c = 0;\n \n     printf(\"\\nwrapfalloc: fd=%d size=%d\\n\", fd, size);\n     if (c >= sizeof(fallocpat) || !fallocpat[c++]) {\n", "test_patch": "", "problem_statement": "mark unused parameters to satisfy -Wextra\nParameters marked with the UNUSED_PARAMETERS macros cannot be\r\nremoved from functions because their prototypes cannot be changed.\r\n\r\nCreate the srv struct via designated initializers. Also remove NULL\r\nassigment, because this way struct values are set to 0 anyway.\r\n\r\nAlso declare vars next to their first usage as usual.\r\n\r\nUpdate #443", "version": "", "language": "C", "created_at": "2019-07-08T18:29:03Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-444", "repo": "beanstalkd/beanstalkd", "pull_number": 444, "base_commit": "570eb7b1f3caea434c1e140d46ce561d783bdae5", "patch": "diff --git a/testheap.c b/testheap.c\n--- a/testheap.c\n+++ b/testheap.c\n@@ -8,7 +8,7 @@\n \n \n void\n-cttestheap_insert_one()\n+cttest_heap_insert_one()\n {\n     Heap h = {0};\n     job j;\n@@ -24,9 +24,8 @@ cttestheap_insert_one()\n     assertf(j->heap_index == 0, \"should match\");\n }\n \n-\n void\n-cttestheap_insert_and_remove_one()\n+cttest_heap_insert_and_remove_one()\n {\n     Heap h = {0};\n     int r;\n@@ -47,9 +46,8 @@ cttestheap_insert_and_remove_one()\n     assertf(j->heap_index == -1, \"j's heap index should be invalid\");\n }\n \n-\n void\n-cttestheap_priority()\n+cttest_heap_priority()\n {\n     Heap h = {0};\n     int r;\n@@ -92,9 +90,8 @@ cttestheap_priority()\n     assertf(j == j3, \"j3 should come out third.\");\n }\n \n-\n void\n-cttestheap_fifo_property()\n+cttest_heap_fifo_property()\n {\n     Heap h = {0};\n     int r;\n@@ -140,9 +137,8 @@ cttestheap_fifo_property()\n     assertf(j == j3c, \"j3c should come out third.\");\n }\n \n-\n void\n-cttestheap_many_jobs()\n+cttest_heap_many_jobs()\n {\n     Heap h = {0};\n     uint last_pri;\n@@ -167,9 +163,8 @@ cttestheap_many_jobs()\n     }\n }\n \n-\n void\n-cttestheap_remove_k()\n+cttest_heap_remove_k()\n {\n     Heap h = {0};\n     uint last_pri;\n@@ -201,7 +196,7 @@ cttestheap_remove_k()\n }\n \n void\n-ctbenchheapinsert(int n)\n+ctbench_heap_insert(int n)\n {\n     job *j;\n     int i;\n@@ -222,7 +217,7 @@ ctbenchheapinsert(int n)\n }\n \n void\n-ctbenchheapremove(int n)\n+ctbench_heap_remove(int n)\n {\n     Heap h = {0};\n     job j;\n\ndiff --git a/testjobs.c b/testjobs.c\n--- a/testjobs.c\n+++ b/testjobs.c\n@@ -9,7 +9,7 @@\n static tube default_tube;\n \n void\n-cttestjob_creation()\n+cttest_job_creation()\n {\n     job j;\n \n@@ -19,7 +19,7 @@ cttestjob_creation()\n }\n \n void\n-cttestjob_cmp_pris()\n+cttest_job_cmp_pris()\n {\n     job a, b;\n \n@@ -31,7 +31,7 @@ cttestjob_cmp_pris()\n }\n \n void\n-cttestjob_cmp_ids()\n+cttest_job_cmp_ids()\n {\n     job a, b;\n \n@@ -43,9 +43,8 @@ cttestjob_cmp_ids()\n     assertf(job_pri_less(a, b), \"should be less\");\n }\n \n-\n void\n-cttestjob_large_pris()\n+cttest_job_large_pris()\n {\n     job a, b;\n \n@@ -62,7 +61,7 @@ cttestjob_large_pris()\n }\n \n void\n-cttestjob_hash_free()\n+cttest_job_hash_free()\n {\n     job j;\n     uint64 jid = 83;\n@@ -75,7 +74,7 @@ cttestjob_hash_free()\n }\n \n void\n-cttestjob_hash_free_next()\n+cttest_job_hash_free_next()\n {\n     job a, b;\n     uint64 aid = 97, bid = 12386;\n@@ -92,7 +91,7 @@ cttestjob_hash_free_next()\n }\n \n void\n-cttestjob_all_jobs_used()\n+cttest_job_all_jobs_used()\n {\n     job j, x;\n \n@@ -111,7 +110,7 @@ cttestjob_all_jobs_used()\n }\n \n void\n-cttestjob_100_000_jobs()\n+cttest_job_100_000_jobs()\n {\n     int i;\n \n@@ -129,7 +128,7 @@ cttestjob_100_000_jobs()\n }\n \n void\n-ctbenchmakejob(int n)\n+ctbench_make_job(int n)\n {\n     int i;\n     TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -36,7 +36,6 @@ wrapfalloc(int fd, int size)\n     return rawfalloc(fd, size);\n }\n \n-\n static void\n muststart(char *a0, char *a1, char *a2, char *a3, char *a4)\n {\n@@ -58,7 +57,6 @@ muststart(char *a0, char *a1, char *a2, char *a3, char *a4)\n     execlp(a0, a0, a1, a2, a3, a4, NULL);\n }\n \n-\n static int\n mustdiallocal(int port)\n {\n@@ -80,7 +78,7 @@ mustdiallocal(int port)\n         exit(1);\n     }\n \n-    r = connect(fd, (struct sockaddr*)&addr, sizeof addr);\n+    r = connect(fd, (struct sockaddr *)&addr, sizeof addr);\n     if (r == -1) {\n         twarn(\"connect\");\n         exit(1);\n@@ -89,8 +87,7 @@ mustdiallocal(int port)\n     return fd;\n }\n \n-\n-#define SERVER() (progname=__func__, mustforksrv())\n+#define SERVER() (progname = __func__, mustforksrv())\n \n static int\n mustforksrv()\n@@ -105,7 +102,7 @@ mustforksrv()\n     }\n \n     len = sizeof(addr);\n-    r = getsockname(srv.sock.fd, (struct sockaddr*)&addr, (socklen_t*)&len);\n+    r = getsockname(srv.sock.fd, (struct sockaddr *)&addr, (socklen_t *)&len);\n     if (r == -1 || len > sizeof(addr)) {\n         puts(\"mustforksrv failed\");\n         exit(1);\n@@ -150,7 +147,6 @@ mustforksrv()\n     exit(1); /* satisfy the compiler */\n }\n \n-\n static char *\n readline(int fd)\n {\n@@ -203,7 +199,6 @@ readline(int fd)\n     return buf;\n }\n \n-\n static void\n ckresp(int fd, char *exp)\n {\n@@ -213,7 +208,6 @@ ckresp(int fd, char *exp)\n     assertf(strcmp(exp, line) == 0, \"\\\"%s\\\" != \\\"%s\\\"\", exp, line);\n }\n \n-\n static void\n ckrespsub(int fd, char *sub)\n {\n@@ -223,7 +217,6 @@ ckrespsub(int fd, char *sub)\n     assertf(strstr(line, sub), \"\\\"%s\\\" not in \\\"%s\\\"\", sub, line);\n }\n \n-\n static void\n writefull(int fd, char *s, int n)\n {\n@@ -238,7 +231,6 @@ writefull(int fd, char *s, int n)\n     }\n }\n \n-\n static void\n mustsend(int fd, char *s)\n {\n@@ -247,7 +239,6 @@ mustsend(int fd, char *s)\n     fflush(stdout);\n }\n \n-\n static int\n filesize(char *path)\n {\n@@ -262,7 +253,6 @@ filesize(char *path)\n     return s.st_size;\n }\n \n-\n static int\n exist(char *path)\n {\n@@ -273,9 +263,8 @@ exist(char *path)\n     return r != -1;\n }\n \n-\n void\n-cttestpause()\n+cttest_pause()\n {\n     int64 s;\n \n@@ -293,19 +282,17 @@ cttestpause()\n     assert(nanoseconds() - s >= 1000000000); // 1s\n }\n \n-\n void\n-cttestunderscore()\n+cttest_underscore()\n {\n     port = SERVER();\n     fd = mustdiallocal(port);\n     mustsend(fd, \"use x_y\\r\\n\");\n     ckresp(fd, \"USING x_y\\r\\n\");\n }\n \n-\n void\n-cttest2cmdpacket()\n+cttest_2cmdpacket()\n {\n     port = SERVER();\n     fd = mustdiallocal(port);\n@@ -314,9 +301,8 @@ cttest2cmdpacket()\n     ckresp(fd, \"USING b\\r\\n\");\n }\n \n-\n void\n-cttesttoobig()\n+cttest_too_big()\n {\n     job_data_size_limit = 10;\n     port = SERVER();\n@@ -329,9 +315,8 @@ cttesttoobig()\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n }\n \n-\n void\n-cttestdeleteready()\n+cttest_delete_ready()\n {\n     port = SERVER();\n     fd = mustdiallocal(port);\n@@ -342,9 +327,8 @@ cttestdeleteready()\n     ckresp(fd, \"DELETED\\r\\n\");\n }\n \n-\n void\n-cttestmultitube()\n+cttest_multi_tube()\n {\n     port = SERVER();\n     fd = mustdiallocal(port);\n@@ -366,19 +350,17 @@ cttestmultitube()\n     ckresp(fd, \"RESERVED 2 0\\r\\n\");\n }\n \n-\n void\n-cttestnonegativedelay()\n+cttest_negative_delay()\n {\n     port = SERVER();\n     fd = mustdiallocal(port);\n     mustsend(fd, \"put 512 -1 100 0\\r\\n\");\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n }\n \n-\n void\n-cttestomittimeleft()\n+cttest_omit_time_left()\n {\n     port = SERVER();\n     fd = mustdiallocal(port);\n@@ -390,9 +372,8 @@ cttestomittimeleft()\n     ckrespsub(fd, \"\\ntime-left: 0\\n\");\n }\n \n-\n void\n-cttestsmalldelay()\n+cttest_small_delay()\n {\n     port = SERVER();\n     fd = mustdiallocal(port);\n@@ -401,9 +382,8 @@ cttestsmalldelay()\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n }\n \n-\n void\n-ctteststatstube()\n+cttest_stats_tube()\n {\n     port = SERVER();\n     fd = mustdiallocal(port);\n@@ -502,9 +482,8 @@ ctteststatstube()\n     ckrespsub(fd, \"\\npause-time-left: 0\\n\");\n }\n \n-\n void\n-cttestttrlarge()\n+cttest_ttrlarge()\n {\n     port = SERVER();\n     fd = mustdiallocal(port);\n@@ -552,9 +531,8 @@ cttestttrlarge()\n     ckrespsub(fd, \"\\nttr: 21600\\n\");\n }\n \n-\n void\n-cttestttrsmall()\n+cttest_ttr_small()\n {\n     port = SERVER();\n     fd = mustdiallocal(port);\n@@ -566,9 +544,8 @@ cttestttrsmall()\n     ckrespsub(fd, \"\\nttr: 1\\n\");\n }\n \n-\n void\n-cttestzerodelay()\n+cttest_zero_delay()\n {\n     port = SERVER();\n     fd = mustdiallocal(port);\n@@ -577,9 +554,8 @@ cttestzerodelay()\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n }\n \n-\n void\n-cttestreservewithtimeout2conn()\n+cttest_reserve_with_timeout_2conns()\n {\n     int fd0, fd1;\n \n@@ -597,9 +573,8 @@ cttestreservewithtimeout2conn()\n     ckresp(fd0, \"TIMED_OUT\\r\\n\");\n }\n \n-\n void\n-cttestunpausetube()\n+cttest_unpause_tube()\n {\n     int fd0, fd1;\n \n@@ -625,9 +600,8 @@ cttestunpausetube()\n     ckresp(fd1, \"\\r\\n\");\n }\n \n-\n void\n-cttestbinlogemptyexit()\n+cttest_binlog_empty_exit()\n {\n     srv.wal.dir = ctdir();\n     srv.wal.use = 1;\n@@ -645,9 +619,8 @@ cttestbinlogemptyexit()\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n }\n \n-\n void\n-cttestbinlogbury()\n+cttest_binlog_bury()\n {\n     srv.wal.dir = ctdir();\n     srv.wal.use = 1;\n@@ -665,9 +638,8 @@ cttestbinlogbury()\n     ckresp(fd, \"BURIED\\r\\n\");\n }\n \n-\n void\n-cttestbinlogbasic()\n+cttest_binlog_basic()\n {\n     srv.wal.dir = ctdir();\n     srv.wal.use = 1;\n@@ -688,9 +660,8 @@ cttestbinlogbasic()\n     ckresp(fd, \"DELETED\\r\\n\");\n }\n \n-\n void\n-cttestbinlogsizelimit()\n+cttest_binlog_size_limit()\n {\n     int i = 0;\n     char *b2;\n@@ -718,9 +689,8 @@ cttestbinlogsizelimit()\n     assertf(gotsize == size, \"binlog.2 %d != %d\", gotsize, size);\n }\n \n-\n void\n-cttestbinlogallocation()\n+cttest_binlog_allocation()\n {\n     int i = 0;\n \n@@ -744,9 +714,8 @@ cttestbinlogallocation()\n     }\n }\n \n-\n void\n-cttestbinlogread()\n+cttest_binlog_read()\n {\n     srv.wal.dir = ctdir();\n     srv.wal.use = 1;\n@@ -792,9 +761,8 @@ cttestbinlogread()\n     ckresp(fd, \"NOT_FOUND\\r\\n\");\n }\n \n-\n void\n-cttestbinlogdiskfull()\n+cttest_binlog_disk_full()\n {\n     size = 1000;\n     falloc = &wrapfalloc;\n@@ -857,9 +825,8 @@ cttestbinlogdiskfull()\n     ckresp(fd, \"DELETED\\r\\n\");\n }\n \n-\n void\n-cttestbinlogdiskfulldelete()\n+cttest_binlog_disk_full_delete()\n {\n     size = 1000;\n     falloc = &wrapfalloc;\n@@ -924,9 +891,8 @@ cttestbinlogdiskfulldelete()\n     ckresp(fd, \"DELETED\\r\\n\");\n }\n \n-\n void\n-cttestbinlogv5()\n+cttest_binlog_v5()\n {\n     char portstr[10];\n \n@@ -935,8 +901,8 @@ cttestbinlogv5()\n         exit(0);\n     }\n \n-    progname=__func__;\n-    port = (rand()&0xfbff) + 1024;\n+    progname = __func__;\n+    port = (rand() & 0xfbff) + 1024;\n     sprintf(portstr, \"%d\", port);\n     muststart(\"beanstalkd-1.4.6\", \"-b\", ctdir(), \"-p\", portstr);\n     fd = mustdiallocal(port);\n@@ -1097,9 +1063,8 @@ cttestbinlogv5()\n     ckrespsub(fd, \"\\nkicks: 0\\n\");\n }\n \n-\n static void\n-benchputdeletesize(int n, int size)\n+bench_put_delete_size(int n, int size)\n {\n     port = SERVER();\n     fd = mustdiallocal(port);\n@@ -1115,29 +1080,32 @@ benchputdeletesize(int n, int size)\n         mustsend(fd, body);\n         mustsend(fd, \"\\r\\n\");\n         ckrespsub(fd, \"INSERTED \");\n-        sprintf(buf, \"delete %d\\r\\n\", i+1);\n+        sprintf(buf, \"delete %d\\r\\n\", i + 1);\n         mustsend(fd, buf);\n         ckresp(fd, \"DELETED\\r\\n\");\n     }\n }\n \n-\n void\n-ctbenchputdelete8byte(int n)\n+ctbench_put_delete_8(int n)\n {\n-    benchputdeletesize(n, 8);\n+    bench_put_delete_size(n, 8);\n }\n \n-\n void\n-ctbenchputdelete1k(int n)\n+ctbench_put_delete_1k(int n)\n {\n-    benchputdeletesize(n, 1024);\n+    bench_put_delete_size(n, 1024);\n }\n \n+void\n+ctbench_put_delete_8k(int n)\n+{\n+    bench_put_delete_size(n, 8192);\n+}\n \n void\n-ctbenchputdelete8k(int n)\n+ctbench_put_delete_64k(int n)\n {\n-    benchputdeletesize(n, 8192);\n+    bench_put_delete_size(n, 65535);\n }\n\ndiff --git a/testutil.c b/testutil.c\n--- a/testutil.c\n+++ b/testutil.c\n@@ -8,17 +8,16 @@\n #include \"dat.h\"\n \n void\n-cttestallocf()\n+cttest_allocf()\n {\n     char *got;\n \n     got = fmtalloc(\"hello, %s %d\", \"world\", 5);\n     assertf(strcmp(\"hello, world 5\", got) == 0, \"got \\\"%s\\\"\", got);\n }\n \n-\n void\n-cttestoptnone()\n+cttest_opt_none()\n {\n     char *args[] = {\n         NULL,\n@@ -37,16 +36,14 @@ cttestoptnone()\n     assert(verbose == 0);\n }\n \n-\n static void\n success(void)\n {\n     _exit(0);\n }\n \n-\n void\n-cttestoptminus()\n+cttest_optminus()\n {\n     char *args[] = {\n         \"-\",\n@@ -58,9 +55,8 @@ cttestoptminus()\n     assertf(0, \"optparse failed to call exit\");\n }\n \n-\n void\n-cttestoptp()\n+cttest_optp()\n {\n     char *args[] = {\n         \"-p1234\",\n@@ -71,9 +67,8 @@ cttestoptp()\n     assert(strcmp(srv.port, \"1234\") == 0);\n }\n \n-\n void\n-cttestoptl()\n+cttest_optl()\n {\n     char *args[] = {\n         \"-llocalhost\",\n@@ -84,9 +79,8 @@ cttestoptl()\n     assert(strcmp(srv.addr, \"localhost\") == 0);\n }\n \n-\n void\n-cttestoptlseparate()\n+cttest_optlseparate()\n {\n     char *args[] = {\n         \"-l\",\n@@ -98,9 +92,8 @@ cttestoptlseparate()\n     assert(strcmp(srv.addr, \"localhost\") == 0);\n }\n \n-\n void\n-cttestoptz()\n+cttest_optz()\n {\n     char *args[] = {\n         \"-z1234\",\n@@ -111,9 +104,8 @@ cttestoptz()\n     assert(job_data_size_limit == 1234);\n }\n \n-\n void\n-cttestopts()\n+cttest_opts()\n {\n     char *args[] = {\n         \"-s1234\",\n@@ -124,9 +116,8 @@ cttestopts()\n     assert(srv.wal.filesize == 1234);\n }\n \n-\n void\n-cttestoptc()\n+cttest_optc()\n {\n     char *args[] = {\n         \"-n\",\n@@ -138,9 +129,8 @@ cttestoptc()\n     assert(srv.wal.nocomp == 0);\n }\n \n-\n void\n-cttestoptn()\n+cttest_optn()\n {\n     char *args[] = {\n         \"-n\",\n@@ -151,9 +141,8 @@ cttestoptn()\n     assert(srv.wal.nocomp == 1);\n }\n \n-\n void\n-cttestoptf()\n+cttest_optf()\n {\n     char *args[] = {\n         \"-f1234\",\n@@ -165,9 +154,8 @@ cttestoptf()\n     assert(srv.wal.wantsync == 1);\n }\n \n-\n void\n-cttestoptF()\n+cttest_optF()\n {\n     char *args[] = {\n         \"-f1234\",\n@@ -179,9 +167,8 @@ cttestoptF()\n     assert(srv.wal.wantsync == 0);\n }\n \n-\n void\n-cttestoptu()\n+cttest_optu()\n {\n     char *args[] = {\n         \"-ukr\",\n@@ -192,9 +179,8 @@ cttestoptu()\n     assert(strcmp(srv.user, \"kr\") == 0);\n }\n \n-\n void\n-cttestoptb()\n+cttest_optb()\n {\n     char *args[] = {\n         \"-bfoo\",\n@@ -206,9 +192,8 @@ cttestoptb()\n     assert(srv.wal.use == 1);\n }\n \n-\n void\n-cttestoptV()\n+cttest_optV()\n {\n     char *args[] = {\n         \"-V\",\n@@ -219,9 +204,8 @@ cttestoptV()\n     assert(verbose == 1);\n }\n \n-\n void\n-cttestoptV_V()\n+cttest_optV_V()\n {\n     char *args[] = {\n         \"-V\",\n@@ -233,9 +217,8 @@ cttestoptV_V()\n     assert(verbose == 2);\n }\n \n-\n void\n-cttestoptVVV()\n+cttest_optVVV()\n {\n     char *args[] = {\n         \"-VVV\",\n@@ -246,9 +229,8 @@ cttestoptVVV()\n     assert(verbose == 3);\n }\n \n-\n void\n-cttestoptVnVu()\n+cttest_optVnVu()\n {\n     char *args[] = {\n         \"-VnVukr\",\n", "test_patch": "", "problem_statement": "fix tests names for more readable ones\nAll tests functions are more readble since\r\nword are separated with underscores.\r\nRedundant newlines are removed.\r\n\r\nFixes #441", "version": "", "language": "C", "created_at": "2019-07-07T10:26:59Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-564", "repo": "beanstalkd/beanstalkd", "pull_number": 564, "base_commit": "88870638299bab04b4435b6a8aeed879b0c70a38", "patch": "diff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -194,7 +194,8 @@ job_delay_less(void *ja, void *jb)\n Job *\n job_copy(Job *j)\n {\n-    if (!j) return NULL;\n+    if (!j)\n+        return NULL;\n \n     Job *n = malloc(sizeof(Job) + j->r.body_size);\n     if (!n) {\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -1,4 +1,5 @@\n #include \"dat.h\"\n+#include <stdbool.h>\n #include <stdint.h>\n #include <stdlib.h>\n #include <stdio.h>\n@@ -724,21 +725,21 @@ remove_ready_job(Job *j)\n     return j;\n }\n \n-static Job *\n-find_reserved_job_in_conn(Conn *c, Job *j)\n+static bool\n+is_job_reserved_by_conn(Conn *c, Job *j)\n {\n-    return (j && j->reserver == c && j->r.state == Reserved) ? j : NULL;\n+    return j && j->reserver == c && j->r.state == Reserved;\n }\n \n-static Job *\n+static bool\n touch_job(Conn *c, Job *j)\n {\n-    j = find_reserved_job_in_conn(c, j);\n-    if (j) {\n+    if (is_job_reserved_by_conn(c, j)) {\n         j->r.deadline_at = nanoseconds() + j->r.ttr;\n         c->soonest_job = NULL;\n+        return true;\n     }\n-    return j;\n+    return false;\n }\n \n static void\n@@ -1268,15 +1269,18 @@ remove_this_reserved_job(Conn *c, Job *j)\n static Job *\n remove_reserved_job(Conn *c, Job *j)\n {\n-    return remove_this_reserved_job(c, find_reserved_job_in_conn(c, j));\n+    if (!is_job_reserved_by_conn(c, j))\n+        return NULL;\n+    return remove_this_reserved_job(c, j);\n }\n \n-static int\n-name_is_ok(const char *name, size_t max)\n+static bool\n+is_valid_tube(const char *name, size_t max)\n {\n     size_t len = strlen(name);\n-    return len > 0 && len <= max &&\n-        strspn(name, NAME_CHARS) == len && name[0] != '-';\n+    return 0 < len && len <= max &&\n+        strspn(name, NAME_CHARS) == len &&\n+        name[0] != '-';\n }\n \n static void\n@@ -1400,8 +1404,10 @@ dispatch_cmd(Conn *c)\n         }\n         op_ct[type]++;\n \n-        // TODO: simplify the next horror line.\n-        j = job_copy(buried_job_p(c->use) ? j = c->use->buried.next : NULL);\n+        if (buried_job_p(c->use))\n+            j = job_copy(c->use->buried.next);\n+        else\n+            j = NULL;\n \n         if (!j) {\n             reply_msg(c, MSG_NOTFOUND);\n@@ -1650,9 +1656,7 @@ dispatch_cmd(Conn *c)\n         }\n         op_ct[type]++;\n \n-        j = touch_job(c, job_find(id));\n-\n-        if (j) {\n+        if (touch_job(c, job_find(id))) {\n             reply_msg(c, MSG_TOUCHED);\n         } else {\n             reply_msg(c, MSG_NOTFOUND);\n@@ -1692,7 +1696,7 @@ dispatch_cmd(Conn *c)\n \n     case OP_STATS_TUBE:\n         name = c->cmd + CMD_STATS_TUBE_LEN;\n-        if (!name_is_ok(name, MAX_TUBE_NAME_LEN - 1)) {\n+        if (!is_valid_tube(name, MAX_TUBE_NAME_LEN - 1)) {\n             reply_msg(c, MSG_BAD_FORMAT);\n             return;\n         }\n@@ -1739,7 +1743,7 @@ dispatch_cmd(Conn *c)\n \n     case OP_USE:\n         name = c->cmd + CMD_USE_LEN;\n-        if (!name_is_ok(name, MAX_TUBE_NAME_LEN - 1)) {\n+        if (!is_valid_tube(name, MAX_TUBE_NAME_LEN - 1)) {\n             reply_msg(c, MSG_BAD_FORMAT);\n             return;\n         }\n@@ -1761,7 +1765,7 @@ dispatch_cmd(Conn *c)\n \n     case OP_WATCH:\n         name = c->cmd + CMD_WATCH_LEN;\n-        if (!name_is_ok(name, MAX_TUBE_NAME_LEN - 1)) {\n+        if (!is_valid_tube(name, MAX_TUBE_NAME_LEN - 1)) {\n             reply_msg(c, MSG_BAD_FORMAT);\n             return;\n         }\n@@ -1786,7 +1790,7 @@ dispatch_cmd(Conn *c)\n \n     case OP_IGNORE:\n         name = c->cmd + CMD_IGNORE_LEN;\n-        if (!name_is_ok(name, MAX_TUBE_NAME_LEN - 1)) {\n+        if (!is_valid_tube(name, MAX_TUBE_NAME_LEN - 1)) {\n             reply_msg(c, MSG_BAD_FORMAT);\n             return;\n         }\n@@ -1824,7 +1828,7 @@ dispatch_cmd(Conn *c)\n         op_ct[type]++;\n \n         *delay_buf = '\\0';\n-        if (!name_is_ok(name, MAX_TUBE_NAME_LEN - 1)) {\n+        if (!is_valid_tube(name, MAX_TUBE_NAME_LEN - 1)) {\n             reply_msg(c, MSG_BAD_FORMAT);\n             return;\n         }\n", "test_patch": "", "problem_statement": "introduce the bool data type\nThis is to improve readability of some functions:\r\nis_job_reserved_by_conn, touch_job, and is_valid_tube.", "version": "", "language": "C", "created_at": "2019-09-07T14:42:59Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-457", "repo": "beanstalkd/beanstalkd", "pull_number": 457, "base_commit": "d8fbb52d095e60f6e8621ff60581d6cb00f90269", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -17,6 +17,11 @@ typedef uint64_t      uint64;\n #define int64_t  do_not_use_int64_t\n #define uint64_t do_not_use_uint64_t\n \n+/* TODO: typedefs of ms, job and tube should not hide the pointer.\n+   Make them similar to other typedefs (Conn, Heap).\n+   Maybem move each typedef next to the corresponding struct definition.\n+   See issue #458. */\n+\n typedef struct ms     *ms;\n typedef struct job    *job;\n typedef struct tube   *tube;\n\ndiff --git a/linux.c b/linux.c\n--- a/linux.c\n+++ b/linux.c\n@@ -41,7 +41,6 @@ int\n sockwant(Socket *s, int rw)\n {\n     int op;\n-    struct epoll_event ev = {};\n \n     if (!s->added && !rw) {\n         return 0;\n@@ -54,6 +53,7 @@ sockwant(Socket *s, int rw)\n         op = EPOLL_CTL_MOD;\n     }\n \n+    struct epoll_event ev = {.events=0};\n     switch (rw) {\n     case 'r':\n         ev.events = EPOLLIN;\n@@ -73,7 +73,7 @@ int\n socknext(Socket **s, int64 timeout)\n {\n     int r;\n-    struct epoll_event ev;\n+    struct epoll_event ev = {.events=0};\n \n     r = epoll_wait(epfd, &ev, 1, (int)(timeout/1000000));\n     if (r == -1 && errno != EINTR) {\n\ndiff --git a/main.c b/main.c\n--- a/main.c\n+++ b/main.c\n@@ -99,7 +99,7 @@ main(int argc, char **argv)\n             exit(10);\n         }\n \n-        struct job list = {};\n+        struct job list = {.prev=NULL, .next=NULL};\n         list.prev = list.next = &list;\n         walinit(&srv.wal, &list);\n         r = prot_replay(&srv, &list);\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -60,10 +60,11 @@ muststart(char *a0, char *a1, char *a2, char *a3, char *a4)\n static int\n mustdiallocal(int port)\n {\n-    struct sockaddr_in addr = {};\n+    struct sockaddr_in addr = {\n+        .sin_family = AF_INET,\n+        .sin_port = htons(port),\n+    };\n \n-    addr.sin_family = AF_INET;\n-    addr.sin_port = htons(port);\n     int r = inet_aton(\"127.0.0.1\", &addr.sin_addr);\n     if (!r) {\n         errno = EINVAL;\n@@ -167,7 +168,6 @@ mustforksrv(void)\n     prot_init();\n \n     if (srv.wal.use) {\n-        struct job list = {};\n         // We want to make sure that only one beanstalkd tries\n         // to use the wal directory at a time. So acquire a lock\n         // now and never release it.\n@@ -176,6 +176,10 @@ mustforksrv(void)\n             exit(10);\n         }\n \n+        struct job list = {\n+            .prev = NULL,\n+            .next = NULL,\n+        };\n         list.prev = list.next = &list;\n         walinit(&srv.wal, &list);\n         int ok = prot_replay(&srv, &list);\n\ndiff --git a/tube.c b/tube.c\n--- a/tube.c\n+++ b/tube.c\n@@ -21,7 +21,9 @@ make_tube(const char *name)\n     t->delay.less = job_delay_less;\n     t->ready.rec = job_setheappos;\n     t->delay.rec = job_setheappos;\n-    t->buried = (struct job) { };\n+\n+    struct job j = {.tube = NULL};\n+    t->buried = j;\n     t->buried.prev = t->buried.next = &t->buried;\n     ms_init(&t->waiting, NULL, NULL);\n \n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -325,6 +325,137 @@ cttest_too_long_commandline()\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n }\n \n+void\n+cttest_put_in_drain()\n+{\n+    enter_drain_mode(SIGUSR1);\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"x\\r\\n\");\n+    ckresp(fd, \"DRAINING\\r\\n\");\n+}\n+\n+void\n+cttest_peek_ok()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"a\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+\n+    mustsend(fd, \"peek 1\\r\\n\");\n+    ckresp(fd, \"FOUND 1 1\\r\\n\");\n+    ckresp(fd, \"a\\r\\n\");\n+}\n+\n+void\n+cttest_peek_not_found()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"a\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+\n+    mustsend(fd, \"peek 2\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+    mustsend(fd, \"peek 18446744073709551615\\r\\n\");  // max uint64\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+}\n+\n+/*\n+  TODO: Enable this test after fixing #464.\n+void\n+cttest_peek_bad_format()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"peek 18446744073709551616\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+\n+    mustsend(fd, \"peek foo111\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+}\n+*/\n+\n+void\n+cttest_peek_delayed()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"peek-delayed\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"A\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+    mustsend(fd, \"put 0 99 1 1\\r\\n\");\n+    mustsend(fd, \"B\\r\\n\");\n+    ckresp(fd, \"INSERTED 2\\r\\n\");\n+    mustsend(fd, \"put 0 1 1 1\\r\\n\");\n+    mustsend(fd, \"C\\r\\n\");\n+    ckresp(fd, \"INSERTED 3\\r\\n\");\n+\n+    mustsend(fd, \"peek-delayed\\r\\n\");\n+    ckresp(fd, \"FOUND 3 1\\r\\n\");\n+    ckresp(fd, \"C\\r\\n\");\n+\n+    mustsend(fd, \"delete 3\\r\\n\");\n+    ckresp(fd, \"DELETED\\r\\n\");\n+\n+    mustsend(fd, \"peek-delayed\\r\\n\");\n+    ckresp(fd, \"FOUND 2 1\\r\\n\");\n+    ckresp(fd, \"B\\r\\n\");\n+\n+    mustsend(fd, \"delete 2\\r\\n\");\n+    ckresp(fd, \"DELETED\\r\\n\");\n+\n+    mustsend(fd, \"peek-delayed\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+}\n+\n+void\n+cttest_peek_buried_kick()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"A\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+\n+    mustsend(fd, \"bury 1 0\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+\n+    mustsend(fd, \"peek-buried\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+\n+    mustsend(fd, \"reserve-with-timeout 0\\r\\n\");\n+    ckresp(fd, \"RESERVED 1 1\\r\\n\");\n+    ckresp(fd, \"A\\r\\n\");\n+\n+    mustsend(fd, \"bury 1 0\\r\\n\");\n+    ckresp(fd, \"BURIED\\r\\n\");\n+\n+    mustsend(fd, \"peek-buried\\r\\n\");\n+    ckresp(fd, \"FOUND 1 1\\r\\n\");\n+    ckresp(fd, \"A\\r\\n\");\n+\n+    mustsend(fd, \"kick 1\\r\\n\");\n+    ckresp(fd, \"KICKED 1\\r\\n\");\n+\n+    mustsend(fd, \"peek-buried\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+\n+    mustsend(fd, \"peek-ready\\r\\n\");\n+    ckresp(fd, \"FOUND 1 1\\r\\n\");\n+    ckresp(fd, \"A\\r\\n\");\n+\n+    mustsend(fd, \"kick 1\\r\\n\");\n+    ckresp(fd, \"KICKED 0\\r\\n\");\n+}\n+\n void\n cttest_pause()\n {\n@@ -677,6 +808,68 @@ cttest_reserve_with_timeout_2conns()\n     ckresp(fd0, \"TIMED_OUT\\r\\n\");\n }\n \n+void\n+cttest_reserve_ttr_deadline_soon()\n+{\n+    port = SERVER();\n+    int prod = mustdiallocal(port);\n+\n+    mustsend(prod, \"put 0 0 1 1\\r\\n\");\n+    mustsend(prod, \"a\\r\\n\");\n+    ckresp(prod, \"INSERTED 1\\r\\n\");\n+\n+    mustsend(prod, \"reserve-with-timeout 1\\r\\n\");\n+    ckresp(prod, \"RESERVED 1 1\\r\\n\");\n+    ckresp(prod, \"a\\r\\n\");\n+\n+    // After 0.5s the job should be still reserved.\n+    usleep(500000);\n+    mustsend(prod, \"stats-job 1\\r\\n\");\n+    ckrespsub(prod, \"OK \");\n+    ckrespsub(prod, \"\\nstate: reserved\\n\");\n+\n+    mustsend(prod, \"reserve-with-timeout 1\\r\\n\");\n+    ckresp(prod, \"DEADLINE_SOON\\r\\n\");\n+\n+    // Job should be reserved; last \"reserve\" took less than 1s.\n+    mustsend(prod, \"stats-job 1\\r\\n\");\n+    ckrespsub(prod, \"OK \");\n+    ckrespsub(prod, \"\\nstate: reserved\\n\");\n+\n+    // After 0.7s the job should time out and be ready again.\n+    usleep(700000);\n+    mustsend(prod, \"stats-job 1\\r\\n\");\n+    ckrespsub(prod, \"OK \");\n+    ckrespsub(prod, \"\\nstate: ready\\n\");\n+}\n+\n+void\n+cttest_close_frees_job()\n+{\n+    port = SERVER();\n+    int cons = mustdiallocal(port);\n+    int prod = mustdiallocal(port);\n+    mustsend(cons, \"reserve-with-timeout 1\\r\\n\");\n+\n+    mustsend(prod, \"put 0 0 100 1\\r\\n\");\n+    mustsend(prod, \"a\\r\\n\");\n+    ckresp(prod, \"INSERTED 1\\r\\n\");\n+\n+    ckresp(cons, \"RESERVED 1 1\\r\\n\");\n+    ckresp(cons, \"a\\r\\n\");\n+\n+    mustsend(prod, \"stats-job 1\\r\\n\");\n+    ckrespsub(prod, \"OK \");\n+    ckrespsub(prod, \"\\nstate: reserved\\n\");\n+\n+    // Closed consumer connection should make the job ready again.\n+    close(cons);\n+\n+    mustsend(prod, \"stats-job 1\\r\\n\");\n+    ckrespsub(prod, \"OK \");\n+    ckrespsub(prod, \"\\nstate: ready\\n\");\n+}\n+\n void\n cttest_unpause_tube()\n {\n@@ -704,6 +897,49 @@ cttest_unpause_tube()\n     ckresp(fd1, \"\\r\\n\");\n }\n \n+void\n+cttest_list_tube()\n+{\n+    port = SERVER();\n+    int fd0 = mustdiallocal(port);\n+\n+    mustsend(fd0, \"watch w\\r\\n\");\n+    ckresp(fd0, \"WATCHING 2\\r\\n\");\n+\n+    mustsend(fd0, \"use u\\r\\n\");\n+    ckresp(fd0, \"USING u\\r\\n\");\n+\n+    mustsend(fd0, \"list-tubes\\r\\n\");\n+    ckrespsub(fd0, \"OK \");\n+    ckresp(fd0,\n+           \"---\\n\"\n+           \"- default\\n\"\n+           \"- w\\n\"\n+           \"- u\\n\\r\\n\");\n+\n+    mustsend(fd0, \"list-tube-used\\r\\n\");\n+    ckresp(fd0, \"USING u\\r\\n\");\n+\n+    mustsend(fd0, \"list-tubes-watched\\r\\n\");\n+    ckrespsub(fd0, \"OK \");\n+    ckresp(fd0,\n+           \"---\\n\"\n+           \"- default\\n\"\n+           \"- w\\n\\r\\n\");\n+\n+    mustsend(fd0, \"ignore default\\r\\n\");\n+    ckresp(fd0, \"WATCHING 1\\r\\n\");\n+\n+    mustsend(fd0, \"list-tubes-watched\\r\\n\");\n+    ckrespsub(fd0, \"OK \");\n+    ckresp(fd0,\n+           \"---\\n\"\n+           \"- w\\n\\r\\n\");\n+\n+    mustsend(fd0, \"ignore w\\r\\n\");\n+    ckresp(fd0, \"NOT_IGNORED\\r\\n\");\n+}\n+\n void\n cttest_binlog_empty_exit()\n {\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -822,8 +822,8 @@ cttest_reserve_ttr_deadline_soon()\n     ckresp(prod, \"RESERVED 1 1\\r\\n\");\n     ckresp(prod, \"a\\r\\n\");\n \n-    // After 0.5s the job should be still reserved.\n-    usleep(500000);\n+    // After 0.3s the job should be still reserved.\n+    usleep(300000);\n     mustsend(prod, \"stats-job 1\\r\\n\");\n     ckrespsub(prod, \"OK \");\n     ckrespsub(prod, \"\\nstate: reserved\\n\");\n@@ -836,8 +836,9 @@ cttest_reserve_ttr_deadline_soon()\n     ckrespsub(prod, \"OK \");\n     ckrespsub(prod, \"\\nstate: reserved\\n\");\n \n-    // After 0.7s the job should time out and be ready again.\n-    usleep(700000);\n+    // We don't want to process the job, so release it and check that it's ready.\n+    mustsend(prod, \"release 1 0 0\\r\\n\");\n+    ckresp(prod, \"RELEASED\\r\\n\");\n     mustsend(prod, \"stats-job 1\\r\\n\");\n     ckrespsub(prod, \"OK \");\n     ckrespsub(prod, \"\\nstate: ready\\n\");\n", "test_patch": "", "problem_statement": "fix struct initializers to fix -Wextra warnings\nUpdates #443", "version": "", "language": "C", "created_at": "2019-07-11T14:10:38Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-569", "repo": "beanstalkd/beanstalkd", "pull_number": 569, "base_commit": "0fcf38b1782b10cbdb2ee03a79a401812c612663", "patch": "diff --git a/doc/protocol.zh-CN.md b/doc/protocol.zh-CN.md\n--- a/doc/protocol.zh-CN.md\n+++ b/doc/protocol.zh-CN.md\n@@ -95,8 +95,8 @@ put <pri> <delay> <ttr> <bytes>\\r\\n\n ```\n \n * `<pri>` \u6574\u578b\u503c, \u4e3a\u4f18\u5148\u7ea7, \u53ef\u4ee5\u4e3a0-2^32 (4,294,967,295) \u503c\u8d8a\u5c0f\u4f18\u5148\u7ea7\u8d8a\u9ad8, \u9ed8\u8ba4\u4e3a1024.\n-* `<delay>` \u6574\u578b\u503c\uff0c\u5ef6\u8fdf`ready`\u7684\u79d2\u6570\uff0c\u5728\u8fd9\u6bb5\u65f6\u95f4 job \u4e3a `delayed` \u72b6\u6001.\n-* `<ttr>` -- time to run --\u6574\u578b\u503c\uff0c\u5141\u8bb8 worker \u6267\u884c\u7684\u6700\u5927\u79d2\u6570\uff0c\u5982\u679c worker \u5728\u8fd9\u6bb5\u65f6\u95f4\u4e0d\u80fd delete\uff0crelease\uff0cbury job\uff0c\u90a3\u4e48\u5f53 job \u8d85\u65f6\uff0c\u670d\u52a1\u5668\u5c06**\u81ea\u52a8** release \u6b64job\uff0c\u6b64 job \u7684\u72b6\u6001\u8fc1\u79fb\u4e3a`ready`. \u6700\u5c0f\u4e3a 1 \u79d2\uff0c\u5982\u679c\u5ba2\u6237\u7aef\u6307\u5b9a\u4e3a 0 \u5c06\u4f1a\u88ab\u91cd\u7f6e\u4e3a 1.\n+* `<delay>` \u6574\u578b\u503c\uff0c\u5ef6\u8fdf`ready`\u7684\u79d2\u6570\uff0c\u5728\u8fd9\u6bb5\u65f6\u95f4 job \u4e3a `delayed` \u72b6\u6001. \u6700\u5927 delay \u503c\u4e3a 2^32-1.\n+* `<ttr>` -- time to run --\u6574\u578b\u503c\uff0c\u5141\u8bb8 worker \u6267\u884c\u7684\u6700\u5927\u79d2\u6570\uff0c\u5982\u679c worker \u5728\u8fd9\u6bb5\u65f6\u95f4\u4e0d\u80fd delete\uff0crelease\uff0cbury job\uff0c\u90a3\u4e48\u5f53 job \u8d85\u65f6\uff0c\u670d\u52a1\u5668\u5c06**\u81ea\u52a8** release \u6b64job\uff0c\u6b64 job \u7684\u72b6\u6001\u8fc1\u79fb\u4e3a`ready`. \u6700\u5c0f\u4e3a 1 \u79d2\uff0c\u5982\u679c\u5ba2\u6237\u7aef\u6307\u5b9a\u4e3a 0 \u5c06\u4f1a\u88ab\u91cd\u7f6e\u4e3a 1. \u6700\u5927 ttr \u503c\u4e3a 2^32-1.\n * `<bytes>` \u6574\u578b\u503c\uff0cjob body\u7684\u957f\u5ea6\uff0c\u4e0d\u5305\u542b`\\r\\n`\uff0c\u8fd9\u4e2a\u503c\u5fc5\u987b\u5c0f\u4e8e `max-job-size`\uff0c\u9ed8\u8ba4\u4e3a 2^16.\n * `<data>`   job body\n \n", "test_patch": "", "problem_statement": "add delay ttr maximum value\nhttps://github.com/beanstalkd/beanstalkd/blob/master/doc/protocol.txt#L137-L139\r\n\r\nhttps://github.com/beanstalkd/beanstalkd/blob/master/doc/protocol.txt#L146", "version": "", "language": "C", "created_at": "2019-11-05T05:40:09Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-547", "repo": "beanstalkd/beanstalkd", "pull_number": 547, "base_commit": "3be232879979e46a0c6fb51de1f90aaa2d981af8", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -251,9 +251,8 @@ struct Tube {\n     // pause is set to the duration of the current pause, otherwise 0, in nsec.\n     int64 pause;\n \n-    // dealine_at is a timestamp when to unpause the tube, in nsec.\n-    // TODO: rename to unpause_at\n-    int64 deadline_at;\n+    // unpause_at is a timestamp when to unpause the tube, in nsec.\n+    int64 unpause_at;\n \n     Job buried;                 // linked list header\n };\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -447,20 +447,20 @@ reserve_job(Conn *c, Job *j)\n     reply_job(c, j, MSG_RESERVED);\n }\n \n-// next_eligible_job iterates through all the tubes with awaiting connections,\n+// next_awaited_job iterates through all the tubes with awaiting connections,\n // returns the next ready job with the smallest priority.\n // If jobs has the same priority it picks the job with smaller id.\n-// All paused tubes with expired pause deadline are unpaused.\n+// All tubes with expired pause are unpaused.\n static Job *\n-next_eligible_job(int64 now)\n+next_awaited_job(int64 now)\n {\n     size_t i;\n     Job *j = NULL;\n \n     for (i = 0; i < tubes.len; i++) {\n         Tube *t = tubes.items[i];\n         if (t->pause) {\n-            if (t->deadline_at > now)\n+            if (t->unpause_at > now)\n                 continue;\n             t->pause = 0;\n         }\n@@ -481,17 +481,19 @@ process_queue()\n     Job *j = NULL;\n     int64 now = nanoseconds();\n \n-    while ((j = next_eligible_job(now))) {\n+    while ((j = next_awaited_job(now))) {\n         heapremove(&j->tube->ready, j->heap_index);\n         ready_ct--;\n         if (j->r.pri < URGENT_THRESHOLD) {\n             global_stat.urgent_ct--;\n             j->tube->stat.urgent_ct--;\n         }\n         Conn *next = ms_take(&j->tube->waiting_conns);\n+        if (next==NULL) {\n+            twarnx(\"waiting_conns is empty\");\n+            continue;\n+        }\n         next = remove_waiting_conn(next);\n-        // If next==NULL here, we have a bug. See the call above.\n-        // TODO: Report this bug on stderr and skip the conn.\n         reserve_job(next, j);\n     }\n }\n@@ -1198,7 +1200,7 @@ fmt_stats_tube(char *buf, size_t size, Tube *t)\n     uint64 time_left;\n \n     if (t->pause > 0) {\n-        time_left = (t->deadline_at - nanoseconds()) / 1000000000;\n+        time_left = (t->unpause_at - nanoseconds()) / 1000000000;\n     } else {\n         time_left = 0;\n     }\n@@ -1779,7 +1781,7 @@ dispatch_cmd(Conn *c)\n             delay = 1;\n         }\n \n-        t->deadline_at = nanoseconds() + delay;\n+        t->unpause_at = nanoseconds() + delay;\n         t->pause = delay;\n         t->stat.pause_ct++;\n \n@@ -2080,7 +2082,7 @@ prottick(Server *s)\n     size_t i;\n     for (i = 0; i < tubes.len; i++) {\n         t = tubes.items[i];\n-        d = t->deadline_at - now;\n+        d = t->unpause_at - now;\n         if (t->pause && d <= 0) {\n             t->pause = 0;\n             process_queue();\n", "test_patch": "", "problem_statement": "rename deadline_at to unpause_at\nAnd do collateral renames to improve clarity.\r\nAdd a check for not NULL invariant.", "version": "", "language": "C", "created_at": "2019-08-15T06:37:32Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-611", "repo": "beanstalkd/beanstalkd", "pull_number": 611, "base_commit": "e7ae45b08c91827b15b736350754621cc9cfcf7c", "patch": "diff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -186,13 +186,13 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n     \"binlog-max-size: %d\\n\" \\\n     \"draining: %s\\n\" \\\n     \"id: %s\\n\" \\\n-    \"hostname: %s\\n\" \\\n+    \"hostname: \\\"%s\\\"\\n\" \\\n     \"os: \\\"%s\\\"\\n\" \\\n-    \"platform: %s\\n\" \\\n+    \"platform: \\\"%s\\\"\\n\" \\\n     \"\\r\\n\"\n \n #define STATS_TUBE_FMT \"---\\n\" \\\n-    \"name: %s\\n\" \\\n+    \"name: \\\"%s\\\"\\n\" \\\n     \"current-jobs-urgent: %\" PRIu64 \"\\n\" \\\n     \"current-jobs-ready: %zu\\n\" \\\n     \"current-jobs-reserved: %\" PRIu64 \"\\n\" \\\n@@ -210,7 +210,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n \n #define STATS_JOB_FMT \"---\\n\" \\\n     \"id: %\" PRIu64 \"\\n\" \\\n-    \"tube: %s\\n\" \\\n+    \"tube: \\\"%s\\\"\\n\" \\\n     \"state: %s\\n\" \\\n     \"pri: %u\\n\" \\\n     \"age: %\" PRId64 \"\\n\" \\\n", "test_patch": "", "problem_statement": "Quote string values in yaml dictionaries\nApplies the fix from #592  to other string keys.\r\n\r\nFixes #610", "version": "", "language": "C", "created_at": "2021-12-30T13:27:19Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-594", "repo": "beanstalkd/beanstalkd", "pull_number": 594, "base_commit": "2080177258b46b274d51d1a9f8fadc09d0e351a5", "patch": "diff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -191,8 +191,8 @@ mustforksrv(void)\n         exit(1);\n     }\n \n-    size_t len = sizeof(addr);\n-    int r = getsockname(srv.sock.fd, (struct sockaddr *)&addr, (socklen_t *)&len);\n+    socklen_t len = sizeof(addr);\n+    int r = getsockname(srv.sock.fd, (struct sockaddr *)&addr, &len);\n     if (r == -1 || len > sizeof(addr)) {\n         puts(\"mustforksrv failed\");\n         exit(1);\n", "test_patch": "", "problem_statement": "Test failures on big-endian systems\nThis PR fixes a test failure on big-endian systems (e.g., s390x, ppc64, sparc64) caused by an invalid pointer cast from `size_t*` to `socklen_t*`. On these platforms, `size_t` is 8 bytes and `socklen_t` is 4 bytes; casting a `size_t*` to `socklen_t*` and writing via the casted pointer modifies the 4 most significant bytes due to big-endian byte order, leaving garbage in the `size_t` value\u2014e.g., storing 4 results in 4 << 32 = 17179869184. This corrupts the `addrlen` argument to `getsockname()` in `mustforksrv()`, causing test failure. The fix replaces the misaligned cast with a properly typed `socklen_t` variable, avoiding type-punning and ensuring correct memory access. This restores reliable test execution on big-endian architectures.", "version": "", "language": "C", "created_at": "2020-09-24T07:12:06Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-525", "repo": "beanstalkd/beanstalkd", "pull_number": 525, "base_commit": "7068cb2b2092f5cc23f2f39c836630d4fa2efb33", "patch": "diff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -138,16 +138,6 @@ conntickat(Conn *c)\n }\n \n \n-// TODO: remove this function by inlining its content into 3 callees places.\n-// Reason: conn.c does not use rw anywhere in this file.\n-void\n-connwant(Conn *c, int rw)\n-{\n-    c->rw = rw;\n-    connsched(c);\n-}\n-\n-\n // Remove c from the c->srv heap and reschedule it using the value\n // returned by conntickat if there is an outstanding timeout in the c.\n void\n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -368,7 +368,6 @@ struct Conn {\n };\n int  conn_less(void *ca, void *cb);\n void conn_setpos(void *c, size_t i);\n-void connwant(Conn *c, int rw);\n void connsched(Conn *c);\n void connclose(Conn *c);\n void connsetproducer(Conn *c);\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -235,6 +235,9 @@ static char instance_hex[instance_id_bytes * 2 + 1]; // hex-encoded len of insta\n static struct utsname node_info;\n static uint64 op_ct[TOTAL_OPS], timeout_ct = 0;\n \n+// Single linked list that holds connections\n+// that required update in polling mechanism by update_conns().\n+// TODO: rename to epoll_changes?\n static Conn *dirty;\n \n static const char * op_names[] = {\n@@ -274,33 +277,26 @@ buried_job_p(Tube *t)\n }\n \n static void\n-reply(Conn *c, char *line, int len, int state)\n-{\n-    if (!c) return;\n-\n-    connwant(c, 'w');\n+dirty_add(Conn *c, char rw) {\n+    c->rw = rw;\n+    connsched(c);\n     c->next = dirty;\n     dirty = c;\n-    c->reply = line;\n-    c->reply_len = len;\n-    c->reply_sent = 0;\n-    c->state = state;\n-    if (verbose >= 2) {\n-        printf(\">%d reply %.*s\\n\", c->sock.fd, len-2, line);\n-    }\n }\n \n-\n+// Remove connection c from the dirty.\n static void\n-protrmdirty(Conn *c)\n+dirty_rmconn(Conn *c)\n {\n     Conn *x, *newdirty = NULL;\n \n     while (dirty) {\n+        // x as next element from dirty.\n         x = dirty;\n         dirty = dirty->next;\n         x->next = NULL;\n \n+        // put x back into newdirty list.\n         if (x != c) {\n             x->next = newdirty;\n             newdirty = x;\n@@ -309,11 +305,28 @@ protrmdirty(Conn *c)\n     dirty = newdirty;\n }\n \n+#define reply_msg(c, m) \\\n+    reply((c), (m), CONSTSTRLEN(m), STATE_SENDWORD)\n+\n+#define reply_serr(c, e) \\\n+    (twarnx(\"server error: %s\", (e)), reply_msg((c), (e)))\n \n-#define reply_msg(c,m) reply((c),(m),CONSTSTRLEN(m),STATE_SENDWORD)\n+static void\n+reply(Conn *c, char *line, int len, int state)\n+{\n+    if (!c)\n+        return;\n \n-#define reply_serr(c,e) (twarnx(\"server error: %s\",(e)),\\\n-                         reply_msg((c),(e)))\n+    dirty_add(c, 'w');\n+\n+    c->reply = line;\n+    c->reply_len = len;\n+    c->reply_sent = 0;\n+    c->state = state;\n+    if (verbose >= 2) {\n+        printf(\">%d reply %.*s\\n\", c->sock.fd, len-2, line);\n+    }\n+}\n \n static void\n reply_line(Conn*, int, const char*, ...)\n@@ -1045,9 +1058,8 @@ wait_for_job(Conn *c, int timeout)\n     /* Set the pending timeout to the requested timeout amount */\n     c->pending_timeout = timeout;\n \n-    connwant(c, 'h'); // only care if they hang up\n-    c->next = dirty;\n-    dirty = c;\n+    // only care if they hang up\n+    dirty_add(c, 'h');\n }\n \n typedef int(*fmt_fn)(char *, size_t, void *);\n@@ -1815,9 +1827,7 @@ enter_drain_mode(int sig)\n static void\n reset_conn(Conn *c)\n {\n-    connwant(c, 'r');\n-    c->next = dirty;\n-    dirty = c;\n+    dirty_add(c, 'r');\n \n     /* was this a peek or stats command? */\n     if (c->out_job && c->out_job->r.state == Copy) job_free(c->out_job);\n@@ -1983,6 +1993,9 @@ conn_data(Conn *c)\n #define want_command(c) ((c)->sock.fd && ((c)->state == STATE_WANTCOMMAND))\n #define cmd_data_ready(c) (want_command(c) && (c)->cmd_read)\n \n+// TODO: rename it to epoll_changes_apply()? If so then:\n+// dirty_add()    -> epoll_changes_add()\n+// dirty_rmconn() -> epoll_changes_rmconn()\n static void\n update_conns()\n {\n@@ -2021,7 +2034,7 @@ h_conn(const int fd, const short which, Conn *c)\n         fill_extra_data(c);\n     }\n     if (c->state == STATE_CLOSE) {\n-        protrmdirty(c);\n+        dirty_rmconn(c);\n         connclose(c);\n     }\n     update_conns();\n@@ -2150,8 +2163,6 @@ h_accept(const int fd, const short which, Server *s)\n         if (verbose) {\n             printf(\"close %d\\n\", cfd);\n         }\n-        update_conns();\n-        return;\n     }\n     update_conns();\n }\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -1098,8 +1098,39 @@ cttest_close_releases_job()\n     // Closed consumer connection should make the job ready sooner than ttr=100.\n     close(cons);\n \n-    // Job should be released in less than 1s. It is low expectation,\n-    // but we do not make guarantees about how soon jobs should be released.\n+    // Job should be released in less than 1s. It is not instantly;\n+    // we do not make guarantees about how soon jobs should be released.\n+    mustsend(prod, \"reserve-with-timeout 1\\r\\n\");\n+    ckresp(prod, \"RESERVED 1 1\\r\\n\");\n+    ckresp(prod, \"a\\r\\n\");\n+}\n+\n+void\n+cttest_quit_releases_job()\n+{\n+    // This test is similar to the close_releases_job test, except that\n+    // connection is not closed, but command quit is sent.\n+    int port = SERVER();\n+    int cons = mustdiallocal(port);\n+    int prod = mustdiallocal(port);\n+    mustsend(cons, \"reserve-with-timeout 1\\r\\n\");\n+\n+    mustsend(prod, \"put 0 0 100 1\\r\\n\");\n+    mustsend(prod, \"a\\r\\n\");\n+    ckresp(prod, \"INSERTED 1\\r\\n\");\n+\n+    ckresp(cons, \"RESERVED 1 1\\r\\n\");\n+    ckresp(cons, \"a\\r\\n\");\n+\n+    mustsend(prod, \"stats-job 1\\r\\n\");\n+    ckrespsub(prod, \"OK \");\n+    ckrespsub(prod, \"\\nstate: reserved\\n\");\n+\n+    // Quitting consumer should make the job ready sooner than ttr=100.\n+    mustsend(cons, \"quit\\r\\n\");\n+\n+    // Job should be released in less than 1s. It is not instantly;\n+    // we do not make guarantees about how soon jobs should be released.\n     mustsend(prod, \"reserve-with-timeout 1\\r\\n\");\n     ckresp(prod, \"RESERVED 1 1\\r\\n\");\n     ckresp(prod, \"a\\r\\n\");\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -235,10 +235,9 @@ static char instance_hex[instance_id_bytes * 2 + 1]; // hex-encoded len of insta\n static struct utsname node_info;\n static uint64 op_ct[TOTAL_OPS], timeout_ct = 0;\n \n-// Single linked list that holds connections\n-// that required update in polling mechanism by update_conns().\n-// TODO: rename to epoll_changes?\n-static Conn *dirty;\n+// Single linked list with connections that require updates\n+// in the event notification mechanism.\n+static Conn *epollq;\n \n static const char * op_names[] = {\n     \"<unknown>\",\n@@ -277,32 +276,51 @@ buried_job_p(Tube *t)\n }\n \n static void\n-dirty_add(Conn *c, char rw) {\n+epollq_add(Conn *c, char rw) {\n     c->rw = rw;\n     connsched(c);\n-    c->next = dirty;\n-    dirty = c;\n+    c->next = epollq;\n+    epollq = c;\n }\n \n-// Remove connection c from the dirty.\n+// Remove connection c from the epollq.\n static void\n-dirty_rmconn(Conn *c)\n+epollq_rmconn(Conn *c)\n {\n-    Conn *x, *newdirty = NULL;\n+    Conn *x, *newhead = NULL;\n \n-    while (dirty) {\n-        // x as next element from dirty.\n-        x = dirty;\n-        dirty = dirty->next;\n+    while (epollq) {\n+        // x as next element from epollq.\n+        x = epollq;\n+        epollq = epollq->next;\n         x->next = NULL;\n \n-        // put x back into newdirty list.\n+        // put x back into newhead list.\n         if (x != c) {\n-            x->next = newdirty;\n-            newdirty = x;\n+            x->next = newhead;\n+            newhead = x;\n+        }\n+    }\n+    epollq = newhead;\n+}\n+\n+// Propagate changes to event notification mechanism about wanted responses\n+// from connections. Clear the epollq list.\n+static void\n+epollq_apply()\n+{\n+    Conn *c;\n+\n+    while (epollq) {\n+        c = epollq;\n+        epollq = epollq->next;\n+        c->next = NULL;\n+        int r = sockwant(&c->sock, c->rw);\n+        if (r == -1) {\n+            twarn(\"sockwant\");\n+            connclose(c);\n         }\n     }\n-    dirty = newdirty;\n }\n \n #define reply_msg(c, m) \\\n@@ -317,7 +335,7 @@ reply(Conn *c, char *line, int len, int state)\n     if (!c)\n         return;\n \n-    dirty_add(c, 'w');\n+    epollq_add(c, 'w');\n \n     c->reply = line;\n     c->reply_len = len;\n@@ -1059,7 +1077,7 @@ wait_for_job(Conn *c, int timeout)\n     c->pending_timeout = timeout;\n \n     // only care if they hang up\n-    dirty_add(c, 'h');\n+    epollq_add(c, 'h');\n }\n \n typedef int(*fmt_fn)(char *, size_t, void *);\n@@ -1827,7 +1845,7 @@ enter_drain_mode(int sig)\n static void\n reset_conn(Conn *c)\n {\n-    dirty_add(c, 'r');\n+    epollq_add(c, 'r');\n \n     /* was this a peek or stats command? */\n     if (c->out_job && c->out_job->r.state == Copy) job_free(c->out_job);\n@@ -1993,34 +2011,14 @@ conn_data(Conn *c)\n #define want_command(c) ((c)->sock.fd && ((c)->state == STATE_WANTCOMMAND))\n #define cmd_data_ready(c) (want_command(c) && (c)->cmd_read)\n \n-// TODO: rename it to epoll_changes_apply()? If so then:\n-// dirty_add()    -> epoll_changes_add()\n-// dirty_rmconn() -> epoll_changes_rmconn()\n-static void\n-update_conns()\n-{\n-    Conn *c;\n-\n-    while (dirty) {\n-        c = dirty;\n-        dirty = dirty->next;\n-        c->next = NULL;\n-        int r = sockwant(&c->sock, c->rw);\n-        if (r == -1) {\n-            twarn(\"sockwant\");\n-            connclose(c);\n-        }\n-    }\n-}\n-\n static void\n h_conn(const int fd, const short which, Conn *c)\n {\n     if (fd != c->sock.fd) {\n         twarnx(\"Argh! event fd doesn't match conn fd.\");\n         close(fd);\n         connclose(c);\n-        update_conns();\n+        epollq_apply();\n         return;\n     }\n \n@@ -2034,10 +2032,10 @@ h_conn(const int fd, const short which, Conn *c)\n         fill_extra_data(c);\n     }\n     if (c->state == STATE_CLOSE) {\n-        dirty_rmconn(c);\n+        epollq_rmconn(c);\n         connclose(c);\n     }\n-    update_conns();\n+    epollq_apply();\n }\n \n static void\n@@ -2097,7 +2095,7 @@ prottick(Server *s)\n         conn_timeout(c);\n     }\n \n-    update_conns();\n+    epollq_apply();\n \n     return period;\n }\n@@ -2112,7 +2110,7 @@ h_accept(const int fd, const short which, Server *s)\n     int cfd = accept(fd, (struct sockaddr *)&addr, &addrlen);\n     if (cfd == -1) {\n         if (errno != EAGAIN && errno != EWOULDBLOCK) twarn(\"accept()\");\n-        update_conns();\n+        epollq_apply();\n         return;\n     }\n     if (verbose) {\n@@ -2126,7 +2124,7 @@ h_accept(const int fd, const short which, Server *s)\n         if (verbose) {\n             printf(\"close %d\\n\", cfd);\n         }\n-        update_conns();\n+        epollq_apply();\n         return;\n     }\n \n@@ -2137,7 +2135,7 @@ h_accept(const int fd, const short which, Server *s)\n         if (verbose) {\n             printf(\"close %d\\n\", cfd);\n         }\n-        update_conns();\n+        epollq_apply();\n         return;\n     }\n \n@@ -2148,7 +2146,7 @@ h_accept(const int fd, const short which, Server *s)\n         if (verbose) {\n             printf(\"close %d\\n\", cfd);\n         }\n-        update_conns();\n+        epollq_apply();\n         return;\n     }\n     c->srv = s;\n@@ -2164,7 +2162,7 @@ h_accept(const int fd, const short which, Server *s)\n             printf(\"close %d\\n\", cfd);\n         }\n     }\n-    update_conns();\n+    epollq_apply();\n }\n \n void\n", "test_patch": "", "problem_statement": "refactor the code controlling events for sockets\nThe name \"dirty\" did not reveal the purpose of the variable.\r\nI've renamed it to \"epollq\".\r\n\r\nI have removed connwant() and moved its functionality into introduced\r\nfunction epollq_add(). This function adds a connection as pending for\r\npolling change. protrmdirty() was renamed to epollq_rmconn().\r\nupdate_conns() was renamed to epollq_apply().\r\n\r\nI added a test checking the \"quit\" command.\r\n\r\nFixes #524", "version": "", "language": "C", "created_at": "2019-08-04T15:42:50Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-607", "repo": "beanstalkd/beanstalkd", "pull_number": 607, "base_commit": "51a079455d4b511e72c3f9f53547ffed3a79c967", "patch": "diff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -15,6 +15,7 @@\n #include <inttypes.h>\n #include <stdarg.h>\n #include <signal.h>\n+#include <limits.h>\n \n /* job body cannot be greater than this many bytes long */\n size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n@@ -1435,11 +1436,12 @@ dispatch_cmd(Conn *c)\n \n     case OP_RESERVE_TIMEOUT:\n         errno = 0;\n-        timeout = strtol(c->cmd + CMD_RESERVE_TIMEOUT_LEN, &end_buf, 10);\n-        if (errno) {\n+        unsigned int utimeout = 0;\n+        if (read_u32(&utimeout, c->cmd + CMD_RESERVE_TIMEOUT_LEN, &end_buf) != 0 || utimeout > INT_MAX) {\n             reply_msg(c, MSG_BAD_FORMAT);\n             return;\n         }\n+        timeout = (int)utimeout;\n         /* Falls through */\n \n     case OP_RESERVE:\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -1436,7 +1436,7 @@ dispatch_cmd(Conn *c)\n \n     case OP_RESERVE_TIMEOUT:\n         errno = 0;\n-        unsigned int utimeout = 0;\n+        uint32 utimeout = 0;\n         if (read_u32(&utimeout, c->cmd + CMD_RESERVE_TIMEOUT_LEN, &end_buf) != 0 || utimeout > INT_MAX) {\n             reply_msg(c, MSG_BAD_FORMAT);\n             return;\n", "test_patch": "", "problem_statement": "use read_u32 to safely read reserve-with-timeout argument\nFixes #606.", "version": "", "language": "C", "created_at": "2021-10-12T19:05:03Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-150", "repo": "beanstalkd/beanstalkd", "pull_number": 150, "base_commit": "a017423d28019492f2bf144d574d2d0ba696177e", "patch": "diff --git a/net.c b/net.c\n--- a/net.c\n+++ b/net.c\n@@ -7,143 +7,239 @@\n #include <string.h>\n #include <errno.h>\n #include <sys/socket.h>\n+#include <sys/un.h>\n+#include <sys/stat.h>\n #include <netinet/in.h>\n #include <netinet/tcp.h>\n \n-int\n-make_server_socket(char *host, char *port)\n+static int\n+set_nonblocking(int fd)\n {\n-    int fd = -1, flags, r;\n-    struct linger linger = {0, 0};\n-    struct addrinfo *airoot, *ai, hints;\n+    int flags, r;\n \n-    /* See if we got a listen fd from systemd. If so, all socket options etc\n-     * are already set, so we check that the fd is a TCP listen socket and\n-     * return. */\n-    r = sd_listen_fds(1);\n-    if (r < 0) {\n-        return twarn(\"sd_listen_fds\"), -1;\n+    flags = fcntl(fd, F_GETFL, 0);\n+    if (flags < 0) {\n+        twarn(\"getting flags\");\n+        return -1;\n     }\n-    if (r > 0) {\n-        if (r > 1) {\n-            twarnx(\"inherited more than one listen socket;\"\n-                   \" ignoring all but the first\");\n-        }\n-        fd = SD_LISTEN_FDS_START;\n-        r = sd_is_socket_inet(fd, 0, SOCK_STREAM, 1, 0);\n-        if (r < 0) {\n-            errno = -r;\n-            twarn(\"sd_is_socket_inet\");\n-            return -1;\n-        }\n-        if (!r) {\n-            twarnx(\"inherited fd is not a TCP listen socket\");\n-            return -1;\n-        }\n-        return fd;\n+    r = fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n+    if (r == -1) {\n+        twarn(\"setting O_NONBLOCK\");\n+        return -1;\n     }\n+    return 0;\n+}\n+\n+static int\n+make_inet_socket(char *host, char *port)\n+{\n+    int fd = -1, flags, r;\n+    struct linger linger = {0, 0};\n+    struct addrinfo *airoot, *ai, hints;\n \n     memset(&hints, 0, sizeof(hints));\n     hints.ai_family = PF_UNSPEC;\n     hints.ai_socktype = SOCK_STREAM;\n     hints.ai_flags = AI_PASSIVE;\n     r = getaddrinfo(host, port, &hints, &airoot);\n     if (r != 0) {\n-      twarnx(\"getaddrinfo(): %s\", gai_strerror(r));\n-      return -1;\n+        twarnx(\"getaddrinfo(): %s\", gai_strerror(r));\n+        return -1;\n     }\n \n-    for(ai = airoot; ai; ai = ai->ai_next) {\n-      fd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n-      if (fd == -1) {\n-        twarn(\"socket()\");\n-        continue;\n-      }\n+    for (ai = airoot; ai; ai = ai->ai_next) {\n+        fd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n+        if (fd == -1) {\n+            twarn(\"socket()\");\n+            continue;\n+        }\n \n-      flags = fcntl(fd, F_GETFL, 0);\n-      if (flags < 0) {\n-        twarn(\"getting flags\");\n-        close(fd);\n-        continue;\n-      }\n+        r = set_nonblocking(fd);\n+        if (r == -1) {\n+            close(fd);\n+            continue;\n+        }\n \n-      r = fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n-      if (r == -1) {\n-        twarn(\"setting O_NONBLOCK\");\n-        close(fd);\n-        continue;\n-      }\n+        flags = 1;\n+        r = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &flags, sizeof flags);\n+        if (r == -1) {\n+            twarn(\"setting SO_REUSEADDR on fd %d\", fd);\n+            close(fd);\n+            continue;\n+        }\n+        r = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &flags, sizeof flags);\n+        if (r == -1) {\n+            twarn(\"setting SO_KEEPALIVE on fd %d\", fd);\n+            close(fd);\n+            continue;\n+        }\n+        r = setsockopt(fd, SOL_SOCKET, SO_LINGER, &linger, sizeof linger);\n+        if (r == -1) {\n+            twarn(\"setting SO_LINGER on fd %d\", fd);\n+            close(fd);\n+            continue;\n+        }\n+        r = setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flags, sizeof flags);\n+        if (r == -1) {\n+            twarn(\"setting TCP_NODELAY on fd %d\", fd);\n+            close(fd);\n+            continue;\n+        }\n \n-      flags = 1;\n-      r = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &flags, sizeof flags);\n-      if (r == -1) {\n-        twarn(\"setting SO_REUSEADDR on fd %d\", fd);\n-        close(fd);\n-        continue;\n-      }\n-      r = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &flags, sizeof flags);\n-      if (r == -1) {\n-        twarn(\"setting SO_KEEPALIVE on fd %d\", fd);\n-        close(fd);\n-        continue;\n-      }\n-      r = setsockopt(fd, SOL_SOCKET, SO_LINGER, &linger, sizeof linger);\n-      if (r == -1) {\n-        twarn(\"setting SO_LINGER on fd %d\", fd);\n-        close(fd);\n-        continue;\n-      }\n-      r = setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flags, sizeof flags);\n-      if (r == -1) {\n-        twarn(\"setting TCP_NODELAY on fd %d\", fd);\n+        r = bind(fd, ai->ai_addr, ai->ai_addrlen);\n+        if (r == -1) {\n+            twarn(\"bind()\");\n+            close(fd);\n+            continue;\n+        }\n+        if (verbose) {\n+            char hbuf[NI_MAXHOST], pbuf[NI_MAXSERV], *h = host, *p = port;\n+            struct sockaddr_in addr;\n+            socklen_t addrlen;\n+\n+            addrlen = sizeof(addr);\n+            r = getsockname(fd, (struct sockaddr *) &addr, &addrlen);\n+            if (!r) {\n+                r = getnameinfo((struct sockaddr *) &addr, addrlen,\n+                                hbuf, sizeof(hbuf),\n+                                pbuf, sizeof(pbuf),\n+                                NI_NUMERICHOST|NI_NUMERICSERV);\n+                if (!r) {\n+                    h = hbuf;\n+                    p = pbuf;\n+                }\n+            }\n+            if (ai->ai_family == AF_INET6) {\n+                printf(\"bind %d [%s]:%s\\n\", fd, h, p);\n+            } else {\n+                printf(\"bind %d %s:%s\\n\", fd, h, p);\n+            }\n+        }\n+\n+        r = listen(fd, 1024);\n+        if (r == -1) {\n+            twarn(\"listen()\");\n+            close(fd);\n+            continue;\n+        }\n+\n+        break;\n+    }\n+\n+    freeaddrinfo(airoot);\n+\n+    if(ai == NULL)\n+        fd = -1;\n+\n+    return fd;\n+}\n+\n+static int\n+make_unix_socket(char *path)\n+{\n+    int fd = -1, r;\n+    struct stat st;\n+    struct sockaddr_un addr;\n+    const size_t maxlen = sizeof(addr.sun_path) - 1; // Reserve the last position for '\\0'\n+\n+    memset(&addr, 0, sizeof(struct sockaddr_un));\n+    addr.sun_family = AF_UNIX;\n+    if (strlen(path) > maxlen) {\n+        warnx(\"socket path %s is too long (%ld characters), where maximum allowed is %ld\",\n+              path, strlen(path), maxlen);\n+        return -1;\n+    }\n+    strncpy(addr.sun_path, path, maxlen);\n+\n+    r = stat(path, &st);\n+    if (r == 0) {\n+        if (S_ISSOCK(st.st_mode)) {\n+            warnx(\"removing existing local socket to replace it\");\n+            r = unlink(path);\n+            if (r == -1) {\n+                twarn(\"unlink\");\n+                return -1;\n+            }\n+        } else {\n+            twarnx(\"another file already exists in the given path\");\n+            return -1;\n+        }\n+    }\n+\n+    fd = socket(AF_UNIX, SOCK_STREAM, 0);\n+    if (fd == -1) {\n+        twarn(\"socket()\");\n+        return -1;\n+    }\n+\n+    r = set_nonblocking(fd);\n+    if (r == -1) {\n         close(fd);\n-        continue;\n-      }\n+        return -1;\n+    }\n \n-      r = bind(fd, ai->ai_addr, ai->ai_addrlen);\n-      if (r == -1) {\n+    r = bind(fd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un));\n+    if (r == -1) {\n         twarn(\"bind()\");\n         close(fd);\n-        continue;\n-      }\n-      if (verbose) {\n-          char hbuf[NI_MAXHOST], pbuf[NI_MAXSERV], *h = host, *p = port;\n-         struct sockaddr_in addr;\n-         socklen_t addrlen;\n-\n-         addrlen = sizeof(addr);\n-         r = getsockname(fd, (struct sockaddr *) &addr, &addrlen);\n-         if (!r) {\n-             r = getnameinfo((struct sockaddr *) &addr, addrlen,\n-                             hbuf, sizeof(hbuf),\n-                             pbuf, sizeof(pbuf),\n-                             NI_NUMERICHOST|NI_NUMERICSERV);\n-             if (!r) {\n-                 h = hbuf;\n-                 p = pbuf;\n-             }\n-         }\n-          if (ai->ai_family == AF_INET6) {\n-              printf(\"bind %d [%s]:%s\\n\", fd, h, p);\n-          } else {\n-              printf(\"bind %d %s:%s\\n\", fd, h, p);\n-          }\n-      }\n-\n-      r = listen(fd, 1024);\n-      if (r == -1) {\n+        return -1;\n+    }\n+    if (verbose) {\n+        printf(\"bind %d %s\\n\", fd, path);\n+    }\n+\n+    r = listen(fd, 1024);\n+    if (r == -1) {\n         twarn(\"listen()\");\n         close(fd);\n-        continue;\n-      }\n-\n-      break;\n+        return -1;\n     }\n \n-    freeaddrinfo(airoot);\n+    return fd;\n+}\n \n-    if(ai == NULL)\n-      fd = -1;\n+int\n+make_server_socket(char *host, char *port)\n+{\n+    int fd = -1, r;\n \n-    return fd;\n+    /* See if we got a listen fd from systemd. If so, all socket options etc\n+     * are already set, so we check that the fd is a TCP or UNIX listen socket\n+     * and return. */\n+    r = sd_listen_fds(1);\n+    if (r < 0) {\n+        return twarn(\"sd_listen_fds\"), -1;\n+    }\n+    if (r > 0) {\n+        if (r > 1) {\n+            twarnx(\"inherited more than one listen socket;\"\n+                   \" ignoring all but the first\");\n+        }\n+        fd = SD_LISTEN_FDS_START;\n+        r = sd_is_socket_inet(fd, 0, SOCK_STREAM, 1, 0);\n+        if (r < 0) {\n+            twarn(\"sd_is_socket_inet\");\n+            errno = -r;\n+            return -1;\n+        }\n+        if (r == 0) {\n+            r = sd_is_socket_unix(fd, SOCK_STREAM, 1, NULL, 0);\n+            if (r < 0) {\n+                twarn(\"sd_is_socket_unix\");\n+                errno = -r;\n+                return -1;\n+            }\n+            if (r == 0) {\n+                twarnx(\"inherited fd is not a TCP or UNIX listening socket\");\n+                return -1;\n+            }\n+        }\n+        return fd;\n+    }\n+\n+    if (host && !strncmp(host, \"unix:\", 5)) {\n+        return make_unix_socket(&host[5]);\n+    } else {\n+        return make_inet_socket(host, port);\n+    }\n }\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -11,7 +11,6 @@\n #include <sys/types.h>\n #include <sys/utsname.h>\n #include <sys/socket.h>\n-#include <netinet/in.h>\n #include <inttypes.h>\n #include <stdarg.h>\n #include <signal.h>\n@@ -2112,7 +2111,7 @@ void\n h_accept(const int fd, const short which, Server *s)\n {\n     UNUSED_PARAMETER(which);\n-    struct sockaddr_in6 addr;\n+    struct sockaddr_storage addr;\n \n     socklen_t addrlen = sizeof addr;\n     int cfd = accept(fd, (struct sockaddr *)&addr, &addrlen);\n\ndiff --git a/doc/beanstalkd.1 b/doc/beanstalkd.1\n--- a/doc/beanstalkd.1\n+++ b/doc/beanstalkd.1\n@@ -1,7 +1,7 @@\n .\\\" generated with Ronn/v0.7.3\n .\\\" http://github.com/rtomayko/ronn/tree/0.7.3\n .\n-.TH \"BEANSTALKD\" \"1\" \"April 2012\" \"\" \"\"\n+.TH \"BEANSTALKD\" \"1\" \"August 2019\" \"\" \"\"\n .\n .SH \"NAME\"\n \\fBbeanstalkd\\fR \\- simple, fast work queue\n@@ -57,6 +57,9 @@ Show a brief help message and exit\\.\n Listen on address \\fIaddr\\fR (default is 0\\.0\\.0\\.0)\\.\n .\n .IP\n+When \\fIaddr\\fR starts with \"unix:\", the unprefixed value of it will be used as the local filesystem path to create a UNIX socket instead of a TCP socket\\. In this case the value of \\fB\\-p\\fR will be ignored\\.\n+.\n+.IP\n (Option \\fB\\-l\\fR has no effect if sd\\-daemon(5) socket activation is being used\\. See also \\fIENVIRONMENT\\fR\\.)\n .\n .TP\n\ndiff --git a/doc/beanstalkd.1.html b/doc/beanstalkd.1.html\n--- a/doc/beanstalkd.1.html\n+++ b/doc/beanstalkd.1.html\n@@ -121,6 +121,10 @@ <h2 id=\"OPTIONS\">OPTIONS</h2>\n <dt class=\"flush\"><code>-h</code></dt><dd><p>Show a brief help message and exit.</p></dd>\n <dt class=\"flush\"><code>-l</code> <var>addr</var></dt><dd><p>Listen on address <var>addr</var> (default is 0.0.0.0).</p>\n \n+<p>When <var>addr</var> starts with \"unix:\", the unprefixed value of it will be\n+used as the local filesystem path to create a UNIX socket instead of\n+a TCP socket. In this case the value of <code>-p</code> will be ignored.</p>\n+\n <p>(Option <code>-l</code> has no effect if <span class=\"man-ref\">sd-daemon<span class=\"s\">(5)</span></span> socket activation is\n being used. See also <a href=\"#ENVIRONMENT\" title=\"ENVIRONMENT\" data-bare-link=\"true\">ENVIRONMENT</a>.)</p></dd>\n <dt class=\"flush\"><code>-n</code></dt><dd><p>Turn off binlog compaction, negating <code>-c</code>.</p>\n@@ -167,7 +171,7 @@ <h2 id=\"AUTHOR\">AUTHOR</h2>\n \n   <ol class='man-decor man-foot man foot'>\n     <li class='tl'></li>\n-    <li class='tc'>April 2012</li>\n+    <li class='tc'>August 2019</li>\n     <li class='tr'>beanstalkd(1)</li>\n   </ol>\n \n\ndiff --git a/doc/beanstalkd.ronn b/doc/beanstalkd.ronn\n--- a/doc/beanstalkd.ronn\n+++ b/doc/beanstalkd.ronn\n@@ -59,6 +59,10 @@ and format of the `beanstalkd` protocol.\n * `-l` <addr>:\n   Listen on address <addr> (default is 0.0.0.0).\n \n+  When <addr> starts with \"unix:\", the unprefixed value of it will be\n+  used as the local filesystem path to create a UNIX socket instead of\n+  a TCP socket. In this case the value of `-p` will be ignored.\n+\n   (Option `-l` has no effect if sd-daemon(5) socket activation is\n   being used. See also [ENVIRONMENT][].)\n \n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -10,6 +10,7 @@\n #include <sys/types.h>\n #include <sys/socket.h>\n #include <sys/select.h>\n+#include <sys/un.h>\n #include <netdb.h>\n #include <netinet/in.h>\n #include <netinet/ip.h>\n@@ -30,6 +31,15 @@ static int64 timeout = 5000000000LL;\n static byte fallocpat[3];\n \n \n+static int\n+exist(char *path)\n+{\n+    struct stat s;\n+\n+    int r = stat(path, &s);\n+    return r != -1;\n+}\n+\n static int\n wrapfalloc(int fd, int size)\n {\n@@ -100,6 +110,29 @@ mustdiallocal(int port)\n     return fd;\n }\n \n+static int\n+mustdialunix(char *socket_file)\n+{\n+    struct sockaddr_un addr;\n+    const size_t maxlen = sizeof(addr.sun_path);\n+    addr.sun_family = AF_UNIX;\n+    snprintf(addr.sun_path, maxlen, \"%s\", socket_file);\n+\n+    int fd = socket(AF_UNIX, SOCK_STREAM, 0);\n+    if (fd == -1) {\n+        twarn(\"socket\");\n+        exit(1);\n+    }\n+\n+    int r = connect(fd, (struct sockaddr *)&addr, sizeof addr);\n+    if (r == -1) {\n+        twarn(\"connect\");\n+        exit(1);\n+    }\n+\n+    return fd;\n+}\n+\n static void\n exit_process(int signum)\n {\n@@ -142,6 +175,7 @@ kill_srvpid(void)\n }\n \n #define SERVER() (progname=__func__, mustforksrv())\n+#define SERVER_UNIX() (progname=__func__, mustforksrv_unix())\n \n // Forks the server storing the pid in srvpid.\n // The parent process returns port assigned.\n@@ -189,6 +223,44 @@ mustforksrv(void)\n     exit(1); /* satisfy the compiler */\n }\n \n+static char *\n+mustforksrv_unix(void)\n+{\n+    static char path[90];\n+    char name[95];\n+    snprintf(path, sizeof(path), \"%s/socket\", ctdir());\n+    snprintf(name, sizeof(name), \"unix:%s\", path);\n+    srv.sock.fd = make_server_socket(name, NULL);\n+    if (srv.sock.fd == -1) {\n+        puts(\"mustforksrv_unix failed\");\n+        exit(1);\n+    }\n+\n+    srvpid = fork();\n+    if (srvpid < 0) {\n+        twarn(\"fork\");\n+        exit(1);\n+    }\n+\n+    if (srvpid > 0) {\n+        // On exit the parent (test) sends SIGTERM to the child.\n+        atexit(kill_srvpid);\n+        printf(\"start server socket=%s\\n\", path);\n+        assert(exist(path));\n+        return path;\n+    }\n+\n+    /* now in child */\n+\n+    set_sig_handler();\n+    prot_init();\n+\n+    srv_acquire_wal(&srv);\n+\n+    srvserve(&srv); /* does not return */\n+    exit(1); /* satisfy the compiler */\n+}\n+\n static char *\n readline(int fd)\n {\n@@ -293,15 +365,6 @@ filesize(char *path)\n     return s.st_size;\n }\n \n-static int\n-exist(char *path)\n-{\n-    struct stat s;\n-\n-    int r = stat(path, &s);\n-    return r != -1;\n-}\n-\n void\n cttest_unknown_command()\n {\n@@ -363,6 +426,31 @@ cttest_peek_not_found()\n     ckresp(fd, \"NOT_FOUND\\r\\n\");\n }\n \n+void\n+cttest_peek_ok_unix()\n+{\n+    char *name = SERVER_UNIX();\n+    int fd = mustdialunix(name);\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"a\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+\n+    mustsend(fd, \"peek 1\\r\\n\");\n+    ckresp(fd, \"FOUND 1 1\\r\\n\");\n+    ckresp(fd, \"a\\r\\n\");\n+\n+    unlink(name);\n+}\n+\n+void\n+cttest_unix_auto_removal()\n+{\n+    // Twice, to trigger autoremoval\n+    SERVER_UNIX();\n+    kill_srvpid();\n+    SERVER_UNIX();\n+}\n+\n void\n cttest_peek_bad_format()\n {\n", "test_patch": "", "problem_statement": "AF_UNIX support for beanstalkd\nAdd the posibility of accepting connections from a local socket (bound to a filesystem path).\n\nTo minimize portability issues, socket paths longer than 100 bytes are rejected.  Systemd support has been added too, but not tested as I don't have access to any Fedora or similar.\n\nThe behaviour of the new command line switch may be strange, but it has been implemented in a way to avoid script breakage when this option is not used.\n\nThe automatic socket file replacement may be a bit surprising too.  However, I found that implementing an automatic removal/cleanup on exit was a bit more intrusive.\n\nAny feedback will be appreciated.", "version": "", "language": "C", "created_at": "2012-10-20T14:45:48Z", "repo_id": 6040}
