{"instance_id": "beanstalkd__beanstalkd-221", "repo": "beanstalkd/beanstalkd", "pull_number": 221, "base_commit": "157d88bf9435a23b71a1940a9afb617e52a2b9e9", "patch": "diff --git a/linux.c b/linux.c\n--- a/linux.c\n+++ b/linux.c\n@@ -79,7 +79,7 @@ socknext(Socket **s, int64 timeout)\n         exit(1);\n     }\n \n-    if (r) {\n+    if (r > 0) {\n         *s = ev.data.ptr;\n         if (ev.events & (EPOLLHUP|EPOLLRDHUP)) {\n             return 'h';\n", "test_patch": "", "problem_statement": "Prevent Linux system suspend segfault, fixes #220\nFixes https://github.com/kr/beanstalkd/issues/220 by preventing segfaults when epoll_wait returns <= 0, which can occur due to EINTR during system suspend or job control (e.g., Ctrl-Z + `fg`). A prior refactor replaced a loop that implicitly skipped invalid events with an if check that failed to validate epoll_wait's return value, allowing -1 (error) events to be processed\u2014causing crashes. This change restores safe behavior by skipping event processing when epoll_wait returns <= 0, matching the original robustness. Reproducible via foreground start, suspend with Ctrl-Z, and resume with `fg`, which previously triggered a segfault. All tests, including CT, pass. This fix addresses a broader class of interrupt-induced failures and improves stability under system interruptions.", "version": "1.9", "language": "C", "created_at": "2013-12-15T22:32:16Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-176", "repo": "beanstalkd/beanstalkd", "pull_number": 176, "base_commit": "76adfd9e4cab98a1db75ebeac677ca5f14913851", "patch": "diff --git a/doc/protocol.md b/doc/protocol.md\n--- a/doc/protocol.md\n+++ b/doc/protocol.md\n@@ -61,7 +61,7 @@ Here is a picture with more possibilities:\n    put with delay               release with delay\n   ----------------> [DELAYED] <------------.\n                         |                   |\n-                        | (time passes)     |\n+                 kick   | (time passes)     |\n                         |                   |\n    put                  v     reserve       |       delete\n   -----------------> [READY] ---------> [RESERVED] --------> *poof*\n", "test_patch": "", "problem_statement": "show the delayed->ready transition via 'kick'\n...as proposed in issue #172", "version": "1.8", "language": "C", "created_at": "2013-03-18T19:14:49Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-367", "repo": "beanstalkd/beanstalkd", "pull_number": 367, "base_commit": "9f692dc0c1c43b333e1e4a6cc384128bf510651e", "patch": "diff --git a/net.c b/net.c\n--- a/net.c\n+++ b/net.c\n@@ -98,28 +98,35 @@ make_server_socket(char *host, char *port)\n         continue;\n       }\n \n+      r = bind(fd, ai->ai_addr, ai->ai_addrlen);\n+      if (r == -1) {\n+        twarn(\"bind()\");\n+        close(fd);\n+        continue;\n+      }\n       if (verbose) {\n           char hbuf[NI_MAXHOST], pbuf[NI_MAXSERV], *h = host, *p = port;\n-          r = getnameinfo(ai->ai_addr, ai->ai_addrlen,\n-                  hbuf, sizeof hbuf,\n-                  pbuf, sizeof pbuf,\n-                  NI_NUMERICHOST|NI_NUMERICSERV);\n-          if (!r) {\n-              h = hbuf;\n-              p = pbuf;\n-          }\n+         struct sockaddr_in addr;\n+         socklen_t addrlen;\n+\n+         addrlen = sizeof(addr);\n+         r = getsockname(fd, (struct sockaddr *) &addr, &addrlen);\n+         if (!r) {\n+             r = getnameinfo((struct sockaddr *) &addr, addrlen,\n+                             hbuf, sizeof(hbuf),\n+                             pbuf, sizeof(pbuf),\n+                             NI_NUMERICHOST|NI_NUMERICSERV);\n+             if (!r) {\n+                 h = hbuf;\n+                 p = pbuf;\n+             }\n+         }\n           if (ai->ai_family == AF_INET6) {\n               printf(\"bind %d [%s]:%s\\n\", fd, h, p);\n           } else {\n               printf(\"bind %d %s:%s\\n\", fd, h, p);\n           }\n       }\n-      r = bind(fd, ai->ai_addr, ai->ai_addrlen);\n-      if (r == -1) {\n-        twarn(\"bind()\");\n-        close(fd);\n-        continue;\n-      }\n \n       r = listen(fd, 1024);\n       if (r == -1) {\n", "test_patch": "", "problem_statement": "Report bound port correctly\nWhen binding to port 0 beanstalk correctly binds to a random port but doesn't report which port it bound to, reporting 0 instead. This patch fixes that.", "version": "1.10", "language": "C", "created_at": "2017-11-26T22:26:31Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-151", "repo": "beanstalkd/beanstalkd", "pull_number": 151, "base_commit": "f43a5470128a1f94210dace36244503148c1f42f", "patch": "diff --git a/doc/protocol.md b/doc/protocol.md\n--- a/doc/protocol.md\n+++ b/doc/protocol.md\n@@ -37,16 +37,14 @@ Names only supports ASCII strings.\n \n ### Job Lifecycle\n \n-A job in beanstalk gets created by a client with the `put` command. During its life it can be in one of four states:\n+A job in beanstalk gets created by a client with the `put` command. During its life it can be in one of four states: `ready`, `reserved`, `delayed`, or `buried`. After the `put` command, a job typically starts out ready. It waits in the ready queue until a worker comes along and runs the \"reserve\" command. If this job is next in the queue, it will be reserved for the worker. The worker will execute the job; when it is finished the worker will send a `delete` command to delete the job.\n \n | Status              | Description   |\n | --------------------| ------------- |\n-| `ready`             | it waits in the ready queue until a worker comes along and runs the \"reserve\" command |\n+| `ready`             | waiting to be reserved and processed after being put onto a tubed |\n | `reserved`          | if this job is next in the queue, it will be reserved for the worker. The worker will execute the job |\n-| `delayed`           | when it's waiting \"x\" seconds before to be `ready` |\n-| `buried`            | when it is finished the worker will send a \"delete\" ; when it is finished the worker will send a \"delete\" |\n-\n-\n+| `delayed`           | waiting to become ready after the specified delay. |\n+| `buried`            | waiting to be kicked, usually after job fails to process |\n \n Here is a picture of the typical job lifecycle:\n \n", "test_patch": "", "problem_statement": "[doc] fix job lifecycle description\nHi @kr,\n\nI realized I naively copied and pasted without checking if it made sense or. So I made some quick fixes on job lifecycle description.", "version": "1.7", "language": "C", "created_at": "2012-10-31T23:14:38Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-164", "repo": "beanstalkd/beanstalkd", "pull_number": 164, "base_commit": "d5ffd665048ef7e3fbac4fff002073e487820dea", "patch": "diff --git a/doc/protocol.md b/doc/protocol.md\n--- a/doc/protocol.md\n+++ b/doc/protocol.md\n@@ -364,19 +364,19 @@ The response is one of:\n * `NOT_FOUND\\r\\n` if the job does not exist or is not in a kickable state. This can also happen upon internal errors.\n * `KICKED\\r\\n` when the operation succeeded.\n \n-#### `stats-jobs` command\n+#### `stats-job` command\n \n The stats-job command gives statistical information about the specified job if it exists. Its form is:\n \n ```\n stats-job <id>\\r\\n\n ```\n \n-##### `stats-jobs` options\n+##### `stats-job` options\n \n * `<id>` is a job id.\n \n-##### `stats-jobs` responses\n+##### `stats-job` responses\n \n The response is one of:\n \n@@ -590,4 +590,4 @@ pause-tube <tube-name> <delay>\\r\\n\n There are two possible responses:\n \n * `PAUSED\\r\\n` to indicate success.\n-* `NOT_FOUND\\r\\n` if the tube does not exist.\n\\ No newline at end of file\n+* `NOT_FOUND\\r\\n` if the tube does not exist.\n", "test_patch": "", "problem_statement": "Fixing a few \"stats-jobs\" typos\nAs far as I can tell they should just all be stats-job", "version": "1.8", "language": "C", "created_at": "2013-01-10T21:17:40Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-136", "repo": "beanstalkd/beanstalkd", "pull_number": 136, "base_commit": "ecb403ee8c6ec8b29f9f9ab1b37d1dbbc7b2f546", "patch": "diff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -143,8 +143,11 @@ connwant(Conn *c, int rw)\n void\n connsched(Conn *c)\n {\n+    if (c->tickpos > -1)\n+        heapremove(&c->srv->conns, c->tickpos);\n     c->tickat = conntickat(c);\n-    srvschedconn(c->srv, c);\n+    if (c->tickat)\n+        heapinsert(&c->srv->conns, c);\n }\n \n \n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -384,5 +384,4 @@ struct Server {\n };\n void srvserve(Server *srv);\n void srvaccept(Server *s, int ev);\n-void srvschedconn(Server *srv, Conn *c);\n void srvtick(Server *s, int ev);\n\ndiff --git a/srv.c b/srv.c\n--- a/srv.c\n+++ b/srv.c\n@@ -43,18 +43,6 @@ srvserve(Server *s)\n }\n \n \n-void\n-srvschedconn(Server *s, Conn *c)\n-{\n-    if (c->tickpos > -1) {\n-        heapremove(&s->conns, c->tickpos);\n-    }\n-    if (c->tickat) {\n-        heapinsert(&s->conns, c);\n-    }\n-}\n-\n-\n void\n srvaccept(Server *s, int ev)\n {\n", "test_patch": "", "problem_statement": "Better attempt to fix issue #134\nThis fix shoud make more sense than the previous attempt.  Right now closes #134 but it should also resolve a bunch of segfaults and infinite loop issues.", "version": "1.6", "language": "C", "created_at": "2012-08-30T09:12:54Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-76", "repo": "beanstalkd/beanstalkd", "pull_number": 76, "base_commit": "b5a20491fda42ad68de55914762c1b7c369c923a", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -72,6 +72,7 @@ struct stats {\n     uint buried_ct;\n     uint reserved_ct;\n     uint pause_ct;\n+    uint64   total_delete_ct;\n     uint64   total_jobs_ct;\n };\n \n\ndiff --git a/doc/protocol.txt b/doc/protocol.txt\n--- a/doc/protocol.txt\n+++ b/doc/protocol.txt\n@@ -485,6 +485,8 @@ to scalars. It contains these keys:\n \n  - \"pause\" is the number of seconds the tube has been paused for.\n \n+ - \"cmd-delete\" is the cumulative number of delete commands for this tube\n+\n  - \"cmd-pause-tube\" is the cumulative number of pause-tube commands for this\n    tube.\n \n\ndiff --git a/integ-test.c b/integ-test.c\n--- a/integ-test.c\n+++ b/integ-test.c\n@@ -35,6 +35,7 @@ static T ts[] = {\n     {\"sh-tests/omit-time-left.commands\", \"sh-tests/omit-time-left.expected\"},\n     {\"sh-tests/pause-tube.commands\", \"sh-tests/pause-tube.expected\"},\n     {\"sh-tests/small_delay.commands\", \"sh-tests/small_delay.expected\"},\n+    {\"sh-tests/stats_tube.commands\", \"sh-tests/stats_tube.expected\"},\n     {\"sh-tests/too-big.commands\", \"sh-tests/too-big.expected\"},\n     {\"sh-tests/ttr-large.commands\", \"sh-tests/ttr-large.expected\"},\n     {\"sh-tests/zero_delay.commands\", \"sh-tests/zero_delay.expected\"},\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -192,6 +192,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n     \"current-using: %u\\n\" \\\n     \"current-watching: %u\\n\" \\\n     \"current-waiting: %u\\n\" \\\n+    \"cmd-delete: %\" PRIu64 \"\\n\" \\\n     \"cmd-pause-tube: %u\\n\" \\\n     \"pause: %\" PRIu64 \"\\n\" \\\n     \"pause-time-left: %\" PRIu64 \"\\n\" \\\n@@ -1082,6 +1083,7 @@ fmt_stats_tube(char *buf, size_t size, tube t)\n             t->using_ct,\n             t->watching_ct,\n             t->stat.waiting_ct,\n+            t->stat.total_delete_ct,\n             t->stat.pause_ct,\n             t->pause / 1000000000,\n             time_left);\n@@ -1292,6 +1294,8 @@ dispatch_cmd(conn c)\n \n         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n \n+        j->tube->stat.total_delete_ct++;\n+\n         j->r.state = Invalid;\n         r = walwrite(&c->srv->wal, j);\n         walmaint(&c->srv->wal);\n\ndiff --git a/sh-tests/pause-tube.expected b/sh-tests/pause-tube.expected\n--- a/sh-tests/pause-tube.expected\n+++ b/sh-tests/pause-tube.expected\n@@ -1,6 +1,6 @@\n INSERTED 1\r\n INSERTED 2\r\n-OK 251\r\n+OK 265\r\n ---\n name: default\n current-jobs-urgent: 0\n@@ -12,12 +12,13 @@ total-jobs: 2\n current-using: 1\n current-watching: 1\n current-waiting: 0\n+cmd-delete: 0\n cmd-pause-tube: 0\n pause: 0\n pause-time-left: 0\n \r\n PAUSED\r\n-OK 252\r\n+OK 266\r\n ---\n name: default\n current-jobs-urgent: 0\n@@ -29,6 +30,7 @@ total-jobs: 2\n current-using: 1\n current-watching: 1\n current-waiting: 0\n+cmd-delete: 0\n cmd-pause-tube: 1\n pause: 10\n pause-time-left: 9\n@@ -38,7 +40,7 @@ RESERVED 1 1\n 1\r\n DELETED\r\n PAUSED\r\n-OK 251\r\n+OK 265\r\n ---\n name: default\n current-jobs-urgent: 1\n@@ -50,6 +52,7 @@ total-jobs: 2\n current-using: 1\n current-watching: 1\n current-waiting: 0\n+cmd-delete: 1\n cmd-pause-tube: 3\n pause: 3\n pause-time-left: 2\n\ndiff --git a/sh-tests/stats_tube.commands b/sh-tests/stats_tube.commands\n--- a/sh-tests/stats_tube.commands\n+++ b/sh-tests/stats_tube.commands\n@@ -0,0 +1,7 @@\n+use tubea\r\n+put 0 0 0 0\r\n+\r\n+delete 1\r\n+stats-tube tubea\r\n+stats-tube default\r\n+quit\r\n\ndiff --git a/sh-tests/stats_tube.expected b/sh-tests/stats_tube.expected\n--- a/sh-tests/stats_tube.expected\n+++ b/sh-tests/stats_tube.expected\n@@ -0,0 +1,37 @@\n+USING tubea\r\n+INSERTED 1\r\n+DELETED\r\n+OK 263\r\n+---\n+name: tubea\n+current-jobs-urgent: 0\n+current-jobs-ready: 0\n+current-jobs-reserved: 0\n+current-jobs-delayed: 0\n+current-jobs-buried: 0\n+total-jobs: 1\n+current-using: 1\n+current-watching: 0\n+current-waiting: 0\n+cmd-delete: 1\n+cmd-pause-tube: 0\n+pause: 0\n+pause-time-left: 0\n+\r\n+OK 265\r\n+---\n+name: default\n+current-jobs-urgent: 0\n+current-jobs-ready: 0\n+current-jobs-reserved: 0\n+current-jobs-delayed: 0\n+current-jobs-buried: 0\n+total-jobs: 0\n+current-using: 0\n+current-watching: 1\n+current-waiting: 0\n+cmd-delete: 0\n+cmd-pause-tube: 0\n+pause: 0\n+pause-time-left: 0\n+\r\n", "test_patch": "diff --git a/sh-tests/pause-tube.expected b/sh-tests/pause-tube.expected\n--- a/sh-tests/pause-tube.expected\n+++ b/sh-tests/pause-tube.expected\n@@ -1,6 +1,6 @@\n INSERTED 1\r\n INSERTED 2\r\n-OK 251\r\n+OK 265\r\n ---\n name: default\n current-jobs-urgent: 0\n@@ -12,12 +12,13 @@ total-jobs: 2\n current-using: 1\n current-watching: 1\n current-waiting: 0\n+cmd-delete: 0\n cmd-pause-tube: 0\n pause: 0\n pause-time-left: 0\n \r\n PAUSED\r\n-OK 252\r\n+OK 266\r\n ---\n name: default\n current-jobs-urgent: 0\n@@ -29,6 +30,7 @@ total-jobs: 2\n current-using: 1\n current-watching: 1\n current-waiting: 0\n+cmd-delete: 0\n cmd-pause-tube: 1\n pause: 10\n pause-time-left: 9\n@@ -38,7 +40,7 @@ RESERVED 1 1\n 1\r\n DELETED\r\n PAUSED\r\n-OK 251\r\n+OK 265\r\n ---\n name: default\n current-jobs-urgent: 1\n@@ -50,6 +52,7 @@ total-jobs: 2\n current-using: 1\n current-watching: 1\n current-waiting: 0\n+cmd-delete: 1\n cmd-pause-tube: 3\n pause: 3\n pause-time-left: 2\n\ndiff --git a/sh-tests/stats_tube.commands b/sh-tests/stats_tube.commands\n--- a/sh-tests/stats_tube.commands\n+++ b/sh-tests/stats_tube.commands\n@@ -0,0 +1,7 @@\n+use tubea\r\n+put 0 0 0 0\r\n+\r\n+delete 1\r\n+stats-tube tubea\r\n+stats-tube default\r\n+quit\r\n\ndiff --git a/sh-tests/stats_tube.expected b/sh-tests/stats_tube.expected\n--- a/sh-tests/stats_tube.expected\n+++ b/sh-tests/stats_tube.expected\n@@ -0,0 +1,37 @@\n+USING tubea\r\n+INSERTED 1\r\n+DELETED\r\n+OK 263\r\n+---\n+name: tubea\n+current-jobs-urgent: 0\n+current-jobs-ready: 0\n+current-jobs-reserved: 0\n+current-jobs-delayed: 0\n+current-jobs-buried: 0\n+total-jobs: 1\n+current-using: 1\n+current-watching: 0\n+current-waiting: 0\n+cmd-delete: 1\n+cmd-pause-tube: 0\n+pause: 0\n+pause-time-left: 0\n+\r\n+OK 265\r\n+---\n+name: default\n+current-jobs-urgent: 0\n+current-jobs-ready: 0\n+current-jobs-reserved: 0\n+current-jobs-delayed: 0\n+current-jobs-buried: 0\n+total-jobs: 0\n+current-using: 0\n+current-watching: 1\n+current-waiting: 0\n+cmd-delete: 0\n+cmd-pause-tube: 0\n+pause: 0\n+pause-time-left: 0\n+\r\n", "problem_statement": "adding support for counting deletes on a tube\nthis makes it easier to track inflow/outflow of a tube", "version": "1.4", "language": "C", "created_at": "2011-10-03T18:23:47Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-213", "repo": "beanstalkd/beanstalkd", "pull_number": 213, "base_commit": "157d88bf9435a23b71a1940a9afb617e52a2b9e9", "patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -1,4 +1,3 @@\n-DESTDIR=\n PREFIX=/usr/local\n BINDIR=$(DESTDIR)$(PREFIX)/bin\n CFLAGS=-Wall -Werror\\\n", "test_patch": "", "problem_statement": "Makefile: finish DESTDIR support\nSupport originally added in 0f97427a38cd0c2c2aee00946ebe561453165a50.\nI'm sure this was left in accidentally as it resets the variable to ''.", "version": "1.9", "language": "C", "created_at": "2013-11-06T19:30:21Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-419", "repo": "beanstalkd/beanstalkd", "pull_number": 419, "base_commit": "bbafc68567038aaacc4f15212adcd25a45c42e01", "patch": "diff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -1,15 +1,16 @@\n # beanstalkd\n \n-This is beanstalkd, a fast, general-purpose work queue.\n-See https://beanstalkd.github.io/ for general info.\n+Simple and fast general purpose work queue.\n+\n+https://beanstalkd.github.io/\n \n Please note that this project is released with a Contributor\n Code of Conduct. By participating in this project you agree\n to abide by its terms. See CodeOfConduct.txt for details.\n \n [![Build Status](https://travis-ci.org/beanstalkd/beanstalkd.svg?branch=master)](https://travis-ci.org/beanstalkd/beanstalkd)\n \n-## Quick Stat\n+## Quick Start\n \n     $ make\n     $ ./beanstalkd\n@@ -26,7 +27,8 @@ also try,\n     $ make install PREFIX=/usr\n \n Requires Linux (2.6.17 or later), Mac OS X, or FreeBSD.\n-See `doc/protocol.txt` for details of the network protocol.\n+See [doc/protocol.txt](https://github.com/beanstalkd/beanstalkd/blob/master/doc/protocol.txt) \n+for details of the network protocol.\n \n Uses ronn to generate the manual.\n See http://github.com/rtomayko/ronn.\n@@ -35,9 +37,9 @@ See http://github.com/rtomayko/ronn.\n ## Subdirectories\n \n - `adm`\t- files useful for system administrators\n-- `ct`\t- testing tool; see https://github.com/kr/ct\n+- `ct`\t- testing tool; vendored from https://github.com/kr/ct\n - `doc`\t- documentation\n-- `pkg`\t- miscellaneous files for packagers\n+- `pkg`\t- scripts to make releases\n \n \n ## Tests\n@@ -46,7 +48,7 @@ Unit tests are in test*.c. See https://github.com/kr/ct for\n information on how to write them.\n \n \n-Copyright \u00a9 2007-2013 the authors of beanstalkd.\n+Copyright \u00a9 2007-2019 the authors of beanstalkd.\n Copyright in contributions to beanstalkd is retained\n by the original copyright holder of each contribution.\n See file LICENSE for terms of use.\n", "test_patch": "", "problem_statement": "README.md: fix typos\nAs usual, after I merged the changes, I spotted some typos and style warts.", "version": "1.10", "language": "C", "created_at": "2019-06-27T07:26:26Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-169", "repo": "beanstalkd/beanstalkd", "pull_number": 169, "base_commit": "1c7a2b3dcf4f27a8c2f702a792733dd612d2e7b9", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -247,7 +247,7 @@ extern size_t primes[];\n extern size_t job_data_size_limit;\n \n void prot_init(void);\n-void prottick(Server *s);\n+int64 prottick(Server *s);\n void protrmdirty(Conn*);\n \n Conn *remove_waiting_conn(Conn *c);\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -1832,35 +1832,46 @@ prothandle(Conn *c, int ev)\n     h_conn(c->sock.fd, ev, c);\n }\n \n-void\n+int64\n prottick(Server *s)\n {\n     int r;\n     job j;\n     int64 now;\n     int i;\n     tube t;\n+    int64 period = 0x34630B8A000LL; /* 1 hour in nanoseconds */\n+    int64 d;\n \n     now = nanoseconds();\n     while ((j = delay_q_peek())) {\n-        if (j->r.deadline_at > now) break;\n+        d = j->r.deadline_at - now;\n+        if (d > 0) {\n+            period = min(period, d);\n+            break;\n+        }\n         j = delay_q_take();\n         r = enqueue_job(s, j, 0, 0);\n         if (r < 1) bury_job(s, j, 0); /* out of memory, so bury it */\n     }\n \n     for (i = 0; i < tubes.used; i++) {\n         t = tubes.items[i];\n-\n-        if (t->pause && t->deadline_at <= now) {\n+        d = t->deadline_at - now;\n+        if (t->pause && d <= 0) {\n             t->pause = 0;\n             process_queue();\n         }\n+        else if (d > 0) {\n+            period = min(period, d);\n+        }\n     }\n \n     while (s->conns.len) {\n         Conn *c = s->conns.data[0];\n-        if (c->tickat > now) {\n+        d = c->tickat - now;\n+        if (d > 0) {\n+            period = min(period, d);\n             break;\n         }\n \n@@ -1869,6 +1880,8 @@ prottick(Server *s)\n     }\n \n     update_conns();\n+\n+    return period;\n }\n \n void\n\ndiff --git a/serv.c b/serv.c\n--- a/serv.c\n+++ b/serv.c\n@@ -18,7 +18,7 @@ srvserve(Server *s)\n {\n     int r;\n     Socket *sock;\n-    int64 period = 10*1000000; // 10ms\n+    int64 period;\n \n     if (sockinit() == -1) {\n         twarnx(\"sockinit\");\n@@ -43,20 +43,15 @@ srvserve(Server *s)\n     }\n \n \n-    int64 t = nanoseconds();\n     for (;;) {\n+        period = prottick(s);\n+\n         int rw = socknext(&sock, period);\n         if (rw == -1) {\n             twarnx(\"socknext\");\n             exit(1);\n         }\n \n-        int64 t1 = nanoseconds();\n-        if (t1-t > period) {\n-            prottick(s);\n-            t = t1;\n-        }\n-\n         if (rw) {\n             sock->f(sock->x, rw);\n         }\n", "test_patch": "", "problem_statement": "Beanstalkd uses a lot more CPU cycles when the system is under high load\nI experience that beanstalkd uses a lot CPU cycles when the system is under high load. This, even when beanstalkd is not in use.\n\nThis simple test shows the issue in effect:\n- beanstalkd v1.8 on an Amazon EC2 Large instance with Ubuntu Linux 12.04.2 LTS.\n- No jobs in beanstalkd\n- Saturate the available CPU cycles with a couple of nice'd dummy processes, using:\n  `nice -n 10 python -c \"while True: x=2**10\"&`\n\nIn this test beanstalkd (according to top) uses between 15% and 20% of the CPU cycles. As soon as the high load is stopped, beanstalkd goes back to nearly ~0% CPU.\n\nThis observed behaviour is quite unfortunate. So what is happening, and is it expected behaviour?", "version": "1.8", "language": "C", "created_at": "2013-03-07T17:04:17Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-315", "repo": "beanstalkd/beanstalkd", "pull_number": 315, "base_commit": "7628779e94f696ae9d5385c8c3bd3ac78d632dba", "patch": "diff --git a/doc/protocol.zh-CN.md b/doc/protocol.zh-CN.md\n--- a/doc/protocol.zh-CN.md\n+++ b/doc/protocol.zh-CN.md\n@@ -300,6 +300,8 @@ data \u4e3aYAML file\u7684\u7edf\u8ba1\u4fe1\u606f\n - `state` \u8868\u793ajob\u7684\u5f53\u524d\u72b6\u6001\n - `pri` \u8868\u793ajob\u7684\u4f18\u5148\u7ea7\n - `age` \u8868\u793ajob\u521b\u5efa\u7684\u65f6\u95f4\u5355\u4f4d\u79d2\n+- `delay` \u662f\u5ef6\u8fdfjob\u653e\u5165ready\u961f\u5217\u7684\u6574\u6570\u79d2\u6570\n+- `ttr` \u6307\u5141\u8bb8worker\u6267\u884cjob\u7684\u6574\u6570\u79d2\u6570\n - `time-left` \u8868\u793ajob\u7684\u72b6\u6001\u8fc1\u79fb\u4e3aready\u7684\u65f6\u95f4\uff0c\u4ec5\u5728job\u72b6\u6001\u4e3areserved\u6216\u8005delayed\u65f6\u6709\u610f\u4e49\uff0c\u5f53job\u72b6\u6001\u4e3areserved\u65f6\u8868\u793a\u5269\u4f59\u7684\u8d85\u65f6\u65f6\u95f4\u3002\n - `file` \u8868\u793a\u5305\u542b\u6b64job\u7684binlog\u5e8f\u53f7\uff0c\u5982\u679c\u6ca1\u6709\u5f00\u542f\u5b83\u5c06\u4e3a0\n - `reserves` \u8868\u793ajob\u88abreserved\u7684\u6b21\u6570\n", "test_patch": "", "problem_statement": "Update protocol.zh-CN.md\nDocument stats-job values delay and ttr in Chinese", "version": "1.10", "language": "C", "created_at": "2016-04-04T05:07:34Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-280", "repo": "beanstalkd/beanstalkd", "pull_number": 280, "base_commit": "93ab93451d9355be7bd46fc27d9d521f2287376a", "patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -50,12 +50,10 @@ $(TARG): $(OFILES) $(MOFILE)\n \t$(LINK.o) -o $@ $^ $(LDLIBS)\n \n .PHONY: install\n-install: $(BINDIR) $(BINDIR)/$(TARG)\n-\n-$(BINDIR):\n-\t$(INSTALL) -d $@\n+install: $(BINDIR)/$(TARG)\n \n $(BINDIR)/%: %\n+\t$(INSTALL) -d $(dir $@)\n \t$(INSTALL) $< $@\n \n CLEANFILES:=$(CLEANFILES) $(TARG)\n", "test_patch": "", "problem_statement": "Makefile: resolved parallel install issue\nWhen installing within [Open Embedded](http://www.openembedded.org/) the make jobs parameter is by default shared between \"all\" and \"install\" [as per this doc](http://www.yoctoproject.org/docs/latest/mega-manual/mega-manual.html#var-PARALLEL_MAKEINST). The beanstalkd Makefile was causing needless parallelization where the beanstalkd binary may be installed before the directory is created.", "version": "1.10", "language": "C", "created_at": "2015-10-06T03:35:14Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-453", "repo": "beanstalkd/beanstalkd", "pull_number": 453, "base_commit": "871f09f61e7e62db6adb5c0d55682bafbe7189a3", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -31,7 +31,7 @@ typedef struct Wal    Wal;\n typedef void(*ms_event_fn)(ms a, void *item, size_t i);\n typedef void(*Handle)(void*, int rw);\n typedef int(*Less)(void*, void*);\n-typedef void(*Record)(void*, int);\n+typedef void(*Record)(void*, size_t);\n typedef int(FAlloc)(int, int);\n \n #if _LP64\n@@ -81,14 +81,14 @@ struct stats {\n \n \n struct Heap {\n-    int     cap;\n-    int     len;\n+    size_t  cap;\n+    size_t  len;\n     void    **data;\n     Less    less;\n     Record  rec;\n };\n int   heapinsert(Heap *h, void *x);\n-void* heapremove(Heap *h, int k);\n+void* heapremove(Heap *h, size_t k);\n \n \n struct Socket {\n@@ -210,7 +210,7 @@ void job_free(job j);\n job job_find(uint64 job_id);\n \n /* the void* parameters are really job pointers */\n-void job_setheappos(void*, int);\n+void job_setheappos(void*, size_t);\n int job_pri_less(void*, void*);\n int job_delay_less(void*, void*);\n \n\ndiff --git a/heap.c b/heap.c\n--- a/heap.c\n+++ b/heap.c\n@@ -5,15 +5,15 @@\n \n \n static void\n-set(Heap *h, int k, void *x)\n+set(Heap *h, size_t k, void *x)\n {\n     h->data[k] = x;\n     h->rec(x, k);\n }\n \n \n static void\n-swap(Heap *h, int a, int b)\n+swap(Heap *h, size_t a, size_t b)\n {\n     void *tmp;\n \n@@ -24,17 +24,17 @@ swap(Heap *h, int a, int b)\n \n \n static int\n-less(Heap *h, int a, int b)\n+less(Heap *h, size_t a, size_t b)\n {\n     return h->less(h->data[a], h->data[b]);\n }\n \n \n static void\n-siftdown(Heap *h, int k)\n+siftdown(Heap *h, size_t k)\n {\n     for (;;) {\n-        int p = (k-1) / 2; /* parent */\n+        size_t p = (k-1) / 2; /* parent */\n \n         if (k == 0 || less(h, p, k)) {\n             return;\n@@ -47,16 +47,14 @@ siftdown(Heap *h, int k)\n \n \n static void\n-siftup(Heap *h, int k)\n+siftup(Heap *h, size_t k)\n {\n     for (;;) {\n-        int l, r, s;\n-\n-        l = k*2 + 1; /* left child */\n-        r = k*2 + 2; /* right child */\n+        size_t l = k*2 + 1; /* left child */\n+        size_t r = k*2 + 2; /* right child */\n \n         /* find the smallest of the three */\n-        s = k;\n+        size_t s = k;\n         if (l < h->len && less(h, l, s)) s = l;\n         if (r < h->len && less(h, r, s)) s = r;\n \n@@ -75,24 +73,22 @@ siftup(Heap *h, int k)\n int\n heapinsert(Heap *h, void *x)\n {\n-    int k;\n-\n     if (h->len == h->cap) {\n         void **ndata;\n-        int ncap = (h->len+1) * 2; /* allocate twice what we need */\n+        size_t ncap = (h->len+1) * 2; /* allocate twice what we need */\n \n         ndata = malloc(sizeof(void*) * ncap);\n         if (!ndata) {\n             return 0;\n         }\n \n-        memcpy(ndata, h->data, sizeof(void*)*h->len);\n+        memcpy(ndata, h->data, sizeof(void*) * h->len);\n         free(h->data);\n         h->data = ndata;\n         h->cap = ncap;\n     }\n \n-    k = h->len;\n+    size_t k = h->len;\n     h->len++;\n     set(h, k, x);\n     siftdown(h, k);\n@@ -101,19 +97,16 @@ heapinsert(Heap *h, void *x)\n \n \n void *\n-heapremove(Heap *h, int k)\n+heapremove(Heap *h, size_t k)\n {\n-    void *x;\n-\n     if (k >= h->len) {\n         return 0;\n     }\n \n-    x = h->data[k];\n+    void *x = h->data[k];\n     h->len--;\n     set(h, k, h->data[h->len]);\n     siftdown(h, k);\n     siftup(h, k);\n-    h->rec(x, -1);\n     return x;\n }\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -158,7 +158,7 @@ job_free(job j)\n }\n \n void\n-job_setheappos(void *j, int pos)\n+job_setheappos(void *j, size_t pos)\n {\n     ((job)j)->heap_index = pos;\n }\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -193,9 +193,9 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define STATS_TUBE_FMT \"---\\n\" \\\n     \"name: %s\\n\" \\\n     \"current-jobs-urgent: %u\\n\" \\\n-    \"current-jobs-ready: %u\\n\" \\\n+    \"current-jobs-ready: %zu\\n\" \\\n     \"current-jobs-reserved: %u\\n\" \\\n-    \"current-jobs-delayed: %u\\n\" \\\n+    \"current-jobs-delayed: %zu\\n\" \\\n     \"current-jobs-buried: %u\\n\" \\\n     \"total-jobs: %\" PRIu64 \"\\n\" \\\n     \"current-using: %u\\n\" \\\n\ndiff --git a/testheap.c b/testheap.c\n--- a/testheap.c\n+++ b/testheap.c\n@@ -10,13 +10,12 @@\n void\n cttest_heap_insert_one()\n {\n-    Heap h = {0};\n-    job j;\n-\n-    h.less = job_pri_less;\n-    h.rec = job_setheappos;\n+    Heap h = {\n+        .less = job_pri_less,\n+        .rec = job_setheappos,\n+    };\n \n-    j = make_job(1, 0, 1, 0, 0);\n+    job j = make_job(1, 0, 1, 0, 0);\n     assertf(j, \"allocate job\");\n \n     heapinsert(&h, j);\n@@ -27,42 +26,39 @@ cttest_heap_insert_one()\n void\n cttest_heap_insert_and_remove_one()\n {\n-    Heap h = {0};\n-    int r;\n-    job j, j1;\n+    Heap h = {\n+        .less = job_pri_less,\n+        .rec = job_setheappos,\n+    };\n \n-    h.less = job_pri_less;\n-    h.rec = job_setheappos;\n-    j1 = make_job(1, 0, 1, 0, 0);\n+    job j1 = make_job(1, 0, 1, 0, 0);\n     assertf(j1, \"allocate job\");\n \n-    r = heapinsert(&h, j1);\n+    int r = heapinsert(&h, j1);\n     assertf(r, \"insert should succeed\");\n \n-    j = heapremove(&h, 0);\n-    assertf(j == j1, \"j1 should come back out\");\n+    job got = heapremove(&h, 0);\n+    assertf(got == j1, \"j1 should come back out\");\n     assertf(h.len == 0, \"h should be empty.\");\n-    printf(\"j->heap_index is %zu\\n\", j->heap_index);\n-    assertf(j->heap_index == -1, \"j's heap index should be invalid\");\n }\n \n void\n cttest_heap_priority()\n {\n-    Heap h = {0};\n-    int r;\n+    Heap h = {\n+        .less = job_pri_less,\n+        .rec = job_setheappos,\n+    };\n     job j, j1, j2, j3;\n \n-    h.less = job_pri_less;\n-    h.rec = job_setheappos;\n     j1 = make_job(1, 0, 1, 0, 0);\n     j2 = make_job(2, 0, 1, 0, 0);\n     j3 = make_job(3, 0, 1, 0, 0);\n     assertf(j1, \"allocate job\");\n     assertf(j2, \"allocate job\");\n     assertf(j3, \"allocate job\");\n \n-    r = heapinsert(&h, j2);\n+    int r = heapinsert(&h, j2);\n     assertf(r, \"insert should succeed\");\n     assertf(j2->heap_index == 0, \"should match\");\n \n@@ -93,20 +89,20 @@ cttest_heap_priority()\n void\n cttest_heap_fifo_property()\n {\n-    Heap h = {0};\n-    int r;\n+    Heap h = {\n+        .less = job_pri_less,\n+        .rec = job_setheappos,\n+    };\n     job j, j3a, j3b, j3c;\n \n-    h.less = job_pri_less;\n-    h.rec = job_setheappos;\n     j3a = make_job(3, 0, 1, 0, 0);\n     j3b = make_job(3, 0, 1, 0, 0);\n     j3c = make_job(3, 0, 1, 0, 0);\n     assertf(j3a, \"allocate job\");\n     assertf(j3b, \"allocate job\");\n     assertf(j3c, \"allocate job\");\n \n-    r = heapinsert(&h, j3a);\n+    int r = heapinsert(&h, j3a);\n     assertf(r, \"insert should succeed\");\n     assertf(h.data[0] == j3a, \"j3a should be in pos 0\");\n     assertf(j3a->heap_index == 0, \"should match\");\n@@ -140,22 +136,22 @@ cttest_heap_fifo_property()\n void\n cttest_heap_many_jobs()\n {\n-    Heap h = {0};\n-    uint last_pri;\n-    int r, i, n = 20;\n+    Heap h = {\n+        .less = job_pri_less,\n+        .rec = job_setheappos,\n+    };\n+    const int n = 20;\n     job j;\n \n-    h.less = job_pri_less;\n-    h.rec = job_setheappos;\n-\n+    int i;\n     for (i = 0; i < n; i++) {\n         j = make_job(1 + rand() % 8192, 0, 1, 0, 0);\n         assertf(j, \"allocation\");\n-        r = heapinsert(&h, j);\n+        int r = heapinsert(&h, j);\n         assertf(r, \"heapinsert\");\n     }\n \n-    last_pri = 0;\n+    uint last_pri = 0;\n     for (i = 0; i < n; i++) {\n         j = heapremove(&h, 0);\n         assertf(j->r.pri >= last_pri, \"should come out in order\");\n@@ -166,29 +162,28 @@ cttest_heap_many_jobs()\n void\n cttest_heap_remove_k()\n {\n-    Heap h = {0};\n-    uint last_pri;\n-    int r, i, c, n = 20;\n-    job j;\n-\n-    h.less = job_pri_less;\n-    h.rec = job_setheappos;\n+    Heap h = {\n+        .less = job_pri_less,\n+        .rec = job_setheappos,\n+    };\n+    const int n = 20;\n \n+    int c, i;\n     for (c = 0; c < 50; c++) {\n         for (i = 0; i < n; i++) {\n-            j = make_job(1 + rand() % 8192, 0, 1, 0, 0);\n+            job j = make_job(1 + rand() % 8192, 0, 1, 0, 0);\n             assertf(j, \"allocation\");\n-            r = heapinsert(&h, j);\n+            int r = heapinsert(&h, j);\n             assertf(r, \"heapinsert\");\n         }\n \n         /* remove one from the middle */\n         heapremove(&h, 25);\n \n         /* now make sure the rest are still a valid heap */\n-        last_pri = 0;\n+        uint last_pri = 0;\n         for (i = 1; i < n; i++) {\n-            j = heapremove(&h, 0);\n+            job j = heapremove(&h, 0);\n             assertf(j->r.pri >= last_pri, \"should come out in order\");\n             last_pri = j->r.pri;\n         }\n@@ -198,18 +193,18 @@ cttest_heap_remove_k()\n void\n ctbench_heap_insert(int n)\n {\n-    job *j;\n-    int i;\n-    j = calloc(n, sizeof *j);\n+    job *j = calloc(n, sizeof *j);\n     assert(j);\n+    int i;\n     for (i = 0; i < n; i++) {\n         j[i] = make_job(1, 0, 1, 0, 0);\n         assert(j[i]);\n         j[i]->r.pri = -j[i]->r.id;\n     }\n-    Heap h = {0};\n-    h.less = job_pri_less;\n-    h.rec = job_setheappos;\n+    Heap h = {\n+        .less = job_pri_less,\n+        .rec = job_setheappos,\n+    };\n     ctresettimer();\n     for (i = 0; i < n; i++) {\n         heapinsert(&h, j[i]);\n@@ -219,14 +214,14 @@ ctbench_heap_insert(int n)\n void\n ctbench_heap_remove(int n)\n {\n-    Heap h = {0};\n-    job j;\n-    int i;\n+    Heap h = {\n+        .less = job_pri_less,\n+        .rec = job_setheappos,\n+    };\n \n-    h.less = job_pri_less;\n-    h.rec = job_setheappos;\n+    int i;\n     for (i = 0; i < n; i++) {\n-        j = make_job(1, 0, 1, 0, 0);\n+        job j = make_job(1, 0, 1, 0, 0);\n         assertf(j, \"allocate job\");\n         heapinsert(&h, j);\n     }\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -89,6 +89,7 @@ mustdiallocal(int port)\n static void\n exit_process(int signum)\n {\n+    UNUSED_PARAMETER(signum);\n     exit(0);\n }\n \n", "test_patch": "", "problem_statement": "use size_t for indexes in the heap structure\nPreviously \"int\" was used, it may be too small on some architectures.\r\nThis change uses \"size_t\" instead, since index cannot be negative.\r\n\r\nIn the heapremove function it removes the assignment to the heap_index\r\nfield of deleted member.\r\n\r\nAs usual in affected functions, I have moved  declarations of variables close\r\nto their usage.\r\n\r\nUpdates #443", "version": "1.11", "language": "C", "created_at": "2019-07-10T09:14:46Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-259", "repo": "beanstalkd/beanstalkd", "pull_number": 259, "base_commit": "86231ba548862c755796489dcfb500770620a5b2", "patch": "diff --git a/main.c b/main.c\n--- a/main.c\n+++ b/main.c\n@@ -10,7 +10,8 @@\n #include \"dat.h\"\n \n static void\n-su(const char *user) {\n+su(const char *user) \n+{\n     int r;\n     struct passwd *pwent;\n \n", "test_patch": "", "problem_statement": "Update main.c\nfixed a \"{}\" code style  in main.c", "version": "1.10", "language": "C", "created_at": "2014-12-20T10:55:06Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-192", "repo": "beanstalkd/beanstalkd", "pull_number": 192, "base_commit": "7518ddca9642f70cf0b01094c7229721e4a0f1a6", "patch": "diff --git a/doc/protocol.txt b/doc/protocol.txt\n--- a/doc/protocol.txt\n+++ b/doc/protocol.txt\n@@ -168,9 +168,10 @@ may be:\n  - \"JOB_TOO_BIG\\r\\n\" The client has requested to put a job with a body larger\n    than max-job-size bytes.\n \n- - \"DRAINING\\r\\n\" This means that the server has been put into \"drain mode\"\n-   and is no longer accepting new jobs. The client should try another server\n-   or disconnect and try again later.\n+ - \"DRAINING\\r\\n\" This means that the server has been put into \"drain mode\" and\n+   is no longer accepting new jobs. The client should try another server or\n+   disconnect and try again later. To put the server in drain mode, send the\n+   SIGUSR1 signal to the process.\n \n The \"use\" command is for producers. Subsequent put commands will put jobs into\n the tube specified by this command. If no use command has been issued, jobs\n", "test_patch": "", "problem_statement": "Document \"drain mode\"\nThis pull request fixes #181.", "version": "1.10", "language": "C", "created_at": "2013-06-28T19:44:16Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-462", "repo": "beanstalkd/beanstalkd", "pull_number": 462, "base_commit": "afd8d4ba55c07af66f773fffc381eff18960fcd0", "patch": "diff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -701,8 +701,8 @@ cttest_reserve_ttr_deadline_soon()\n     ckrespsub(prod, \"OK \");\n     ckrespsub(prod, \"\\nstate: reserved\\n\");\n \n-    // After 0.6s the job should time out and be ready again.\n-    usleep(600000);\n+    // After 0.7s the job should time out and be ready again.\n+    usleep(700000);\n     mustsend(prod, \"stats-job 1\\r\\n\");\n     ckrespsub(prod, \"OK \");\n     ckrespsub(prod, \"\\nstate: ready\\n\");\n@@ -762,6 +762,49 @@ cttest_unpause_tube()\n     ckresp(fd1, \"\\r\\n\");\n }\n \n+void\n+cttest_list_tube()\n+{\n+    port = SERVER();\n+    int fd0 = mustdiallocal(port);\n+\n+    mustsend(fd0, \"watch w\\r\\n\");\n+    ckresp(fd0, \"WATCHING 2\\r\\n\");\n+\n+    mustsend(fd0, \"use u\\r\\n\");\n+    ckresp(fd0, \"USING u\\r\\n\");\n+\n+    mustsend(fd0, \"list-tubes\\r\\n\");\n+    ckrespsub(fd0, \"OK \");\n+    ckresp(fd0,\n+           \"---\\n\"\n+           \"- default\\n\"\n+           \"- w\\n\"\n+           \"- u\\n\\r\\n\");\n+\n+    mustsend(fd0, \"list-tube-used\\r\\n\");\n+    ckresp(fd0, \"USING u\\r\\n\");\n+\n+    mustsend(fd0, \"list-tubes-watched\\r\\n\");\n+    ckrespsub(fd0, \"OK \");\n+    ckresp(fd0,\n+           \"---\\n\"\n+           \"- default\\n\"\n+           \"- w\\n\\r\\n\");\n+\n+    mustsend(fd0, \"ignore default\\r\\n\");\n+    ckresp(fd0, \"WATCHING 1\\r\\n\");\n+\n+    mustsend(fd0, \"list-tubes-watched\\r\\n\");\n+    ckrespsub(fd0, \"OK \");\n+    ckresp(fd0,\n+           \"---\\n\"\n+           \"- w\\n\\r\\n\");\n+\n+    mustsend(fd0, \"ignore w\\r\\n\");\n+    ckresp(fd0, \"NOT_IGNORED\\r\\n\");\n+}\n+\n void\n cttest_binlog_empty_exit()\n {\n", "test_patch": "", "problem_statement": "test list-tube* commands\nUpdates #424", "version": "1.11", "language": "C", "created_at": "2019-07-12T14:40:18Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-434", "repo": "beanstalkd/beanstalkd", "pull_number": 434, "base_commit": "4ad7f72ea797939a079a6868f5658afc9a966ac2", "patch": "diff --git a/doc/protocol.txt b/doc/protocol.txt\n--- a/doc/protocol.txt\n+++ b/doc/protocol.txt\n@@ -649,6 +649,9 @@ beanstalkd process starts; they are not stored on disk with the -b flag.\n  - \"binlog-records-migrated\" is the cumulative number of records written\n    as part of compaction.\n \n+ - \"draining\" is set to \"true\" if the server is in drain mode,\n+   \"false\" otherwise.\n+\n  - \"id\" is a random id string for this server process, generated when each\n    beanstalkd process starts.\n \n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -185,6 +185,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n     \"binlog-records-migrated: %\" PRId64 \"\\n\" \\\n     \"binlog-records-written: %\" PRId64 \"\\n\" \\\n     \"binlog-max-size: %d\\n\" \\\n+    \"draining: %s\\n\" \\\n     \"id: %s\\n\" \\\n     \"hostname: %s\\n\" \\\n     \"\\r\\n\"\n@@ -931,6 +932,7 @@ fmt_stats(char *buf, size_t size, void *x)\n             srv->wal.nmig,\n             srv->wal.nrec,\n             srv->wal.filesize,\n+            drain_mode ? \"true\" : \"false\",\n             id,\n             node_info.nodename);\n }\n", "test_patch": "", "problem_statement": "add draining status to the \"stats\" command\nFixes #145\r\nCloses #307", "version": "1.11", "language": "C", "created_at": "2019-07-03T14:43:25Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-89", "repo": "beanstalkd/beanstalkd", "pull_number": 89, "base_commit": "0e6ed5810b18b0b64270a0794911d93192340456", "patch": "diff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -80,8 +80,8 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define MSG_RELEASED \"RELEASED\\r\\n\"\n #define MSG_BURIED \"BURIED\\r\\n\"\n #define MSG_TOUCHED \"TOUCHED\\r\\n\"\n-#define MSG_BURIED_FMT \"BURIED %llu\\r\\n\"\n-#define MSG_INSERTED_FMT \"INSERTED %llu\\r\\n\"\n+#define MSG_BURIED_FMT \"BURIED %\"PRIu64\"\\r\\n\"\n+#define MSG_INSERTED_FMT \"INSERTED %\"PRIu64\"\\r\\n\"\n #define MSG_NOT_IGNORED \"NOT_IGNORED\\r\\n\"\n \n #define MSG_NOTFOUND_LEN CONSTSTRLEN(MSG_NOTFOUND)\n@@ -313,7 +313,7 @@ reply_job(conn c, job j, const char *word)\n     c->out_job = j;\n     c->out_job_sent = 0;\n \n-    return reply_line(c, STATE_SENDJOB, \"%s %llu %u\\r\\n\",\n+    return reply_line(c, STATE_SENDJOB, \"%s %\"PRIu64\" %u\\r\\n\",\n                       word, j->r.id, j->r.body_size - 2);\n }\n \n@@ -803,7 +803,7 @@ enqueue_incoming_job(conn c)\n     }\n \n     if (verbose >= 2) {\n-        printf(\"<%d job %llu\\n\", c->sock.fd, j->r.id);\n+        printf(\"<%d job %\"PRIu64\"\\n\", c->sock.fd, j->r.id);\n     }\n \n     if (drain_mode) {\n@@ -1714,7 +1714,7 @@ conn_data(conn c)\n         /* are we done? */\n         if (c->out_job_sent == j->r.body_size) {\n             if (verbose >= 2) {\n-                printf(\">%d job %llu\\n\", c->sock.fd, j->r.id);\n+                printf(\">%d job %\"PRIu64\"\\n\", c->sock.fd, j->r.id);\n             }\n             return reset_conn(c);\n         }\n@@ -1920,7 +1920,7 @@ prot_replay(Srv *s, job list)\n             /* fall through */\n         default:\n             r = enqueue_job(s, j, delay, 0);\n-            if (r < 1) twarnx(\"error recovering job %llu\", j->r.id);\n+            if (r < 1) twarnx(\"error recovering job %\"PRIu64, j->r.id);\n         }\n     }\n }\n", "test_patch": "", "problem_statement": "Replace %llu with PRIu64 for compatibility\nFailed to compile here on x86_64 Arch Linux with gcc 4.6.2, so I fixed it according to http://stackoverflow.com/questions/165188/printf-uint-64-on-solaris-9", "version": "1.4", "language": "C", "created_at": "2012-01-23T12:18:51Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-363", "repo": "beanstalkd/beanstalkd", "pull_number": 363, "base_commit": "b7b4a6a14b7e8d096dc8cbc255b23be17a228cbb", "patch": "diff --git a/doc/protocol.zh-CN.md b/doc/protocol.zh-CN.md\n--- a/doc/protocol.zh-CN.md\n+++ b/doc/protocol.zh-CN.md\n@@ -1,10 +1,10 @@\n-##Beanstalkd\u4e2d\u6587\u534f\u8bae\n+## Beanstalkd\u4e2d\u6587\u534f\u8bae\n \n-###\u603b\u62ec\n+### \u603b\u62ec\n \n `beanstalkd`\u534f\u8bae\u57fa\u4e8eASCII\u7f16\u7801\u8fd0\u884c\u5728tcp\u4e0a\u3002\u5ba2\u6237\u7aef\u8fde\u63a5\u670d\u52a1\u5668\u5e76\u53d1\u9001\u6307\u4ee4\u548c\u6570\u636e\uff0c\u7136\u540e\u7b49\u5f85\u54cd\u5e94\u5e76\u5173\u95ed\u8fde\u63a5\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u8fde\u63a5\uff0c\u670d\u52a1\u5668\u6309\u7167\u63a5\u6536\u547d\u4ee4\u7684\u5e8f\u5217\u4f9d\u6b21\u5904\u7406\u5e76\u54cd\u5e94\u3002\u6240\u6709\u6574\u578b\u503c\u90fd\u975e\u8d1f\u7684\u5341\u8fdb\u5236\u6570\uff0c\u9664\u975e\u6709\u7279\u522b\u58f0\u660e\u3002\n \n-###\u540d\u79f0\u7ea6\u5b9a\n+### \u540d\u79f0\u7ea6\u5b9a\n \n \u6240\u6709\u540d\u79f0\u5fc5\u987b\u662fASCII\u7801\u5b57\u7b26\u4e32\uff0c\u5373\u5305\u62ec\uff1a\n \n@@ -21,7 +21,7 @@\n \n **\u6ce8\u610f**\uff1a\u540d\u79f0\u4e0d\u80fd\u4ee5\u8fde\u5b57\u7b26\u5f00\u59cb\uff0c\u5e76\u4e14\u662f\u4ee5\u7a7a\u767d\u5b57\u7b26\u7ed3\u675f\uff0c\u6bcf\u4e2a\u540d\u79f0\u81f3\u5c11\u5305\u542b\u4e00\u4e2a\u5b57\u7b26\u3002\n \n-###\u9519\u8bef\u8bf4\u660e\n+### \u9519\u8bef\u8bf4\u660e\n \n | \u8fd4\u56de\u7684\u9519\u8bef                               | \u63cf\u8ff0       |\n | --------------------------------------- | -------- |\n@@ -30,7 +30,7 @@\n | `BAD_FORMAT\\r\\n`                         | \u683c\u5f0f\u4e0d\u6b63\u786e\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u7684\u6307\u4ee4\u683c\u5f0f\u51fa\u9519\uff0c\u6709\u53ef\u80fd\u4e0d\u662f\u4ee5\\r\\n\u7ed3\u5c3e\uff0c\u6216\u8005\u8981\u6c42\u6574\u578b\u503c\u7b49\u7b49 |\n | `UNKNOWN_COMMAND\\r\\n`                   | \u672a\u77e5\u7684\u547d\u4ee4\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u7684\u6307\u4ee4\u670d\u52a1\u5668\u4e0d\u7406\u89e3 |\n \n-###job\u7684\u751f\u547d\u5468\u671f\n+### job\u7684\u751f\u547d\u5468\u671f\n \u4e00\u4e2a\u5de5\u4f5c\u4efb\u52a1job\u5f53client\u4f7f\u7528put\u547d\u4ee4\u65f6\u521b\u5efa\u3002\u5728\u6574\u4e2a\u751f\u547d\u5468\u671f\u4e2djob\u53ef\u80fd\u6709\u56db\u4e2a\u5de5\u4f5c\u72b6\u6001\uff1aready\uff0creserved\uff0cdelayed\uff0cburied\u3002\u5728put\u4e4b\u540e\uff0c\u4e00\u4e2ajob\u7684\u5178\u578b\u72b6\u6001\u662fready\uff0c\u5728ready\u961f\u5217\u4e2d\uff0c\u5b83\u5c06\u7b49\u5f85\u4e00\u4e2aworker\u53d6\u51fa\u6b64job\u5e76\u8bbe\u7f6e\u4e3a\u5176\u4e3areserved\u72b6\u6001\u3002worker\u5360\u6709\u6b64job\u5e76\u6267\u884c\uff0c\u5f53job\u6267\u884c\u5b8c\u6bd5\uff0cworker\u53ef\u4ee5\u53d1\u9001\u4e00\u4e2adelete\u6307\u4ee4\u5220\u9664\u6b64job\u3002\n \n | Status              | Description   |\n@@ -69,16 +69,16 @@ job\u53ef\u80fd\u7684\u72b6\u6001\u8fc1\u79fb\n                         `--------> *poof*\n ```\n \n-##Tubes\n+## Tubes\n \u4e00\u4e2a\u670d\u52a1\u5668\u6709\u4e00\u4e2a\u6216\u8005\u591a\u4e2atubes\uff0c\u7528\u6765\u50a8\u5b58\u7edf\u4e00\u7c7b\u578b\u7684job\u3002\u6bcf\u4e2atube\u7531\u4e00\u4e2a\u5c31\u7eea\u961f\u5217\u4e0e\u5ef6\u8fdf\u961f\u5217\u7ec4\u6210\u3002\u6bcf\u4e2ajob\u6240\u6709\u7684\u72b6\u6001\u8fc1\u79fb\u5728\u4e00\u4e2atube\u4e2d\u5b8c\u6210\u3002consumers\u6d88\u8d39\u8005\u53ef\u4ee5\u76d1\u63a7\u611f\u5174\u8da3\u7684tube\uff0c\u901a\u8fc7\u53d1\u9001watch\u6307\u4ee4\u3002consumers\u6d88\u8d39\u8005\u53ef\u4ee5\u53d6\u6d88\u76d1\u63a7tube\uff0c\u901a\u8fc7\u53d1\u9001ignore\u547d\u4ee4\u3002\u901a\u8fc7watch list\u547d\u4ee4\u8fd4\u56de\u6240\u6709\u76d1\u63a7\u7684tubes\uff0c\u5f53\u5ba2\u6237\u7aef\u9884\u8ba2\u4e00\u4e2ajob\uff0c\u6b64job\u53ef\u80fd\u6765\u81ea\u4efb\u4f55\u4e00\u4e2a\u5b83\u76d1\u63a7\u7684tube\u3002\n \n \u5f53\u4e00\u4e2a\u5ba2\u6237\u7aef\u8fde\u63a5\u4e0a\u670d\u52a1\u5668\u65f6\uff0c\u5ba2\u6237\u7aef\u76d1\u63a7\u7684tube\u9ed8\u8ba4\u4e3adefaut\uff0c\u5982\u679c\u5ba2\u6237\u7aef\u63d0\u4ea4job\u65f6\uff0c\u6ca1\u6709\u4f7f\u7528use\u547d\u4ee4\uff0c\u90a3\u4e48\u8fd9\u4e9bjob\u5c31\u5b58\u4e8e\u540d\u4e3adefault\u7684tube\u4e2d\u3002\n \n tube\u6309\u9700\u6c42\u521b\u5efa\uff0c\u65e0\u8bba\u4ed6\u4eec\u5728\u4ec0\u4e48\u65f6\u5019\u88ab\u5f15\u7528\u5230\u3002\u5982\u679c\u4e00\u4e2atube\u53d8\u4e3a\u7a7a\uff08\u5373no ready jobs\uff0cno delayed jobs\uff0cno buried jobs\uff09\u548c\u6ca1\u6709\u4efb\u4f55\u5ba2\u6237\u7aef\u5f15\u7528\uff0c\u5b83\u5c06\u4f1a\u88ab\u81ea\u52a8\u5220\u9664\u3002\n \n-###\u6307\u4ee4\u8bf4\u660e\uff08Commands\uff09\n-####\u751f\u4ea7\u8005\u6307\u4ee4\u8bf4\u660e\uff08Producer Commands\uff09\n-####`put`\n+### \u6307\u4ee4\u8bf4\u660e\uff08Commands\uff09\n+#### \u751f\u4ea7\u8005\u6307\u4ee4\u8bf4\u660e\uff08Producer Commands\uff09\n+#### `put`\n \n \u63d2\u5165\u4e00\u4e2ajob\u5230\u961f\u5217\n \n@@ -117,7 +117,7 @@ DRAINING\\r\\n\n \u8868\u793a\u670d\u52a1\u5668\u8d44\u6e90\u8017\u5c3d\uff0c\u8868\u793a\u670d\u52a1\u5668\u5df2\u7ecf\u8fdb\u5165\u4e86\u201cdrain mode\u201d\uff0c\u670d\u52a1\u5668\u518d\u4e5f\u4e0d\u80fd\u63a5\u53d7\u8fde\u63a5\uff0c\u5ba2\u6237\u7aef\u5e94\u8be5\u4f7f\u7528\u53e6\u4e00\u4e2a\u670d\u52a1\u5668\u6216\u8005\u65ad\u5f00\u7a0d\u540e\u91cd\u8bd5\n \n \n-####`use`\n+#### `use`\n \u8bf4\u660e\n producer\u751f\u4ea7\u8005\u4f7f\u7528\uff0c\u968f\u540e\u4f7f\u7528put\u547d\u4ee4\uff0c\u5c06job\u653e\u7f6e\u4e8e\u5bf9\u5e94\u7684tube\n \u683c\u5f0f\n@@ -131,7 +131,7 @@ USING <tube>\\r\\n tube\u4e3a\u6b63\u5728\u4f7f\u7528\u7684tube\u540d\u79f0\n ```\n \u6d88\u8d39\u8005\u6307\u4ee4\u8bf4\u660e\uff08Worker Commands\uff09\n \n-####`reserve`\n+#### `reserve`\n \u8bf4\u660e\n \u53d6\u51fa\uff08\u9884\u8ba2\uff09job\uff0c\u5f85\u5904\u7406\u3002\u5b83\u5c06\u8fd4\u56de\u4e00\u4e2a\u65b0\u9884\u8ba2\u7684job\uff0c\u5982\u679c\u6ca1\u6709job\uff0cbeanstalkd\u5c06\u76f4\u5230\u6709job\u65f6\u624d\u53d1\u9001\u54cd\u5e94\u3002\u4e00\u65e6job\u72b6\u6001\u8fc1\u79fb\u4e3areserved,\u53d6\u51fajob\u7684client\u88ab\u9650\u5236\u5728\u6307\u5b9a\u7684\u65f6\u95f4\uff08\u5982\u679c\u8bbe\u7f6e\u4e86ttr\uff09\u5b8c\u6210\uff0c\u5426\u5219\u8d85\u65f6\uff0cjob\u72b6\u6001\u91cd\u88c5\u8fc1\u79fb\u4e3aready\u3002\n \u683c\u5f0f\n@@ -140,7 +140,7 @@ reserve\\r\\n\n ```\n \u53ef\u9009\u7684\u4e00\u4e2a\u76f8\u4f3c\u7684\u547d\u4ee4\n `reserve-with-timeout \\r\\n` \u8bbe\u7f6e\u53d6job\u7684\u8d85\u65f6\u65f6\u95f4\uff0ctimeout\u8bbe\u7f6e\u4e3a0\u65f6\uff0c\u670d\u52a1\u5668\u7acb\u5373\u54cd\u5e94\u6216\u8005TIMED_OUT\uff0c\u79ef\u6781\u7684\u8bbe\u7f6e\u8d85\u65f6\uff0c\u5c06\u4f1a\u9650\u5236\u5ba2\u6237\u7aef\u963b\u585e\u5728\u53d6job\u7684\u8bf7\u6c42\u7684\u65f6\u95f4\u3002\n-#####\u5931\u8d25\u54cd\u5e94\n+##### \u5931\u8d25\u54cd\u5e94\n ```\n DEADLINE_SOON\\r\\n\n ```\n@@ -150,14 +150,14 @@ DEADLINE_SOON\\r\\n\n ```\n TIMED_OUT\\r\\n \u8d85\u65f6\n ```\n-#####\u6210\u529f\u54cd\u5e94\n+##### \u6210\u529f\u54cd\u5e94\n ```\n RESERVED <id> <bytes>\\r\\n\n <data>\\r\\n\n ```\n \u6210\u529f\u53d6\u51fajob\uff0cid\u4e3ajob id,\u6574\u578b\u503c\uff0cjob body\u7684\u957f\u5ea6\uff0c\u4e0d\u5305\u542b\\r\\n\uff0cdata\u4e3ajob body\n \n-####`delete`\n+#### `delete`\n \u8bf4\u660e\n \u4ece\u961f\u5217\u4e2d\u5220\u9664\u4e00\u4e2ajob\n \u683c\u5f0f\n@@ -168,7 +168,7 @@ id\u4e3ajob id\n \u54cd\u5e94\n DELETED\\r\\n \u5220\u9664\u6210\u529f\n NOT_FOUND\\r\\n job\u4e0d\u5b58\u5728\u65f6\uff0c\u6216\u8005job\u7684\u72b6\u6001\u4e0d\u4e3aready\u548cburied\uff08\u8fd9\u79cd\u60c5\u51b5\u662f\u5728job\u6267\u884c\u8d85\u65f6\u4e4b\u524d\uff0cclient\u53d1\u9001\u4e86delete\u6307\u4ee4\uff09\n-####`release`\n+#### `release`\n \u8bf4\u660e\n release\u6307\u4ee4\u5c06\u4e00\u4e2areserved\u7684job\u653e\u56deready queue\u3002\u5b83\u901a\u5e38\u5728job\u6267\u884c\u5931\u8d25\u65f6\u4f7f\u7528\u3002\n \u683c\u5f0f\n@@ -180,7 +180,8 @@ id \u4e3ajob id\uff0cpri\u4e3ajob\u7684\u4f18\u5148\u7ea7\uff0cdelay\u4e3a\u5ef6\u8fdfready\u7684\u79d2\u6570\n RELEASED\\r\\n \u8868\u660e\u6210\u529f\n BURIED\\r\\n \u5982\u670d\u52a1\u5668\u4e3a\u4e86\u589e\u52a0\u961f\u5217\u7684\u4f18\u5148\u7ea7\u800c\uff0c\u5185\u5b58\u4e0d\u8db3\u65f6\u8fd4\u56de\n NOT_FOUND\\r\\n \u5982\u679cjob\u4e0d\u5b58\u5728\u6216\u8005client\u6ca1\u6709\u9884\u8ba2\u6b64job\n-####`bury`\n+\n+#### `bury`\n \u8bf4\u660e\n \u5c06\u4e00\u4e2ajob\u7684\u72b6\u6001\u8fc1\u79fb\u4e3aburied\uff0c\u901a\u8fc7kick\u547d\u4ee4\u5524\u9192\n \u683c\u5f0f\n@@ -191,7 +192,7 @@ id\u4e3ajob id\uff0cpri\u4e3a\u4f18\u5148\u7ea7\n \u54cd\u5e94\n BURIED\\r\\n \u8868\u660e\u6210\u529f\n NOT_FOUND\\r\\n \u5982\u679cjob\u4e0d\u5b58\u5728\u6216\u8005client\u6ca1\u6709\u9884\u8ba2\u6b64job\n-####`touch`\n+#### `touch`\n \u8bf4\u660e\n \u5141\u8bb8worker\u8bf7\u6c42\u66f4\u591a\u7684\u65f6\u95f4\u6267\u884cjob\uff0c\u8fd9\u4e2a\u5f88\u6709\u7528\u5f53job\u9700\u8981\u5f88\u957f\u7684\u65f6\u95f4\u6765\u6267\u884c\uff0cworker\u53ef\u7528\u5468\u671f\u7684\u544a\u8bc9\u670d\u52a1\u5668\u5b83\u4ecd\u7136\u5728\u6267\u884cjob\uff08\u53ef\u4ee5\u88abDEADLINE_SOON\u89e6\u53d1\uff09\n \u683c\u5f0f\n@@ -203,7 +204,7 @@ id\u4e3ajob id\n TOUCHED\\r\\n \u8868\u660e\u6210\u529f\n NOT_FOUND\\r\\n \u5982\u679cjob\u4e0d\u5b58\u5728\u6216\u8005client\u6ca1\u6709\u9884\u8ba2\u6b64job\n \n-####`watch`\n+#### `watch`\n \u8bf4\u660e\n \u6dfb\u52a0\u76d1\u63a7\u7684tube\u5230watch list\u5217\u8868\uff0creserve\u6307\u4ee4\u5c06\u4f1a\u4ece\u76d1\u63a7\u7684tube\u5217\u8868\u83b7\u53d6job\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u8fde\u63a5\uff0c\u76d1\u63a7\u7684\u5217\u8868\u9ed8\u8ba4\u4e3adefault\n \u683c\u5f0f\n@@ -217,7 +218,7 @@ WATCHING <count>\\r\\n \u8868\u660e\u6210\u529f\n ```\n count \u6574\u578b\u503c\uff0c\u5df2\u76d1\u63a7\u7684tube\u6570\u91cf\n \n-####`ignore`\n+#### `ignore`\n \u8bf4\u660e\n \u4ece\u5df2\u76d1\u63a7\u7684watch list\u5217\u8868\u4e2d\u79fb\u51fa\u7279\u5b9a\u7684tube\n \u683c\u5f0f\n@@ -233,7 +234,7 @@ count \u6574\u578b\u503c\uff0c\u5df2\u76d1\u63a7\u7684tube\u6570\u91cf\n NOT_IGNORED\\r\\n \u5982\u679cclient\u4f01\u56fe\u5ffd\u7565\u5176\u4ec5\u6709\u7684tube\u65f6\u7684\u54cd\u5e94\n \u5176\u4ed6\u6307\u4ee4\u8bf4\u660e\uff08Other Command\uff09\n \n-####`peek`\n+#### `peek`\n \u8bf4\u660e\n \u8ba9client\u5728\u7cfb\u7edf\u4e2d\u68c0\u67e5job\uff0c\u6709\u56db\u79cd\u5f62\u5f0f\u7684\u547d\u4ee4\uff0c\u5176\u4e2d\u7b2c\u4e00\u79cd\u5f62\u5f0f\u7684\u6307\u4ee4\u662f\u9488\u5bf9\u5f53\u524d\u4f7f\u7528\u7684tube\n \u683c\u5f0f\n@@ -252,7 +253,7 @@ id \u4e3a\u5bf9\u5e94\u7684job id\n bytes job body\u7684\u5b57\u8282\u6570\n data \u4e3ajob body\n \n-####`kick`\n+#### `kick`\n \u8bf4\u660e\n \u6b64\u6307\u4ee4\u5e94\u7528\u5728\u5f53\u524d\u4f7f\u7528\u7684tube\u4e2d\uff0c\u5b83\u5c06job\u7684\u72b6\u6001\u8fc1\u79fb\u4e3aready\u6216\u8005delayed\n \u683c\u5f0f\n@@ -278,7 +279,7 @@ id \u4e3ajob id\n NOT_FOUND\\r\\n \u5982\u679cjob\u4e0d\u5b58\u5728\uff0c\u6216\u8005job\u662f\u4e0d\u53ef\u5524\u9192\u7684\u72b6\u6001\n KICKED\\r\\n \u8868\u660e\u6210\u529f\n \n-####`stats-job`\n+#### `stats-job`\n \u8bf4\u660e\n \u7edf\u8ba1job\u7684\u76f8\u5173\u4fe1\u606f\n \u683c\u5f0f\n@@ -310,7 +311,7 @@ data \u4e3aYAML file\u7684\u7edf\u8ba1\u4fe1\u606f\n - `buries` \u8868\u793ajob\u88abburied\u7684\u6b21\u6570\n - `kicks` \u8868\u793ajob\u88abkiced\u7684\u6b21\u6570\n \n-####`stats-tube`\n+#### `stats-tube`\n **\u8bf4\u660e**\n \u7edf\u8ba1tube\u7684\u76f8\u5173\u4fe1\u606f\n **\u683c\u5f0f**\n@@ -341,7 +342,7 @@ data \u4e3aYAML file\u7684\u7edf\u8ba1\u4fe1\u606f\n - `cmd-pause-tube` \u6b64tube\u4e2d\u603b\u5171\u6267\u884cpause-tube\u6307\u4ee4\u7684\u6b21\u6570\n - `pause-time-left` \u6b64tube\u6682\u505c\u5269\u4f59\u7684\u79d2\u6570\n \n-####`stats`\n+#### `stats`\n **\u8bf4\u660e**\n \u8fd4\u56de\u6574\u4e2a\u6d88\u606f\u961f\u5217\u7cfb\u7edf\u7684\u6574\u4f53\u4fe1\u606f\n **\u683c\u5f0f**\n@@ -401,7 +402,7 @@ data \u4e3aYAML file\u7684\u7edf\u8ba1\u4fe1\u606f\n - `id` \u4e00\u4e2a\u968f\u673a\u5b57\u7b26\u4e32\uff0c\u5728beanstalkd\u8fdb\u7a0b\u542f\u52a8\u65f6\u4ea7\u751f\n - `hostname` \u4e3b\u673a\u540d\n \n-####`list-tubes`\n+#### `list-tubes`\n \u8bf4\u660e\n \u5217\u8868\u6240\u6709\u5b58\u5728\u7684tube\n \u683c\u5f0f\n@@ -418,7 +419,7 @@ OK <bytes>\\r\\n\n bytes \u4e3a\u63a5\u4e0b\u6765\u7684data\u533a\u5757\u7684\u957f\u5ea6\n data \u4e3aYAML file\uff0c\u5305\u542b\u6240\u6709\u7684tube\u540d\u79f0\n \n-####`list-tube-used`\n+#### `list-tube-used`\n \u8bf4\u660e\n \u5217\u8868\u5f53\u524dclient\u6b63\u5728use\u7684tube\n \u683c\u5f0f\n@@ -431,7 +432,7 @@ USING <tube>\\r\\n\n ```\n tube \u4e3atube\u540d\u79f0\n \n-####`list-tubes-watched`\n+#### `list-tubes-watched`\n \u8bf4\u660e\n \u5217\u8868\u5f53\u524dclient watch\u7684tube\n \u683c\u5f0f\n@@ -447,22 +448,22 @@ OK <bytes>\\r\\n\n bytes \u4e3a\u63a5\u4e0b\u6765\u7684data\u533a\u5757\u7684\u957f\u5ea6\n data \u4e3aYAML file\uff0c\u5305\u542b\u6240\u6709\u7684tube\u540d\u79f0\n \n-####`quit`\n+#### `quit`\n \u8bf4\u660e\n \u5173\u95ed\u8fde\u63a5\n \u683c\u5f0f\n ```\n quit\\r\\n\n ```\n \n-####`pause-tube`\n-#####\u8bf4\u660e\n+#### `pause-tube`\n+##### \u8bf4\u660e\n \u6b64\u6307\u4ee4\u9488\u5bf9\u7279\u5b9a\u7684tube\u5185\u6240\u6709\u65b0\u7684job\u5ef6\u8fdf\u7ed9\u5b9a\u7684\u79d2\u6570\n-#####\u683c\u5f0f\n+##### \u683c\u5f0f\n ```\n pause-tube <tube-name> <delay>\\r\\n\n ```\n-#####\u54cd\u5e94\n+##### \u54cd\u5e94\n ```\n PAUSED\\r\\n \u8868\u793a\u6210\u529f\n NOT_FOUND\\r\\n tube\u4e0d\u5b58\u5728\n", "test_patch": "", "problem_statement": "style(1.10): \u4fee\u590dbeanstalkd\u4e2d\u6587\u7248\u534f\u8bae\u5728github\u4e0aMarkdown\u6807\u9898\u683c\u5f0f\u4e0d\u89c4\u8303\u95ee\u9898\nSigned-off-by: Tony Deng <wolf.deng@gmail.com>", "version": "1.10", "language": "C", "created_at": "2017-09-08T08:40:42Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-156", "repo": "beanstalkd/beanstalkd", "pull_number": 156, "base_commit": "84b12d2ca19be39150d8ad484f2e5a0145f2918e", "patch": "diff --git a/doc/protocol.md b/doc/protocol.md\n--- a/doc/protocol.md\n+++ b/doc/protocol.md\n@@ -504,6 +504,8 @@ The stats data for the system is a YAML file representing a single dictionary of\n * `binlog-max-size` is the maximum size in bytes a binlog file is allowed to get before a new binlog file is opened\n * `binlog-records-written` is the cumulative number of records written to the binlog\n * `binlog-records-migrated` is the cumulative number of records written as part of compaction\n+* `id` a unique id for this server process. The id is generated on each startup and is always a random series of 8 bytes base16 encoded\n+* `hostname` the hostname of the machine as determined by uname\n \n #### `list-tubes` command\n \n\ndiff --git a/doc/protocol.txt b/doc/protocol.txt\n--- a/doc/protocol.txt\n+++ b/doc/protocol.txt\n@@ -637,6 +637,11 @@ beanstalkd process starts; they are not stored on disk with the -b flag.\n  - \"binlog-records-migrated\" is the cumulative number of records written\n    as part of compaction\n \n+ - \"id\" a unique id for this server process. The id is generated on each startup and\n+    is always a random series of 8 bytes base16 encoded\n+\n+ - \"hostname\" the hostname of the machine as determined by uname\n+\n The list-tubes command returns a list of all existing tubes. Its form is:\n \n list-tubes\\r\\n\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -8,6 +8,7 @@\n #include <sys/resource.h>\n #include <sys/uio.h>\n #include <sys/types.h>\n+#include <sys/utsname.h>\n #include <sys/socket.h>\n #include <netinet/in.h>\n #include <inttypes.h>\n@@ -183,6 +184,8 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n     \"binlog-records-migrated: %\" PRId64 \"\\n\" \\\n     \"binlog-records-written: %\" PRId64 \"\\n\" \\\n     \"binlog-max-size: %d\\n\" \\\n+    \"id: %s\\n\" \\\n+    \"hostname: %s\\n\" \\\n     \"\\r\\n\"\n \n #define STATS_TUBE_FMT \"---\\n\" \\\n@@ -231,6 +234,14 @@ static tube default_tube;\n \n static int drain_mode = 0;\n static int64 started_at;\n+\n+enum {\n+  NumIdBytes = 8\n+};\n+\n+static char id[NumIdBytes * 2 + 1]; // hex-encoded len of NumIdBytes\n+\n+static struct utsname node_info;\n static uint64 op_ct[TOTAL_OPS], timeout_ct = 0;\n \n static Conn *dirty;\n@@ -917,7 +928,9 @@ fmt_stats(char *buf, size_t size, void *x)\n             wcur,\n             srv->wal.nmig,\n             srv->wal.nrec,\n-            srv->wal.filesize);\n+            srv->wal.filesize,\n+            id,\n+            node_info.nodename);\n \n }\n \n@@ -1933,6 +1946,26 @@ prot_init()\n     started_at = nanoseconds();\n     memset(op_ct, 0, sizeof(op_ct));\n \n+    int dev_random = open(\"/dev/urandom\", O_RDONLY);\n+    if (dev_random < 0) {\n+      twarn(\"Error could not open '/dev/urandom' to generate server id.\");\n+      exit(50);\n+    }\n+\n+    int i, r;\n+    byte rand_data[NumIdBytes];\n+    r = read(dev_random, &rand_data, NumIdBytes);\n+    if (r != NumIdBytes) {\n+      twarn(\"Error could not read '/dev/urandom' to generate server id.\");\n+      exit(50);\n+    }\n+    for (i = 0; i < NumIdBytes; i++) {\n+        sprintf(id + (i * 2), \"%02x\", rand_data[i]);\n+    }\n+    close(dev_random);\n+\n+    uname(&node_info);\n+\n     ms_init(&tubes, NULL, NULL);\n \n     TUBE_ASSIGN(default_tube, tube_find_or_make(\"default\"));\n", "test_patch": "", "problem_statement": "Add id and hostname to server\nI have taken the diff and Keith's  comments from \n\nhttps://github.com/frew/beanstalkd/commit/829879a73898f9334538ffc50360d9e9960f7727\n\non adding a guid to a server.\n\nHow does this look?", "version": "1.8", "language": "C", "created_at": "2012-12-04T22:15:27Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-369", "repo": "beanstalkd/beanstalkd", "pull_number": 369, "base_commit": "c7c001d943fc17a55b64d82344de0793f101ea4e", "patch": "diff --git a/doc/protocol.zh-CN.md b/doc/protocol.zh-CN.md\n--- a/doc/protocol.zh-CN.md\n+++ b/doc/protocol.zh-CN.md\n@@ -139,7 +139,7 @@ USING <tube>\\r\\n tube\u4e3a\u6b63\u5728\u4f7f\u7528\u7684tube\u540d\u79f0\n reserve\\r\\n\n ```\n \u53ef\u9009\u7684\u4e00\u4e2a\u76f8\u4f3c\u7684\u547d\u4ee4\n-`reserve-with-timeout \\r\\n` \u8bbe\u7f6e\u53d6job\u7684\u8d85\u65f6\u65f6\u95f4\uff0ctimeout\u8bbe\u7f6e\u4e3a0\u65f6\uff0c\u670d\u52a1\u5668\u7acb\u5373\u54cd\u5e94\u6216\u8005TIMED_OUT\uff0c\u79ef\u6781\u7684\u8bbe\u7f6e\u8d85\u65f6\uff0c\u5c06\u4f1a\u9650\u5236\u5ba2\u6237\u7aef\u963b\u585e\u5728\u53d6job\u7684\u8bf7\u6c42\u7684\u65f6\u95f4\u3002\n+`reserve-with-timeout <seconds>\\r\\n` \u8bbe\u7f6e\u53d6job\u7684\u8d85\u65f6\u65f6\u95f4\uff0ctimeout\u8bbe\u7f6e\u4e3a0\u65f6\uff0c\u670d\u52a1\u5668\u7acb\u5373\u54cd\u5e94\u6216\u8005TIMED_OUT\uff0c\u79ef\u6781\u7684\u8bbe\u7f6e\u8d85\u65f6\uff0c\u5c06\u4f1a\u9650\u5236\u5ba2\u6237\u7aef\u963b\u585e\u5728\u53d6job\u7684\u8bf7\u6c42\u7684\u65f6\u95f4\u3002\n ##### \u5931\u8d25\u54cd\u5e94\n ```\n DEADLINE_SOON\\r\\n\n", "test_patch": "", "problem_statement": "Update protocol.zh-CN.md\nadd `reserve-with-timeout` args  \"seconds\" which were omissive before.", "version": "1.10", "language": "C", "created_at": "2017-12-05T05:08:30Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-185", "repo": "beanstalkd/beanstalkd", "pull_number": 185, "base_commit": "b3ae0929726632a0269fb3c913d4810408371af5", "patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -1,5 +1,6 @@\n+DESTDIR=\n PREFIX=/usr/local\n-BINDIR=$(PREFIX)/bin\n+BINDIR=$(DESTDIR)$(PREFIX)/bin\n CFLAGS=-Wall -Werror\\\n \t-Wformat=2\\\n \t-g\\\n", "test_patch": "", "problem_statement": "Add DESTDIR support to Makefile\nThis commit adds support for building packages using debuild. It does not negatively affect other build processes, as the injection of $(DESTDIR) is a no-op otherwise.", "version": "1.9", "language": "C", "created_at": "2013-05-31T15:34:59Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-494", "repo": "beanstalkd/beanstalkd", "pull_number": 494, "base_commit": "24c6b2fdd87cc20c00166f5d22e6b8492f7c3054", "patch": "diff --git a/doc/protocol.zh-CN.md b/doc/protocol.zh-CN.md\n--- a/doc/protocol.zh-CN.md\n+++ b/doc/protocol.zh-CN.md\n@@ -236,7 +236,7 @@ NOT_IGNORED\\r\\n \u5982\u679cclient\u4f01\u56fe\u5ffd\u7565\u5176\u4ec5\u6709\u7684tube\u65f6\u7684\u54cd\u5e94\n \n #### `peek`\n \u8bf4\u660e\n-\u8ba9client\u5728\u7cfb\u7edf\u4e2d\u68c0\u67e5job\uff0c\u6709\u56db\u79cd\u5f62\u5f0f\u7684\u547d\u4ee4\uff0c\u5176\u4e2d\u7b2c\u4e00\u79cd\u5f62\u5f0f\u7684\u6307\u4ee4\u662f\u9488\u5bf9\u5f53\u524d\u4f7f\u7528\u7684tube\n+\u8ba9client\u5728\u7cfb\u7edf\u4e2d\u68c0\u67e5job\uff0c\u6709\u56db\u79cd\u5f62\u5f0f\u7684\u547d\u4ee4\uff0c\u9664\u7b2c\u4e00\u79cd\u5f62\u5f0f\u5916\uff0c\u5176\u5b83\u5747\u9488\u5bf9\u5f53\u524d\u6b63\u5728\u4f7f\u7528\u7684tube\u3002\n \u683c\u5f0f\n ```\n peek <id>\\r\\n  \u8fd4\u56deid\u5bf9\u5e94\u7684job\n", "test_patch": "", "problem_statement": "Fix #485 Chinese protocol wrong translate of peek section.\nFix wrong translate peek section of chinese protocol document.", "version": "1.11", "language": "C", "created_at": "2019-07-25T07:47:25Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-217", "repo": "beanstalkd/beanstalkd", "pull_number": 217, "base_commit": "157d88bf9435a23b71a1940a9afb617e52a2b9e9", "patch": "diff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -1582,6 +1582,7 @@ dispatch_cmd(Conn *c)\n         if (r) return reply_msg(c, MSG_BAD_FORMAT);\n \n         *delay_buf = '\\0';\n+        if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT);\n         t = tube_find(name);\n         if (!t) return reply_msg(c, MSG_NOTFOUND);\n \n", "test_patch": "", "problem_statement": "pause-tube should check tube name is ok\nThis change updates pause-tube to return BAD_FORMAT when an invalid tube name is supplied. At present pause-tube will return NOT_FOUND after it fails to find an invalid tube.\n\nThis is more of a consistency thing than a bug, per se. \n\nct tests all pass.", "version": "1.9", "language": "C", "created_at": "2013-11-12T11:19:10Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-436", "repo": "beanstalkd/beanstalkd", "pull_number": 436, "base_commit": "3aeec07a32bc73979ed5ff57bb7b2675005587db", "patch": "diff --git a/ct/ct.c b/ct/ct.c\n--- a/ct/ct.c\n+++ b/ct/ct.c\n@@ -323,8 +323,12 @@ runbenchn(Benchmark *b, int n)\n         ctstarttimer();\n         b->f(n);\n         ctstoptimer();\n-        write(durfd, &bdur, sizeof bdur);\n-        write(durfd, &bbytes, sizeof bbytes);\n+        if (write(durfd, &bdur, sizeof bdur) != sizeof bdur) {\n+            die(3, errno, \"write\");\n+        }\n+        if (write(durfd, &bbytes, sizeof bbytes) != sizeof bbytes) {\n+            die(3, errno, \"write\");\n+        }\n         exit(0);\n     }\n     setpgid(pid, pid);\n@@ -380,13 +384,15 @@ static int\n roundup(int n)\n {\n     int base = rounddown10(n);\n-    if (n == base)\n-        return n;\n+    if (n <= base)\n+        return base;\n     if (n <= 2*base)\n-        return 2 * base;\n+        return 2*base;\n+    if (n <= 3*base)\n+        return 3*base;\n     if (n <= 5*base)\n-        return 5 * base;\n-    return 10 * base;\n+        return 5*base;\n+    return 10*base;\n }\n \n \n@@ -426,10 +432,10 @@ runbench(Benchmark *b)\n         } else {\n             n = BenchTime / nsop;\n         }\n-        /* Run more iterations than we think we'll need for a second (1.5x).\n+        /* Run more iterations than we think we'll need for a second (1.2x).\n         Don't grow too fast in case we had timing errors previously.\n         Be sure to run at least one more than last time. */\n-        n = max(min(n+n/2, 100*last), last+1);\n+        n = max(min(n+n/5, 100*last), last+1);\n         /* Round up to something easy to read. */\n         n = roundup(n);\n         runbenchn(b, n);\n@@ -540,7 +546,9 @@ writetokens(int n)\n     if (wjobfd >= 0) {\n         fcntl(wjobfd, F_SETFL, fcntl(wjobfd, F_GETFL)|O_NONBLOCK);\n         for (; n>1; n--) {\n-            write(wjobfd, &c, 1); /* ignore error; nothing we can do anyway */\n+            if (write(wjobfd, &c, 1) != 1) {\n+                /* ignore error; nothing we can do anyway */\n+            }\n         }\n     }\n }\n\ndiff --git a/ct/gen b/ct/gen\n--- a/ct/gen\n+++ b/ct/gen\n@@ -33,14 +33,14 @@ done\n \n printf 'Test ctmaintest[] = {\\n'\n for t in $ts\n-do printf '    {%s, \"%s\"},\\n' $t $t\n+do printf '    {%s, \"%s\", 0, 0, 0, TmpDirPat},\\n' $t $t\n done\n printf '    {0},\\n'\n printf '};\\n'\n \n printf 'Benchmark ctmainbench[] = {\\n'\n for b in $bs\n-do printf '    {%s, \"%s\"},\\n' $b $b\n+do printf '    {%s, \"%s\", 0, 0, 0, TmpDirPat},\\n' $b $b\n done\n printf '    {0},\\n'\n printf '};\\n'\n", "test_patch": "", "problem_statement": "update ct to kr/ct@d16c7bc\nUpdate ct to kr/ct@d16c7bc", "version": "1.11", "language": "C", "created_at": "2019-07-03T20:49:13Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-449", "repo": "beanstalkd/beanstalkd", "pull_number": 449, "base_commit": "8a5aabccd3187054312e6bbc1a0ef2219fbaa1a1", "patch": "diff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -1,3 +1,7 @@\n+branches:\n+    only:\n+        - master\n+\n git:\n     quiet: true\n     depth: 5\n", "test_patch": "", "problem_statement": "build master on travis-ci after each merge\nThis prevented codecov from showing correct coverage diff because\r\nthe base (master) was not ever built after the merge.", "version": "1.11", "language": "C", "created_at": "2019-07-08T11:40:59Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-301", "repo": "beanstalkd/beanstalkd", "pull_number": 301, "base_commit": "96e875678bb262343a0caa461b8927a2d2260f6f", "patch": "diff --git a/walg.c b/walg.c\n--- a/walg.c\n+++ b/walg.c\n@@ -445,7 +445,7 @@ walread(Wal *w, job list, int min, int max)\n     int i, fd;\n     int err = 0;\n \n-    for (i = min; i < w->next; i++) {\n+    for (i = min; i < max; i++) {\n         f = new(File);\n         if (!f) {\n             twarnx(\"OOM\");\n\ndiff --git a/walg.c b/walg.c\n--- a/walg.c\n+++ b/walg.c\n@@ -439,13 +439,13 @@ waldirlock(Wal *w)\n \n \n void\n-walread(Wal *w, job list, int min, int max)\n+walread(Wal *w, job list, int min)\n {\n     File *f;\n     int i, fd;\n     int err = 0;\n \n-    for (i = min; i < max; i++) {\n+    for (i = min; i < w->next; i++) {\n         f = new(File);\n         if (!f) {\n             twarnx(\"OOM\");\n@@ -485,7 +485,7 @@ walinit(Wal *w, job list)\n     int min;\n \n     min = walscandir(w);\n-    walread(w, list, min, w->next);\n+    walread(w, list, min);\n \n     // first writable file\n     if (!makenextfile(w)) {\n", "test_patch": "", "problem_statement": "MOD: w->next change to max in function walread\nhello @kr \n\nI think it's a good idea to use max to replace w->next in function walread.\n\n``` c\nvoid\nwalread(Wal *w, job list, int min, int max)\n{\n     File *f;\n     int i, fd;\n     int err = 0;\n\n     for (i = min; i < w->next; i++) {\n         ...\n     }\n}\n```", "version": "1.10", "language": "C", "created_at": "2016-04-02T11:41:51Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-208", "repo": "beanstalkd/beanstalkd", "pull_number": 208, "base_commit": "96e875678bb262343a0caa461b8927a2d2260f6f", "patch": "diff --git a/doc/protocol.en-US.md b/doc/protocol.en-US.md\n--- a/doc/protocol.en-US.md\n+++ b/doc/protocol.en-US.md\n@@ -397,6 +397,8 @@ The `stats-job` data is a YAML file representing a single dictionary of strings\n * `state` is `ready` or `delayed` or `reserved` or `buried`\n * `pri` is the priority value set by the put, release, or bury commands.\n * `age` is the time in seconds since the put command that created this job.\n+* `delay` is the integer number of seconds to wait before putting this job in the ready queue.\n+* `ttr` -- time to run -- is the integer number of seconds a worker is allowed to run this job.\n * `time-left` is the number of seconds left until the server puts this job into the ready queue. This number is only meaningful if the job is reserved or delayed. If the job is reserved and this amount of time elapses before its state changes, it is considered to have timed out.\n * `file` is the number of the earliest binlog file containing this job. If -b wasn't used, this will be 0.\n * `reserves` is the number of times this job has been reserved.\n\ndiff --git a/doc/protocol.txt b/doc/protocol.txt\n--- a/doc/protocol.txt\n+++ b/doc/protocol.txt\n@@ -448,6 +448,12 @@ to scalars. It contains these keys:\n \n  - \"age\" is the time in seconds since the put command that created this job.\n \n+ - \"delay\" is the integer number of seconds to wait before putting this job in\n+   the ready queue.\n+\n+ - \"ttr\" -- time to run -- is the integer number of seconds a worker is\n+   allowed to run this job.\n+\n  - \"time-left\" is the number of seconds left until the server puts this job\n    into the ready queue. This number is only meaningful if the job is\n    reserved or delayed. If the job is reserved and this amount of time\n", "test_patch": "", "problem_statement": "Document stats-job values delay and ttr\nDocument delay and ttr values returned by stats-job command. Language borrowed from elsewhere in the docs.", "version": "1.10", "language": "C", "created_at": "2013-10-09T12:57:24Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-447", "repo": "beanstalkd/beanstalkd", "pull_number": 447, "base_commit": "a1a68d091a8b575c96042b83a2caac443f8d73a5", "patch": "diff --git a/doc/protocol.txt b/doc/protocol.txt\n--- a/doc/protocol.txt\n+++ b/doc/protocol.txt\n@@ -296,7 +296,7 @@ The bury command looks like this:\n \n     bury <id> <pri>\\r\\n\n \n- - <id> is the job id to release.\n+ - <id> is the job id to bury.\n \n  - <pri> is a new priority to assign to the job.\n \n@@ -434,10 +434,10 @@ The response is one of:\n    - <bytes> is the size of the following data section in bytes.\n \n    - <data> is a sequence of bytes of length <bytes> from the previous line. It\n-     is a YAML file with statistical information represented a dictionary.\n+     is a YAML file with statistical information represented by a dictionary.\n \n-The stats-job data is a YAML file representing a single dictionary of strings\n-to scalars. It contains these keys:\n+The stats-job data is a YAML file representing a single dictionary of string\n+keys to scalar values. It contains these keys:\n \n  - \"id\" is the job id\n \n@@ -491,10 +491,10 @@ The response is one of:\n    - <bytes> is the size of the following data section in bytes.\n \n    - <data> is a sequence of bytes of length <bytes> from the previous line. It\n-     is a YAML file with statistical information represented a dictionary.\n+     is a YAML file with statistical information represented by a dictionary.\n \n-The stats-tube data is a YAML file representing a single dictionary of strings\n-to scalars. It contains these keys:\n+The stats-tube data is a YAML file representing a single dictionary of string\n+keys to scalar values. It contains these keys:\n \n  - \"name\" is the tube's name.\n \n@@ -544,11 +544,12 @@ The server will respond:\n  - <bytes> is the size of the following data section in bytes.\n \n  - <data> is a sequence of bytes of length <bytes> from the previous line. It\n-   is a YAML file with statistical information represented a dictionary.\n+   is a YAML file with statistical information represented by a dictionary.\n \n The stats data for the system is a YAML file representing a single dictionary\n-of strings to scalars. Entries described as \"cumulative\" are reset when the\n-beanstalkd process starts; they are not stored on disk with the -b flag.\n+of string keys to scalar values. Entries described as \"cumulative\" are reset\n+when the beanstalkd process starts;\n+they are not stored on disk with the -b flag.\n \n  - \"current-jobs-urgent\" is the number of ready jobs with priority < 1024.\n \n", "test_patch": "", "problem_statement": "protocol.txt: fix typos\nCloses #271", "version": "1.11", "language": "C", "created_at": "2019-07-07T18:28:21Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-446", "repo": "beanstalkd/beanstalkd", "pull_number": 446, "base_commit": "2ea1d016428929ca18d3cdfa37937190213550e4", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -57,6 +57,9 @@ typedef int(FAlloc)(int, int);\n #define URGENT_THRESHOLD 1024\n #define JOB_DATA_SIZE_LIMIT_DEFAULT ((1 << 16) - 1)\n \n+/* Maximum value (uint32) allowed in pri, delay and ttr parameters */\n+#define MAX_UINT32 4294967295\n+\n extern const char version[];\n extern int verbose;\n extern struct Server srv;\n\ndiff --git a/doc/protocol.txt b/doc/protocol.txt\n--- a/doc/protocol.txt\n+++ b/doc/protocol.txt\n@@ -135,13 +135,14 @@ below).\n \n  - <delay> is an integer number of seconds to wait before putting the job in\n    the ready queue. The job will be in the \"delayed\" state during this time.\n+   Maximum delay is 2**32-1.\n \n  - <ttr> -- time to run -- is an integer number of seconds to allow a worker\n    to run this job. This time is counted from the moment a worker reserves\n    this job. If the worker does not delete, release, or bury the job within\n    <ttr> seconds, the job will time out and the server will release the job.\n    The minimum ttr is 1. If the client sends 0, the server will silently\n-   increase the ttr to 1.\n+   increase the ttr to 1. Maximum ttr is 2**32-1.\n \n  - <bytes> is an integer indicating the size of the job body, not including the\n    trailing \"\\r\\n\". This value must be less than max-job-size (default: 2**16).\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -105,7 +105,7 @@ allocate_job(int body_size)\n }\n \n job\n-make_job_with_id(uint pri, int64 delay, int64 ttr,\n+make_job_with_id(uint32 pri, int64 delay, int64 ttr,\n                  int body_size, tube tube, uint64 id)\n {\n     job j;\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -938,30 +938,38 @@ fmt_stats(char *buf, size_t size, void *x)\n             node_info.nodename);\n }\n \n-/* Read a number value from the given buffer and place it in num.\n+/* Read an integer from the given buffer and place it in num.\n+ * Parsed integer should fit into uint32.\n  * Update end to point to the address after the last character consumed.\n  * num and end can be NULL. If they are both NULL, read_num() will do the\n- * conversion and return the status code but not update any values. This is an\n- * easy way to check for errors.\n+ * conversion and return the status code but not update any values.\n+ * This is an easy way to check for errors.\n  * If end is NULL, read_num will also check that the entire input string was\n  * consumed and return an error code otherwise.\n  * Return 0 on success, or nonzero on failure.\n  * If a failure occurs, num and end are not modified. */\n static int\n-read_num(uint *num, const char *buf, char **end)\n+read_num(uint32 *num, const char *buf, char **end)\n {\n-    uint tnum;\n+    uint64 tnum;\n     char *tend;\n \n     errno = 0;\n-    while (buf[0] == ' ') buf++;\n-    if (buf[0] < '0' || '9' < buf[0]) return -1;\n-    tnum = strtoul(buf, &tend, 10);\n-    if (tend == buf) return -1;\n-    if (errno && errno != ERANGE) return -1;\n-    if (!end && tend[0] != '\\0') return -1;\n-\n-    if (num) *num = tnum;\n+    while (buf[0] == ' ')\n+        buf++;\n+    if (buf[0] < '0' || '9' < buf[0])\n+        return -1;\n+    tnum = strtoumax(buf, &tend, 10);\n+    if (tend == buf)\n+        return -1;\n+    if (errno && errno != ERANGE)\n+        return -1;\n+    if (!end && tend[0] != '\\0')\n+        return -1;\n+    if (tnum > MAX_UINT32)\n+        return -1;\n+\n+    if (num) *num = (uint32)tnum;\n     if (end) *end = tend;\n     return 0;\n }\n@@ -973,10 +981,11 @@ static int\n read_duration(int64 *duration, const char *buf, char **end)\n {\n     int r;\n-    uint dur_sec;\n+    uint32 dur_sec;\n \n     r = read_num(&dur_sec, buf, end);\n-    if (r) return r;\n+    if (r)\n+        return r;\n     *duration = ((int64) dur_sec) * 1000000000;\n     return 0;\n }\n@@ -1184,7 +1193,8 @@ dispatch_cmd(Conn *c)\n     job j = 0;\n     byte type;\n     char *size_buf, *delay_buf, *ttr_buf, *pri_buf, *end_buf, *name;\n-    uint pri, body_size;\n+    uint32 pri;\n+    uint body_size;\n     int64 delay, ttr;\n     uint64 id;\n     tube t = NULL;\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -263,6 +263,27 @@ exist(char *path)\n     return r != -1;\n }\n \n+void\n+cttest_unknown_command()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"nont10knowncommand\\r\\n\");\n+    ckresp(fd, \"UNKNOWN_COMMAND\\r\\n\");\n+}\n+\n+void\n+cttest_too_long_commandline()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    int i;\n+    for (i = 0; i < 5; i++)\n+        mustsend(fd, \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\");\n+    mustsend(fd, \"\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+}\n+\n void\n cttest_pause()\n {\n@@ -359,6 +380,48 @@ cttest_negative_delay()\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n }\n \n+/* TODO: add more edge cases tests for delay and ttr */\n+\n+void\n+cttest_garbage_priority()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"put -1kkdj9djjkd9 0 100 1\\r\\n\");\n+    mustsend(fd, \"a\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+}\n+\n+void\n+cttest_negative_priority()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"put -1 0 100 1\\r\\n\");\n+    mustsend(fd, \"a\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+}\n+\n+void\n+cttest_max_priority()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"put 4294967295 0 100 1\\r\\n\");\n+    mustsend(fd, \"a\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+}\n+\n+void\n+cttest_too_big_priority()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"put 4294967296 0 100 1\\r\\n\");\n+    mustsend(fd, \"a\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+}\n+\n void\n cttest_omit_time_left()\n {\n", "test_patch": "", "problem_statement": "set input width of pri, delay and ttr params to uint32\nBefore this fix if the value specified in\r\npri/delay/ttr parameters would equal to 2**32\r\nthen it would be messed up and set to zero because of overflow.\r\nAnd in general, the behaviour was not defined strictly\r\nbecause the uint type can take different width.\r\n\r\nI have fixed the read_num function to parse integer\r\nthat fits into range 0 .. 2**32-1. Internally it parses\r\ninteger into uint64, but it checks if it fits into uint32.\r\nSo it will return success only in this case.\r\n\r\nI have added multiple tests checking that behaviour.\r\n\r\nFixes #230", "version": "1.11", "language": "C", "created_at": "2019-07-07T15:21:46Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-504", "repo": "beanstalkd/beanstalkd", "pull_number": 504, "base_commit": "58d66417c12fbcd5b95dcc5661c4f8c6e6d8a780", "patch": "diff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -14,7 +14,7 @@ static uint tot_conn_ct = 0;\n int verbose = 0;\n \n static void\n-on_watch(Ms *a, tube t, size_t i)\n+on_watch(Ms *a, Tube *t, size_t i)\n {\n     UNUSED_PARAMETER(a);\n     UNUSED_PARAMETER(i);\n@@ -23,7 +23,7 @@ on_watch(Ms *a, tube t, size_t i)\n }\n \n static void\n-on_ignore(Ms *a, tube t, size_t i)\n+on_ignore(Ms *a, Tube *t, size_t i)\n {\n     UNUSED_PARAMETER(a);\n     UNUSED_PARAMETER(i);\n@@ -32,7 +32,7 @@ on_ignore(Ms *a, tube t, size_t i)\n }\n \n Conn *\n-make_conn(int fd, char start_state, tube use, tube watch)\n+make_conn(int fd, char start_state, Tube *use, Tube *watch)\n {\n     Job *j;\n     Conn *c;\n@@ -201,7 +201,7 @@ conn_ready(Conn *c)\n     size_t i;\n \n     for (i = 0; i < c->watch.len; i++) {\n-        if (((tube) c->watch.items[i])->ready.len)\n+        if (((Tube *) c->watch.items[i])->ready.len)\n             return 1;\n     }\n     return 0;\n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -11,7 +11,7 @@ typedef uint64_t      uint64;\n \n typedef struct Ms     Ms;\n typedef struct Job    Job;\n-typedef struct tube   *tube;\n+typedef struct Tube   Tube;\n typedef struct Conn   Conn;\n typedef struct Heap   Heap;\n typedef struct Jobrec Jobrec;\n@@ -202,7 +202,7 @@ struct Job {\n \n     // bookeeping fields; these are in-memory only\n     char pad[6];\n-    tube tube;\n+    Tube *tube;\n     Job *prev, *next;           // linked list of jobs\n     Job *ht_next;               // Next job in a hash table list\n     size_t heap_index;          // where is this job in its current heap\n@@ -216,7 +216,7 @@ struct Job {\n     char body[];                // written separately to the wal\n };\n \n-struct tube {\n+struct Tube {\n     uint refs;\n     char name[MAX_TUBE_NAME_LEN];\n     Heap ready;\n@@ -252,7 +252,7 @@ int   rawfalloc(int fd, int len);\n \n Job *allocate_job(int body_size);\n Job *make_job_with_id(uint pri, int64 delay, int64 ttr,\n-             int body_size, tube tube, uint64 id);\n+                      int body_size, Tube *tube, uint64 id);\n void job_free(Job *j);\n \n /* Lookup a job by job ID */\n@@ -277,15 +277,15 @@ size_t get_all_jobs_used(void);\n \n extern struct Ms tubes;\n \n-tube make_tube(const char *name);\n-void tube_dref(tube t);\n-void tube_iref(tube t);\n-tube tube_find(const char *name);\n-tube tube_find_or_make(const char *name);\n+Tube *make_tube(const char *name);\n+void  tube_dref(Tube *t);\n+void  tube_iref(Tube *t);\n+Tube *tube_find(const char *name);\n+Tube *tube_find_or_make(const char *name);\n #define TUBE_ASSIGN(a,b) (tube_dref(a), (a) = (b), tube_iref(a))\n \n \n-Conn *make_conn(int fd, char start_state, tube use, tube watch);\n+Conn *make_conn(int fd, char start_state, Tube *use, Tube *watch);\n \n int count_cur_conns(void);\n uint count_tot_conns(void);\n@@ -307,7 +307,7 @@ void enqueue_reserved_jobs(Conn *c);\n \n void enter_drain_mode(int sig);\n void h_accept(const int fd, const short which, Server* srv);\n-void prot_remove_tube(tube t);\n+void prot_remove_tube(Tube *t);\n int  prot_replay(Server *s, Job *list);\n \n \n@@ -320,7 +320,7 @@ struct Conn {\n     char   state;\n     char   type;\n     Conn   *next;\n-    tube   use;         // tube currently in use\n+    Tube   *use;        // tube currently in use\n     int64  tickat;      // time at which to do more work; determines pos in heap\n     size_t tickpos;     // position in srv->conns, stale when in_conns=0\n     byte   in_conns;    // 1 if the conn is in srv->conns heap, 0 otherwise\n\ndiff --git a/file.c b/file.c\n--- a/file.c\n+++ b/file.c\n@@ -139,7 +139,7 @@ readrec(File *f, Job *l, int *err)\n     int namelen;\n     Jobrec jr;\n     Job *j;\n-    tube t;\n+    Tube *t;\n     char tubename[MAX_TUBE_NAME_LEN];\n \n     r = read(f->fd, &namelen, sizeof(int));\n@@ -269,7 +269,7 @@ readrec5(File *f, Job *l, int *err)\n     size_t namelen;\n     Jobrec5 jr;\n     Job *j;\n-    tube t;\n+    Tube *t;\n     char tubename[MAX_TUBE_NAME_LEN];\n \n     r = read(f->fd, &namelen, sizeof(namelen));\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -106,7 +106,7 @@ allocate_job(int body_size)\n \n Job *\n make_job_with_id(uint32 pri, int64 delay, int64 ttr,\n-                 int body_size, tube tube, uint64 id)\n+                 int body_size, Tube *tube, uint64 id)\n {\n     Job *j;\n \n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -232,7 +232,7 @@ static char bucket[BUCKET_BUF_SIZE];\n static uint ready_ct = 0;\n static struct stats global_stat = {0, 0, 0, 0, 0, 0, 0};\n \n-static tube default_tube;\n+static Tube *default_tube;\n \n static int drain_mode = 0;\n static int64 started_at;\n@@ -279,7 +279,7 @@ static const char * op_names[] = {\n static Job *remove_buried_job(Job *j);\n \n static int\n-buried_job_p(tube t)\n+buried_job_p(Tube *t)\n {\n     return job_list_any_p(&t->buried);\n }\n@@ -360,7 +360,7 @@ reply_job(Conn *c, Job *j, const char *word)\n Conn *\n remove_waiting_conn(Conn *c)\n {\n-    tube t;\n+    Tube *t;\n     size_t i;\n \n     if (!conn_waiting(c)) return NULL;\n@@ -395,7 +395,7 @@ reserve_job(Conn *c, Job *j)\n static Job *\n next_eligible_job(int64 now)\n {\n-    tube t;\n+    Tube *t;\n     size_t i;\n     Job *j = NULL;\n     Job *candidate;\n@@ -438,7 +438,7 @@ static Job *\n delay_q_peek()\n {\n     size_t i;\n-    tube t;\n+    Tube *t;\n     Job *j = NULL;\n     Job *nj;\n \n@@ -565,7 +565,7 @@ kick_buried_job(Server *s, Job *j)\n static uint\n get_delayed_job_ct()\n {\n-    tube t;\n+    Tube *t;\n     size_t i;\n     uint count = 0;\n \n@@ -603,7 +603,7 @@ kick_delayed_job(Server *s, Job *j)\n \n /* return the number of jobs successfully kicked */\n static uint\n-kick_buried_jobs(Server *s, tube t, uint n)\n+kick_buried_jobs(Server *s, Tube *t, uint n)\n {\n     uint i;\n     for (i = 0; (i < n) && buried_job_p(t); ++i) {\n@@ -614,7 +614,7 @@ kick_buried_jobs(Server *s, tube t, uint n)\n \n /* return the number of jobs successfully kicked */\n static uint\n-kick_delayed_jobs(Server *s, tube t, uint n)\n+kick_delayed_jobs(Server *s, Tube *t, uint n)\n {\n     uint i;\n     for (i = 0; (i < n) && (t->delay.len > 0); ++i) {\n@@ -624,7 +624,7 @@ kick_delayed_jobs(Server *s, tube t, uint n)\n }\n \n static uint\n-kick_jobs(Server *s, tube t, uint n)\n+kick_jobs(Server *s, Tube *t, uint n)\n {\n     if (buried_job_p(t)) return kick_buried_jobs(s, t, n);\n     return kick_delayed_jobs(s, t, n);\n@@ -667,7 +667,7 @@ remove_ready_job(Job *j)\n static void\n enqueue_waiting_conn(Conn *c)\n {\n-    tube t;\n+    Tube *t;\n     size_t i;\n \n     global_stat.waiting_ct++;\n@@ -1077,7 +1077,7 @@ static void\n do_list_tubes(Conn *c, Ms *l)\n {\n     char *buf;\n-    tube t;\n+    Tube *t;\n     size_t i, resp_z;\n \n     /* first, measure how big a buffer we will need */\n@@ -1141,7 +1141,7 @@ fmt_job_stats(char *buf, size_t size, Job *j)\n }\n \n static int\n-fmt_stats_tube(char *buf, size_t size, tube t)\n+fmt_stats_tube(char *buf, size_t size, Tube *t)\n {\n     uint64 time_left;\n \n@@ -1208,7 +1208,7 @@ name_is_ok(const char *name, size_t max)\n }\n \n void\n-prot_remove_tube(tube t)\n+prot_remove_tube(Tube *t)\n {\n     ms_remove(&tubes, t);\n }\n@@ -1226,7 +1226,7 @@ dispatch_cmd(Conn *c)\n     uint32 body_size;\n     int64 delay, ttr;\n     uint64 id;\n-    tube t = NULL;\n+    Tube *t = NULL;\n \n     /* NUL-terminate this string so we can use strtol and friends */\n     c->cmd[c->cmd_len - 2] = '\\0';\n@@ -1905,7 +1905,7 @@ prottick(Server *s)\n {\n     Job *j;\n     int64 now;\n-    tube t;\n+    Tube *t;\n     int64 period = 0x34630B8A000LL; /* 1 hour in nanoseconds */\n     int64 d;\n \n\ndiff --git a/testjobs.c b/testjobs.c\n--- a/testjobs.c\n+++ b/testjobs.c\n@@ -6,7 +6,7 @@\n #include <string.h>\n #include <sys/time.h>\n \n-static tube default_tube;\n+static Tube *default_tube;\n \n void\n cttest_job_creation()\n\ndiff --git a/tube.c b/tube.c\n--- a/tube.c\n+++ b/tube.c\n@@ -5,17 +5,18 @@\n \n struct Ms tubes;\n \n-tube\n+Tube *\n make_tube(const char *name)\n {\n-    tube t;\n+    Tube *t;\n \n-    t = new(struct tube);\n+    t = new(Tube);\n     if (!t) return NULL;\n \n     t->name[MAX_TUBE_NAME_LEN - 1] = '\\0';\n     strncpy(t->name, name, MAX_TUBE_NAME_LEN - 1);\n-    if (t->name[MAX_TUBE_NAME_LEN - 1] != '\\0') twarnx(\"truncating tube name\");\n+    if (t->name[MAX_TUBE_NAME_LEN - 1] != '\\0')\n+        twarnx(\"truncating tube name\");\n \n     t->ready.less = job_pri_less;\n     t->delay.less = job_delay_less;\n@@ -31,7 +32,7 @@ make_tube(const char *name)\n }\n \n static void\n-tube_free(tube t)\n+tube_free(Tube *t)\n {\n     prot_remove_tube(t);\n     free(t->ready.data);\n@@ -41,53 +42,57 @@ tube_free(tube t)\n }\n \n void\n-tube_dref(tube t)\n+tube_dref(Tube *t)\n {\n     if (!t) return;\n-    if (t->refs < 1) return twarnx(\"refs is zero for tube: %s\", t->name);\n+    if (t->refs < 1)\n+        return twarnx(\"refs is zero for tube: %s\", t->name);\n \n     --t->refs;\n-    if (t->refs < 1) tube_free(t);\n+    if (t->refs < 1)\n+        tube_free(t);\n }\n \n void\n-tube_iref(tube t)\n+tube_iref(Tube *t)\n {\n     if (!t) return;\n     ++t->refs;\n }\n \n-static tube\n+static Tube *\n make_and_insert_tube(const char *name)\n {\n     int r;\n-    tube t = NULL;\n+    Tube *t = NULL;\n \n     t = make_tube(name);\n-    if (!t) return NULL;\n+    if (!t)\n+        return NULL;\n \n     /* We want this global tube list to behave like \"weak\" refs, so don't\n      * increment the ref count. */\n     r = ms_append(&tubes, t);\n-    if (!r) return tube_dref(t), (tube) 0;\n+    if (!r)\n+        return tube_dref(t), (Tube *) 0;\n \n     return t;\n }\n \n-tube\n+Tube *\n tube_find(const char *name)\n {\n-    tube t;\n     size_t i;\n \n     for (i = 0; i < tubes.len; i++) {\n-        t = tubes.items[i];\n-        if (strncmp(t->name, name, MAX_TUBE_NAME_LEN) == 0) return t;\n+        Tube *t = tubes.items[i];\n+        if (strncmp(t->name, name, MAX_TUBE_NAME_LEN) == 0)\n+            return t;\n     }\n     return NULL;\n }\n \n-tube\n+Tube *\n tube_find_or_make(const char *name)\n {\n     return tube_find(name) ? : make_and_insert_tube(name);\n", "test_patch": "", "problem_statement": "drop the pointer from the tube typedef\nFixes #458", "version": "1.11", "language": "C", "created_at": "2019-07-27T09:11:51Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-216", "repo": "beanstalkd/beanstalkd", "pull_number": 216, "base_commit": "7518ddca9642f70cf0b01094c7229721e4a0f1a6", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -43,9 +43,9 @@ typedef int(FAlloc)(int, int);\n #define MAX_TUBE_NAME_LEN 201\n \n /* A command can be at most LINE_BUF_SIZE chars, including \"\\r\\n\". This value\n- * MUST be enough to hold the longest possible command or reply line, which is\n- * currently \"USING a{200}\\r\\n\". */\n-#define LINE_BUF_SIZE 208\n+ * MUST be enough to hold the longest possible command (\"pause-tube a{200} 4294967295\\r\\n\")\n+ * or reply line (\"USING a{200}\\r\\n\"). */\n+#define LINE_BUF_SIZE 224\n \n /* CONN_TYPE_* are bit masks */\n #define CONN_TYPE_PRODUCER 1\n\ndiff --git a/doc/protocol.en-US.md b/doc/protocol.en-US.md\n--- a/doc/protocol.en-US.md\n+++ b/doc/protocol.en-US.md\n@@ -590,7 +590,7 @@ pause-tube <tube-name> <delay>\\r\\n\n ##### `pause-tube` options\n \n * `<tube>` is the tube to pause\n-* `<delay>` is an integer number of seconds to wait before reserving any more jobs from the queue\n+* `<delay>` is an integer number of seconds < 2**32 to wait before reserving any more jobs from the queue\n \n ##### `pause-tube` responses\n \n\ndiff --git a/doc/protocol.txt b/doc/protocol.txt\n--- a/doc/protocol.txt\n+++ b/doc/protocol.txt\n@@ -703,7 +703,7 @@ pause-tube <tube-name> <delay>\\r\\n\n \n  - <tube> is the tube to pause\n \n- - <delay> is an integer number of seconds to wait before reserving any more\n+ - <delay> is an integer number of seconds < 2**32 to wait before reserving any more\n    jobs from the queue\n \n There are two possible responses:\n", "test_patch": "", "problem_statement": "Increase LINE_BUF_SIZE to handle longest possible command\nThis fix addresses https://github.com/kr/beanstalkd/issues/211 and https://github.com/kr/beanstalkd/issues/212. \n\nI tried the approach I suggested in the issue of changing prot.c:343 to use `>` instead of `>=`, but trying to use a tube with a name of length 200 continued having issues. Also given the number of other commands having length issues, this approach would not have solved the larger problem.\n\nSo this instead updates LINE_BUF_SIZE to handle the longest possible command and reply lines.\n\nThis may be a preferable approach since both LINE_BUF_SIZE and MAX_TUBE_NAME_LEN follow similar logic in that they both represent the minimum invalid length.\n\nExisting ct tests all pass. Additionally a suite of ~200 integration tests I wrote to test adherence to the beanstalk protocol show no regressions. Those tests can be found here: https://github.com/tdg5/beanstalk_integration_tests. They're written in ruby though, sorry :)", "version": "1.10", "language": "C", "created_at": "2013-11-11T14:21:59Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-283", "repo": "beanstalkd/beanstalkd", "pull_number": 283, "base_commit": "96e875678bb262343a0caa461b8927a2d2260f6f", "patch": "diff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -176,7 +176,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n     \"current-waiting: %u\\n\" \\\n     \"total-connections: %u\\n\" \\\n     \"pid: %ld\\n\" \\\n-    \"version: %s\\n\" \\\n+    \"version: \\\"%s\\\"\\n\" \\\n     \"rusage-utime: %d.%06d\\n\" \\\n     \"rusage-stime: %d.%06d\\n\" \\\n     \"uptime: %u\\n\" \\\n", "test_patch": "", "problem_statement": "Fix version number output in stats\nThe version number was previously being output as a number. In the case of the current version (1.10) this was parsed as 1.1 by several YAML parsers, including Ruby's YAML, JavaScript's js-yaml and Perl 6's YAMLish. In order for the version number to be parsed correctly it needs to be a string since the trailing zeros are significant.\n\nThis change shouldn't affect any existing parsers as the ones that got the correct number are parsing all values as strings anyway.\n\nOf course, since this won't be released until a later version, it won't help. At least not until 1.20 or 2.10.", "version": "1.10", "language": "C", "created_at": "2015-10-20T19:44:52Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-451", "repo": "beanstalkd/beanstalkd", "pull_number": 451, "base_commit": "9b1c610918a747f51d329547040b69b8b67025ed", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -342,7 +342,7 @@ void walinit(Wal*, job list);\n int  walwrite(Wal*, job);\n void walmaint(Wal*);\n int  walresvput(Wal*, job);\n-int  walresvupdate(Wal*, job);\n+int  walresvupdate(Wal*);\n void walgc(Wal*);\n \n \n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -490,7 +490,7 @@ static int\n bury_job(Server *s, job j, char update_store)\n {\n     if (update_store) {\n-        int z = walresvupdate(&s->wal, j);\n+        int z = walresvupdate(&s->wal);\n         if (!z) return 0;\n         j->walresv += z;\n     }\n@@ -545,7 +545,7 @@ kick_buried_job(Server *s, job j)\n     int r;\n     int z;\n \n-    z = walresvupdate(&s->wal, j);\n+    z = walresvupdate(&s->wal);\n     if (!z) return 0;\n     j->walresv += z;\n \n@@ -580,7 +580,7 @@ kick_delayed_job(Server *s, job j)\n     int r;\n     int z;\n \n-    z = walresvupdate(&s->wal, j);\n+    z = walresvupdate(&s->wal);\n     if (!z) return 0;\n     j->walresv += z;\n \n@@ -1381,7 +1381,7 @@ dispatch_cmd(Conn *c)\n         /* We want to update the delay deadline on disk, so reserve space for\n          * that. */\n         if (delay) {\n-            int z = walresvupdate(&c->srv->wal, j);\n+            int z = walresvupdate(&c->srv->wal);\n             if (!z) return reply_serr(c, MSG_OUT_OF_MEMORY);\n             j->walresv += z;\n         }\n@@ -2033,7 +2033,7 @@ prot_replay(Server *s, job list)\n     for (j = list->next ; j != list ; j = nj) {\n         nj = j->next;\n         job_remove(j);\n-        z = walresvupdate(&s->wal, j);\n+        z = walresvupdate(&s->wal);\n         if (!z) {\n             twarnx(\"failed to reserve space\");\n             return 0;\n\ndiff --git a/walg.c b/walg.c\n--- a/walg.c\n+++ b/walg.c\n@@ -388,10 +388,9 @@ walresvput(Wal *w, job j)\n \n // Returns the number of bytes reserved or 0 on error.\n int\n-walresvupdate(Wal *w, job j)\n+walresvupdate(Wal *w)\n {\n     int z = 0;\n-\n     z +=sizeof(int);\n     z +=sizeof(Jobrec);\n     return reserve(w, z);\n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -60,6 +60,8 @@ typedef int(FAlloc)(int, int);\n /* Maximum value (uint32) allowed in pri, delay and ttr parameters */\n #define MAX_UINT32 4294967295\n \n+#define UNUSED_PARAMETER(x) (void)(x)\n+\n extern const char version[];\n extern int verbose;\n extern struct Server srv;\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -1654,8 +1654,9 @@ conn_timeout(Conn *c)\n }\n \n void\n-enter_drain_mode(int sig)\n+enter_drain_mode(int signum)\n {\n+    UNUSED_PARAMETER(signum);\n     drain_mode = 1;\n }\n \n@@ -1918,13 +1919,11 @@ prottick(Server *s)\n void\n h_accept(const int fd, const short which, Server *s)\n {\n-    Conn *c;\n-    int cfd, flags, r;\n-    socklen_t addrlen;\n+    UNUSED_PARAMETER(which);\n     struct sockaddr_in6 addr;\n \n-    addrlen = sizeof addr;\n-    cfd = accept(fd, (struct sockaddr *)&addr, &addrlen);\n+    socklen_t addrlen = sizeof addr;\n+    int cfd = accept(fd, (struct sockaddr *)&addr, &addrlen);\n     if (cfd == -1) {\n         if (errno != EAGAIN && errno != EWOULDBLOCK) twarn(\"accept()\");\n         update_conns();\n@@ -1934,7 +1933,7 @@ h_accept(const int fd, const short which, Server *s)\n         printf(\"accept %d\\n\", cfd);\n     }\n \n-    flags = fcntl(cfd, F_GETFL, 0);\n+    int flags = fcntl(cfd, F_GETFL, 0);\n     if (flags < 0) {\n         twarn(\"getting flags\");\n         close(cfd);\n@@ -1945,7 +1944,7 @@ h_accept(const int fd, const short which, Server *s)\n         return;\n     }\n \n-    r = fcntl(cfd, F_SETFL, flags | O_NONBLOCK);\n+    int r = fcntl(cfd, F_SETFL, flags | O_NONBLOCK);\n     if (r < 0) {\n         twarn(\"setting O_NONBLOCK\");\n         close(cfd);\n@@ -1956,7 +1955,7 @@ h_accept(const int fd, const short which, Server *s)\n         return;\n     }\n \n-    c = make_conn(cfd, STATE_WANTCOMMAND, default_tube, default_tube);\n+    Conn *c = make_conn(cfd, STATE_WANTCOMMAND, default_tube, default_tube);\n     if (!c) {\n         twarnx(\"make_conn() failed\");\n         close(cfd);\n", "test_patch": "", "problem_statement": "remove the j parameter from the walresvupdate function\nThis parameter is not used in the function at all.\r\n\r\nUpdates #443", "version": "1.11", "language": "C", "created_at": "2019-07-08T18:30:43Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-438", "repo": "beanstalkd/beanstalkd", "pull_number": 438, "base_commit": "4da6509fa90538cee7c3bf62eeeb6bbe2c6a028a", "patch": "diff --git a/adm/systemv/beanstalkd.init b/adm/systemv/beanstalkd.init\n--- a/adm/systemv/beanstalkd.init\n+++ b/adm/systemv/beanstalkd.init\n@@ -34,41 +34,39 @@ BEANSTALKD_ADDR=127.0.0.1\n BEANSTALKD_PORT=11300\n BEANSTALKD_USER=beanstalkd\n \n-[ -e /etc/sysconfig/${prog} ] && . /etc/sysconfig/${prog}\n+[ -e /etc/sysconfig/$prog ] && . /etc/sysconfig/$prog\n \n-lockfile=/var/lock/subsys/${prog}\n+lockfile=/var/lock/subsys/$prog\n \n start() {\n \t[ -x $exec ] || exit 5\n \techo -n $\"Starting $prog: \"\n \n-\toptions=\"-l ${BEANSTALKD_ADDR} -p ${BEANSTALKD_PORT} -u ${BEANSTALKD_USER}\"\n+\toptions=\"-l $BEANSTALKD_ADDR -p $BEANSTALKD_PORT -u $BEANSTALKD_USER\"\n \n-\tif [ \"${BEANSTALKD_MAX_JOB_SIZE}\" != \"\"  ]; then\n-\t\toptions=\"${options} -z ${BEANSTALKD_MAX_JOB_SIZE}\"\n-\tfi\n+\t[ -n \"$BEANSTALKD_MAX_JOB_SIZE\" ] && options=\"$options -z $BEANSTALKD_MAX_JOB_SIZE\"\n \n-\tif [ \"${BEANSTALKD_BINLOG_DIR}\" != \"\" ]; then\n-\t\tif [ ! -d \"${BEANSTALKD_BINLOG_DIR}\" ]; then\n-\t\t\techo \"Creating binlog directory (${BEANSTALKD_BINLOG_DIR})\"\n-\t\t\tmkdir -p ${BEANSTALKD_BINLOG_DIR}\n-\t\t\tchown ${BEANSTALKD_USER}:${BEANSTALKD_USER} ${BEANSTALKD_BINLOG_DIR}\n+\tif [ -n \"$BEANSTALKD_BINLOG_DIR\" ]; then\n+\t\tif [ ! -d \"$BEANSTALKD_BINLOG_DIR\" ]; then\n+\t\t\techo \"Creating binlog directory ($BEANSTALKD_BINLOG_DIR)\"\n+\t\t\tmkdir -p $BEANSTALKD_BINLOG_DIR\n+\t\t\tchown $BEANSTALKD_USER:$BEANSTALKD_USER $BEANSTALKD_BINLOG_DIR\n \t\tfi\n \n-\t\toptions=\"${options} -b ${BEANSTALKD_BINLOG_DIR}\"\n+\t\toptions=\"$options -b $BEANSTALKD_BINLOG_DIR\"\n \n-\t\tif [ \"${BEANSTALKD_BINLOG_FSYNC_PERIOD}\" != \"\" ]; then\n-\t\t\toptions=\"${options} -f ${BEANSTALKD_BINLOG_FSYNC_PERIOD}\"\n+\t\tif [ -n \"$BEANSTALKD_BINLOG_FSYNC_PERIOD\" ]; then\n+\t\t\toptions=\"$options -f $BEANSTALKD_BINLOG_FSYNC_PERIOD\"\n \t\telse\n-\t\t\toptions=\"${options} -F\"\n+\t\t\toptions=\"$options -F\"\n \t\tfi\n \n-\t\tif [ \"${BEANSTALKD_BINLOG_SIZE}\" != \"\" ]; then\n-\t\t\toptions=\"${options} -s ${BEANSTALKD_BINLOG_SIZE}\"\n+\t\tif [ -n \"$BEANSTALKD_BINLOG_SIZE\" ]; then\n+\t\t\toptions=\"$options -s $BEANSTALKD_BINLOG_SIZE\"\n \t\tfi\n \tfi\n \n-\tdaemon \"nohup ${exec} $options > /dev/null 2>&1 &\"\n+\tdaemon \"nohup $exec $options > /dev/null 2>&1 &\"\n \tretval=$?\n \techo\n \t[ $retval -eq 0 ] && touch $lockfile\n@@ -136,4 +134,4 @@ case \"$1\" in\n \t\techo $\"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}\"\n \t\texit 2\n esac\n-exit $?\n\\ No newline at end of file\n+exit $?\n", "test_patch": "", "problem_statement": "Cleanup SysV initd script\nUse -n shorthand for non-empty string tests.\r\n\r\nUse if shorthand with && for trivial cases.\r\n\r\nRemove unnecessary curlies.\r\n\r\nSigned-off-by: Philip Prindeville <philipp@redfish-solutions.com>", "version": "1.11", "language": "C", "created_at": "2019-07-04T02:27:46Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-341", "repo": "beanstalkd/beanstalkd", "pull_number": 341, "base_commit": "c17f5030177f689b37ddd6cd2237c96491f6c399", "patch": "diff --git a/linux.c b/linux.c\n--- a/linux.c\n+++ b/linux.c\n@@ -1,4 +1,6 @@\n #define _XOPEN_SOURCE 600\n+#include <unistd.h>\n+#include <sys/types.h>\n #include <stdint.h>\n #include <fcntl.h>\n #include <stdlib.h>\n@@ -19,7 +21,7 @@ static int epfd;\n int\n rawfalloc(int fd, int len)\n {\n-    return posix_fallocate(fd, 0, len);\n+    return ftruncate(fd, len);\n }\n \n \n", "test_patch": "", "problem_statement": "Use ftruncate() as it's much more portable\nEmbedded systems (such as OpenWRT) often have reduced functionality; when operating in such circumstances, using the most widely available API's (or subsets of API's) is key for portability.  ftruncate() is much more ubiquitous than posix_fallocate().", "version": "1.10", "language": "C", "created_at": "2017-02-17T02:28:48Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-445", "repo": "beanstalkd/beanstalkd", "pull_number": 445, "base_commit": "26952446c26e169efedab84b32107aa48f06910f", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -274,9 +274,9 @@ struct Conn {\n     int    pending_timeout;\n     char   halfclosed;\n \n-    char cmd[LINE_BUF_SIZE]; // this string is NOT NUL-terminated\n-    int  cmd_len;\n-    int  cmd_read;\n+    char   cmd[LINE_BUF_SIZE]; // this string is NOT NUL-terminated\n+    size_t cmd_len;\n+    int    cmd_read;\n \n     char *reply;\n     int  reply_len;\n\ndiff --git a/file.c b/file.c\n--- a/file.c\n+++ b/file.c\n@@ -201,7 +201,7 @@ readrec(File *f, job l, int *err)\n     case Buried:\n     case Delayed:\n         if (!j) {\n-            if (jr.body_size > job_data_size_limit) {\n+            if ((size_t)jr.body_size > job_data_size_limit) {\n                 warnpos(f, -r, \"job %\"PRIu64\" is too big (%\"PRId32\" > %zu)\",\n                         jr.id,\n                         jr.body_size,\n@@ -325,7 +325,7 @@ readrec5(File *f, job l, int *err)\n     case Buried:\n     case Delayed:\n         if (!j) {\n-            if (jr.body_size > job_data_size_limit) {\n+            if ((size_t)jr.body_size > job_data_size_limit) {\n                 warnpos(f, -r, \"job %\"PRIu64\" is too big (%\"PRId32\" > %zu)\",\n                         jr.id,\n                         jr.body_size,\n@@ -460,7 +460,7 @@ filewopen(File *f)\n     }\n \n     n = write(fd, &ver, sizeof(int));\n-    if (n < sizeof(int)) {\n+    if (n < 0 || (size_t)n < sizeof(int)) {\n         twarn(\"write %s\", f->path);\n         close(fd);\n         return;\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -452,6 +452,7 @@ delay_q_peek()\n     return j;\n }\n \n+/* Inserts job j in the tube, returns 1 on success, otherwise 0 */\n static int\n enqueue_job(Server *s, job j, int64 delay, char update_store)\n {\n@@ -713,21 +714,23 @@ check_err(Conn *c, const char *s)\n \n /* Scan the given string for the sequence \"\\r\\n\" and return the line length.\n  * Always returns at least 2 if a match is found. Returns 0 if no match. */\n-static int\n+static size_t\n scan_line_end(const char *s, int size)\n {\n     char *match;\n \n     match = memchr(s, '\\r', size - 1);\n-    if (!match) return 0;\n+    if (!match)\n+        return 0;\n \n     /* this is safe because we only scan size - 1 chars above */\n-    if (match[1] == '\\n') return match - s + 2;\n+    if (match[1] == '\\n')\n+        return match - s + 2;\n \n     return 0;\n }\n \n-static int\n+static size_t\n cmd_len(Conn *c)\n {\n     return scan_line_end(c->cmd, c->cmd_read);\n@@ -870,7 +873,7 @@ fmt_stats(char *buf, size_t size, void *x)\n {\n     int whead = 0, wcur = 0;\n     Server *srv;\n-    struct rusage ru = {{0, 0}, {0, 0}};\n+    struct rusage ru;\n \n     srv = x;\n \n@@ -1175,7 +1178,8 @@ prot_remove_tube(tube t)\n static void\n dispatch_cmd(Conn *c)\n {\n-    int r, i, timeout = -1;\n+    int r, timeout = -1;\n+    uint i;\n     uint count;\n     job j = 0;\n     byte type;\n@@ -1645,13 +1649,6 @@ enter_drain_mode(int sig)\n     drain_mode = 1;\n }\n \n-static void\n-do_cmd(Conn *c)\n-{\n-    dispatch_cmd(c);\n-    fill_extra_data(c);\n-}\n-\n static void\n reset_conn(Conn *c)\n {\n@@ -1677,7 +1674,8 @@ conn_data(Conn *c)\n     switch (c->state) {\n     case STATE_WANTCOMMAND:\n         r = read(c->sock.fd, c->cmd + c->cmd_read, LINE_BUF_SIZE - c->cmd_read);\n-        if (r == -1) return check_err(c, \"read()\");\n+        if (r == -1)\n+            return check_err(c, \"read()\");\n         if (r == 0) {\n             c->state = STATE_CLOSE;\n             return;\n@@ -1688,7 +1686,11 @@ conn_data(Conn *c)\n         c->cmd_len = cmd_len(c); /* find the EOL */\n \n         /* yay, complete command line */\n-        if (c->cmd_len) return do_cmd(c);\n+        if (c->cmd_len) {\n+            dispatch_cmd(c);\n+            fill_extra_data(c);\n+            return;\n+        }\n \n         /* c->cmd_read > LINE_BUF_SIZE can't happen */\n \n@@ -1723,7 +1725,8 @@ conn_data(Conn *c)\n         j = c->in_job;\n \n         r = read(c->sock.fd, j->body + c->in_job_read, j->r.body_size -c->in_job_read);\n-        if (r == -1) return check_err(c, \"read()\");\n+        if (r == -1)\n+            return check_err(c, \"read()\");\n         if (r == 0) {\n             c->state = STATE_CLOSE;\n             return;\n@@ -1737,7 +1740,8 @@ conn_data(Conn *c)\n         break;\n     case STATE_SENDWORD:\n         r= write(c->sock.fd, c->reply + c->reply_sent, c->reply_len - c->reply_sent);\n-        if (r == -1) return check_err(c, \"write()\");\n+        if (r == -1)\n+            return check_err(c, \"write()\");\n         if (r == 0) {\n             c->state = STATE_CLOSE;\n             return;\n@@ -1760,7 +1764,8 @@ conn_data(Conn *c)\n         iov[1].iov_len = j->r.body_size - c->out_job_sent;\n \n         r = writev(c->sock.fd, iov, 2);\n-        if (r == -1) return check_err(c, \"writev()\");\n+        if (r == -1)\n+            return check_err(c, \"writev()\");\n         if (r == 0) {\n             c->state = STATE_CLOSE;\n             return;\n@@ -1831,7 +1836,10 @@ h_conn(const int fd, const short which, Conn *c)\n     }\n \n     conn_data(c);\n-    while (cmd_data_ready(c) && (c->cmd_len = cmd_len(c))) do_cmd(c);\n+    while (cmd_data_ready(c) && (c->cmd_len = cmd_len(c))) {\n+        dispatch_cmd(c);\n+        fill_extra_data(c);\n+    }\n     if (c->state == STATE_CLOSE) {\n         protrmdirty(c);\n         connclose(c);\n@@ -1848,10 +1856,8 @@ prothandle(Conn *c, int ev)\n int64\n prottick(Server *s)\n {\n-    int r;\n     job j;\n     int64 now;\n-    int i;\n     tube t;\n     int64 period = 0x34630B8A000LL; /* 1 hour in nanoseconds */\n     int64 d;\n@@ -1864,10 +1870,12 @@ prottick(Server *s)\n             break;\n         }\n         j = delay_q_take();\n-        r = enqueue_job(s, j, 0, 0);\n-        if (r < 1) bury_job(s, j, 0); /* out of memory, so bury it */\n+        int r = enqueue_job(s, j, 0, 0);\n+        if (r < 1)\n+            bury_job(s, j, 0);  /* out of memory */\n     }\n \n+    size_t i;\n     for (i = 0; i < tubes.used; i++) {\n         t = tubes.items[i];\n         d = t->deadline_at - now;\n", "test_patch": "", "problem_statement": "fix types to satisfy -Wextra\nThere is lot of work to be done to satisfy -Wextra.\r\nThis is the first step where I have eliminated all\r\nerrors related to the non-strict type coercion.\r\n\r\nReduced the scope of some variables.\r\n\r\nWhile at it I have eliminated function \"one_cmd\" as making\r\ncode more complex that it has to be.", "version": "1.11", "language": "C", "created_at": "2019-07-07T13:17:06Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-435", "repo": "beanstalkd/beanstalkd", "pull_number": 435, "base_commit": "01ace59f5a6b69133acf9a693e7d36bcbae2aee7", "patch": "diff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -4,6 +4,9 @@ Simple and fast general purpose work queue.\n \n https://beanstalkd.github.io/\n \n+See [doc/protocol.txt](https://github.com/beanstalkd/beanstalkd/blob/master/doc/protocol.txt)\n+for details of the network protocol.\n+\n Please note that this project is released with a Contributor\n Code of Conduct. By participating in this project you agree\n to abide by its terms. See CodeOfConduct.txt for details.\n@@ -25,8 +28,6 @@ also try,\n     $ make install PREFIX=/usr\n \n Requires Linux (2.6.17 or later), Mac OS X, or FreeBSD.\n-See [doc/protocol.txt](https://github.com/beanstalkd/beanstalkd/blob/master/doc/protocol.txt) \n-for details of the network protocol.\n \n Uses ronn to generate the manual.\n See http://github.com/rtomayko/ronn.\n", "test_patch": "", "problem_statement": "make protocol.txt more visible on github\nUpdates #304", "version": "1.11", "language": "C", "created_at": "2019-07-03T20:31:47Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-422", "repo": "beanstalkd/beanstalkd", "pull_number": 422, "base_commit": "2224a8f8b2c3f29c0dcc21d878cc64f8ffdb537f", "patch": "diff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -8,8 +8,6 @@ Please note that this project is released with a Contributor\n Code of Conduct. By participating in this project you agree\n to abide by its terms. See CodeOfConduct.txt for details.\n \n-[![Build Status](https://travis-ci.org/beanstalkd/beanstalkd.svg?branch=master)](https://travis-ci.org/beanstalkd/beanstalkd)\n-\n ## Quick Start\n \n     $ make\n@@ -47,8 +45,16 @@ See http://github.com/rtomayko/ronn.\n Unit tests are in test*.c. See https://github.com/kr/ct for\n information on how to write them.\n \n+## Code Status\n+[![Build Status](https://travis-ci.org/beanstalkd/beanstalkd.svg?branch=master)](https://travis-ci.org/beanstalkd/beanstalkd)\n+[![codecov](https://codecov.io/gh/beanstalkd/beanstalkd/branch/master/graph/badge.svg)](https://codecov.io/gh/beanstalkd/beanstalkd)\n+\n+## License\n+\n+beanstalkd is released under the [MIT License](https://opensource.org/licenses/MIT).\n+\n+Copyright \u00a9 2007 The authors of beanstalkd.\n \n-Copyright \u00a9 2007-2019 the authors of beanstalkd.\n Copyright in contributions to beanstalkd is retained\n by the original copyright holder of each contribution.\n See file LICENSE for terms of use.\n\ndiff --git a/LICENSE b/LICENSE\n--- a/LICENSE\n+++ b/LICENSE\n@@ -1,4 +1,4 @@\n-Copyright (c) 2007-2011 The Beanstalkd Authors.\n+Copyright (c) 2007 The Beanstalkd Authors.\n \n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the \"Software\"), to deal in\n\ndiff --git a/LICENSE b/LICENSE\n--- a/LICENSE\n+++ b/LICENSE\n@@ -1,4 +1,7 @@\n-Copyright (c) 2007 The Beanstalkd Authors.\n+Copyright (c) 2007 The authors of beanstalkd.\n+\n+Copyright in contributions to beanstalkd is retained\n+by the original copyright holder of each contribution.\n \n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the \"Software\"), to deal in\n\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -49,12 +49,3 @@ information on how to write them.\n [![Build Status](https://travis-ci.org/beanstalkd/beanstalkd.svg?branch=master)](https://travis-ci.org/beanstalkd/beanstalkd)\n [![codecov](https://codecov.io/gh/beanstalkd/beanstalkd/branch/master/graph/badge.svg)](https://codecov.io/gh/beanstalkd/beanstalkd)\n \n-## License\n-\n-beanstalkd is released under the [MIT License](https://opensource.org/licenses/MIT).\n-\n-Copyright \u00a9 2007 The authors of beanstalkd.\n-\n-Copyright in contributions to beanstalkd is retained\n-by the original copyright holder of each contribution.\n-See file LICENSE for terms of use.\n", "test_patch": "", "problem_statement": "add coverage badge and move license information\nAdd coverage badge and move license and copyright to the LICENSE file.\r\n\r\nUpdates #396", "version": "1.10", "language": "C", "created_at": "2019-06-28T10:27:43Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-410", "repo": "beanstalkd/beanstalkd", "pull_number": 410, "base_commit": "3a7634614597c00ce22515ec7844920ba30b530e", "patch": "diff --git a/doc/protocol.zh-CN.md b/doc/protocol.zh-CN.md\n--- a/doc/protocol.zh-CN.md\n+++ b/doc/protocol.zh-CN.md\n@@ -332,7 +332,7 @@ data \u4e3aYAML file\u7684\u7edf\u8ba1\u4fe1\u606f\n - `current-jobs-ready` \u6b64tube\u4e2d\u72b6\u6001\u4e3aready\u7684job\u6570\u91cf\n - `current-jobs-reserved` \u6b64tube\u4e2d\u72b6\u6001\u4e3areserved\u7684job\u6570\u91cf\n - `current-jobs-delayed` \u6b64tube\u4e2d\u72b6\u6001\u4e3adelayed\u7684job\u6570\u91cf\n-- `current-jobs-bureid` \u6b64tube\u4e2d\u72b6\u6001\u4e3aburied\u7684job\u6570\u91cf\n+- `current-jobs-buried` \u6b64tube\u4e2d\u72b6\u6001\u4e3aburied\u7684job\u6570\u91cf\n - `total-jobs` \u6b64tube\u4e2d\u521b\u5efa\u7684\u6240\u6709job\u6570\u91cf\n - `current-using` \u4f7f\u7528\u6b64tube\u6253\u5f00\u7684\u8fde\u63a5\u6570\n - `current-wating` \u4f7f\u7528\u6b64tube\u6253\u5f00\u8fde\u63a5\u5e76\u4e14\u7b49\u5f85\u54cd\u5e94\u7684\u8fde\u63a5\u6570\n@@ -360,7 +360,7 @@ data \u4e3aYAML file\u7684\u7edf\u8ba1\u4fe1\u606f\n - `current-jobs-ready` \u72b6\u6001\u4e3aready\u7684job\u6570\u91cf\n - `current-jobs-reserved` \u72b6\u6001\u4e3areserved\u7684job\u6570\u91cf\n - `current-jobs-delayed` \u72b6\u6001\u4e3adelayed\u7684job\u6570\u91cf\n-- `current-jobs-bureid` \u72b6\u6001\u4e3aburied\u7684job\u6570\u91cf\n+- `current-jobs-buried` \u72b6\u6001\u4e3aburied\u7684job\u6570\u91cf\n - `cmd-put` \u603b\u5171\u6267\u884cput\u6307\u4ee4\u7684\u6b21\u6570\n - `cmd-peek` \u603b\u5171\u6267\u884cpeek\u6307\u4ee4\u7684\u6b21\u6570\n - `cmd-peek-ready` \u603b\u5171\u6267\u884cpeek-ready\u6307\u4ee4\u7684\u6b21\u6570\n", "test_patch": "", "problem_statement": "Update protocol.zh-CN.md\ncurrent-jobs-buried", "version": "1.10", "language": "C", "created_at": "2019-04-29T01:59:07Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-414", "repo": "beanstalkd/beanstalkd", "pull_number": 414, "base_commit": "efc3acb7bafea197ec95ba4fc76977cd71a40b83", "patch": "diff --git a/CodeOfConduct.txt b/CodeOfConduct.txt\n--- a/CodeOfConduct.txt\n+++ b/CodeOfConduct.txt\n@@ -0,0 +1,78 @@\n+Contributor Covenant Code of Conduct\n+\n+Our Pledge\n+\n+In the interest of fostering an open and welcoming environment, we as\n+contributors and maintainers pledge to making participation in our project and\n+our community a harassment-free experience for everyone, regardless of age, body\n+size, disability, ethnicity, sex characteristics, gender identity and expression,\n+level of experience, education, socio-economic status, nationality, personal\n+appearance, race, religion, or sexual identity and orientation.\n+\n+Our Standards\n+\n+Examples of behavior that contributes to creating a positive environment\n+include:\n+\n+\n+* Using welcoming and inclusive language\n+* Being respectful of differing viewpoints and experiences\n+* Gracefully accepting constructive criticism\n+* Focusing on what is best for the community\n+* Showing empathy towards other community members\n+\n+\n+Examples of unacceptable behavior by participants include:\n+\n+\n+* The use of sexualized language or imagery and unwelcome sexual attention or\n+advances\n+* Trolling, insulting/derogatory comments, and personal or political attacks\n+* Public or private harassment\n+* Publishing others\u2019 private information, such as a physical or electronic\n+address, without explicit permission\n+* Other conduct which could reasonably be considered inappropriate in a\n+professional setting\n+\n+\n+Our Responsibilities\n+\n+Project maintainers are responsible for clarifying the standards of acceptable\n+behavior and are expected to take appropriate and fair corrective action in\n+response to any instances of unacceptable behavior.\n+\n+Project maintainers have the right and responsibility to remove, edit, or\n+reject comments, commits, code, wiki edits, issues, and other contributions\n+that are not aligned to this Code of Conduct, or to ban temporarily or\n+permanently any contributor for other behaviors that they deem inappropriate,\n+threatening, offensive, or harmful.\n+\n+Scope\n+\n+This Code of Conduct applies within all project spaces, and it also applies when\n+an individual is representing the project or its community in public spaces.\n+Examples of representing a project or community include using an official\n+project e-mail address, posting via an official social media account, or acting\n+as an appointed representative at an online or offline event. Representation of\n+a project may be further defined and clarified by project maintainers.\n+\n+Enforcement\n+\n+Instances of abusive, harassing, or otherwise unacceptable behavior may be\n+reported by contacting the project team at [INSERT EMAIL ADDRESS]. All\n+complaints will be reviewed and investigated and will result in a response that\n+is deemed necessary and appropriate to the circumstances. The project team is\n+obligated to maintain confidentiality with regard to the reporter of an incident.\n+Further details of specific enforcement policies may be posted separately.\n+\n+Project maintainers who do not follow or enforce the Code of Conduct in good\n+faith may face temporary or permanent repercussions as determined by other\n+members of the project\u2019s leadership.\n+\n+Attribution\n+\n+This Code of Conduct is adapted from the Contributor Covenant, version 1.4,\n+available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n+\n+For answers to common questions about this code of conduct, see\n+https://www.contributor-covenant.org/faq\n\ndiff --git a/Contributing b/Contributing\n--- a/Contributing\n+++ b/Contributing\n@@ -4,8 +4,9 @@ keeps beanstalkd a high-quality codebase and running smoothly in\n the demanding, high-volume production environment of the servers\n of many organizations around the world.\n \n-We don't have a lot of rules, but here are some tips to keep in\n-mind that might make your life easier.\n+Please note that this project is released with a Contributor\n+Code of Conduct. By participating in this project you agree\n+to abide by its terms. See CodeOfConduct.txt for details.\n \n General\n \n\ndiff --git a/README b/README\n--- a/README\n+++ b/README\n@@ -1,6 +1,10 @@\n This is beanstalkd, a fast, general-purpose work queue.\n See http://kr.github.io/beanstalkd/ for general info.\n \n+Please note that this project is released with a Contributor\n+Code of Conduct. By participating in this project you agree\n+to abide by its terms. See CodeOfConduct.txt for details.\n+\n \n QUICK START\n \n\ndiff --git a/CodeOfConduct.txt b/CodeOfConduct.txt\n--- a/CodeOfConduct.txt\n+++ b/CodeOfConduct.txt\n@@ -59,7 +59,7 @@ a project may be further defined and clarified by project maintainers.\n Enforcement\n \n Instances of abusive, harassing, or otherwise unacceptable behavior may be\n-reported by contacting the project team at [INSERT EMAIL ADDRESS]. All\n+reported by contacting the project team at beanstalk-team@googlegroups.com. All\n complaints will be reviewed and investigated and will result in a response that\n is deemed necessary and appropriate to the circumstances. The project team is\n obligated to maintain confidentiality with regard to the reporter of an incident.\n", "test_patch": "", "problem_statement": "add a code of conduct\nShould have done this long, long ago.", "version": "1.10", "language": "C", "created_at": "2019-06-21T22:27:40Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-440", "repo": "beanstalkd/beanstalkd", "pull_number": 440, "base_commit": "f41a86c54caf2e7caf57a385fb66052ddf38c8c8", "patch": "diff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -4,6 +4,11 @@ git:\n \n language: c\n \n+addons:\n+    apt:\n+      packages:\n+          - lcov\n+\n compiler:\n     - clang\n     - gcc\n@@ -28,6 +33,26 @@ script:\n           export CFLAGS=\"-O0 -ggdb -fprofile-arcs -ftest-coverage\"\n       fi\n     - make $MAKEJOBS || ( echo \"Build failure. Verbose build follows.\" && make V=1 ; false )\n+    - |\n+      if [ $COVERAGE = \"ON\" ]; then\n+          # Reset all execution counts to zero\n+          lcov \\\n+              --quiet \\\n+              --directory . \\\n+              --base-directory=$(pwd) \\\n+              --compat-libtool \\\n+              --zerocounters\n+\n+         # Capture coverage data\n+         lcov \\\n+             --quiet \\\n+              --directory . \\\n+              --base-directory=$(pwd) \\\n+              --capture \\\n+              --initial \\\n+              --compat-libtool \\\n+              --output-file $(pwd)/lcov.info\n+      fi\n     - make check -j1 VERBOSE=1\n \n jobs:\n@@ -50,7 +75,36 @@ jobs:\n           - make $MAKEJOBS bench\n \n after_success:\n-    - if [ $COVERAGE = \"ON\" ]; then (bash <(curl -s https://codecov.io/bash) || echo \"Codecov did not collect coverage reports\"); fi;\n+    - |\n+      if [ $COVERAGE = \"ON\" ]; then\n+          # Capture coverage data\n+          lcov \\\n+              --quiet \\\n+              --directory . \\\n+              --base-directory=$(pwd) \\\n+              --no-checksum \\\n+              --capture \\\n+              --compat-libtool \\\n+              --output-file $(pwd)/lcov.info\n+\n+          # Remove files matching exclude patterns\n+          lcov \\\n+              --quiet \\\n+              --remove $(pwd)/lcov.info \"ct/*\" \\\n+              --remove $(pwd)/lcov.info \"adm/*\" \\\n+              --remove $(pwd)/lcov.info \"pkg/*\" \\\n+              --remove $(pwd)/lcov.info \"testheap.c\" \\\n+              --remove $(pwd)/lcov.info \"testjobs.c\" \\\n+              --remove $(pwd)/lcov.info \"testserv.c\" \\\n+              --remove $(pwd)/lcov.info \"testutil.c\" \\\n+              --compat-libtool \\\n+              --output-file $(pwd)/lcov.info\n+\n+          # Run codecov\n+          curl -sSl https://codecov.io/bash -o ./codecov\n+          chmod +x ./codecov\n+          ./codecov -f $(pwd)/lcov.info\n+      fi\n \n after_script:\n     - printf \"$TRAVIS_COMMIT_RANGE\\n\"\n", "test_patch": "", "problem_statement": "Improved code coverage report\nRemove files and directories from coverage report matching exclude patterns:\r\n- `ct/*`\r\n- `adm/*`\r\n- `pkg/*`\r\n- `testheap.c`\r\n- `testjobs.c`\r\n- `testserv.c`\r\n- `testutil.c`\r\n\r\nI have no idea why, but ignoring via `codecov.yml` does not work.\r\n\r\nRefs: #424", "version": "1.11", "language": "C", "created_at": "2019-07-05T05:42:00Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-139", "repo": "beanstalkd/beanstalkd", "pull_number": 139, "base_commit": "97bc859826891aea3fdb46d4b381400fc889d434", "patch": "diff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -34,6 +34,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define CMD_RELEASE \"release \"\n #define CMD_BURY \"bury \"\n #define CMD_KICK \"kick \"\n+#define CMD_JOBKICK \"kick-job \"\n #define CMD_TOUCH \"touch \"\n #define CMD_STATS \"stats\"\n #define CMD_JOBSTATS \"stats-job \"\n@@ -59,6 +60,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define CMD_RELEASE_LEN CONSTSTRLEN(CMD_RELEASE)\n #define CMD_BURY_LEN CONSTSTRLEN(CMD_BURY)\n #define CMD_KICK_LEN CONSTSTRLEN(CMD_KICK)\n+#define CMD_JOBKICK_LEN CONSTSTRLEN(CMD_JOBKICK)\n #define CMD_TOUCH_LEN CONSTSTRLEN(CMD_TOUCH)\n #define CMD_STATS_LEN CONSTSTRLEN(CMD_STATS)\n #define CMD_JOBSTATS_LEN CONSTSTRLEN(CMD_JOBSTATS)\n@@ -79,6 +81,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define MSG_DELETED \"DELETED\\r\\n\"\n #define MSG_RELEASED \"RELEASED\\r\\n\"\n #define MSG_BURIED \"BURIED\\r\\n\"\n+#define MSG_KICKED \"KICKED\\r\\n\"\n #define MSG_TOUCHED \"TOUCHED\\r\\n\"\n #define MSG_BURIED_FMT \"BURIED %\"PRIu64\"\\r\\n\"\n #define MSG_INSERTED_FMT \"INSERTED %\"PRIu64\"\\r\\n\"\n@@ -89,6 +92,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define MSG_TOUCHED_LEN CONSTSTRLEN(MSG_TOUCHED)\n #define MSG_RELEASED_LEN CONSTSTRLEN(MSG_RELEASED)\n #define MSG_BURIED_LEN CONSTSTRLEN(MSG_BURIED)\n+#define MSG_KICKED_LEN CONSTSTRLEN(MSG_KICKED)\n #define MSG_NOT_IGNORED_LEN CONSTSTRLEN(MSG_NOT_IGNORED)\n \n #define MSG_OUT_OF_MEMORY \"OUT_OF_MEMORY\\r\\n\"\n@@ -130,7 +134,8 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define OP_TOUCH 21\n #define OP_QUIT 22\n #define OP_PAUSE_TUBE 23\n-#define TOTAL_OPS 24\n+#define OP_JOBKICK 24\n+#define TOTAL_OPS 25\n \n #define STATS_FMT \"---\\n\" \\\n     \"current-jobs-urgent: %u\\n\" \\\n@@ -240,6 +245,7 @@ static const char * op_names[] = {\n     CMD_RELEASE,\n     CMD_BURY,\n     CMD_KICK,\n+    CMD_JOBKICK,\n     CMD_STATS,\n     CMD_JOBSTATS,\n     CMD_PEEK_BURIED,\n@@ -728,6 +734,7 @@ which_cmd(Conn *c)\n     TEST_CMD(c->cmd, CMD_RELEASE, OP_RELEASE);\n     TEST_CMD(c->cmd, CMD_BURY, OP_BURY);\n     TEST_CMD(c->cmd, CMD_KICK, OP_KICK);\n+    TEST_CMD(c->cmd, CMD_JOBKICK, OP_JOBKICK);\n     TEST_CMD(c->cmd, CMD_TOUCH, OP_TOUCH);\n     TEST_CMD(c->cmd, CMD_JOBSTATS, OP_JOBSTATS);\n     TEST_CMD(c->cmd, CMD_STATS_TUBE, OP_STATS_TUBE);\n@@ -1401,6 +1408,22 @@ dispatch_cmd(Conn *c)\n         i = kick_jobs(c->srv, c->use, count);\n \n         return reply_line(c, STATE_SENDWORD, \"KICKED %u\\r\\n\", i);\n+    case OP_JOBKICK:\n+        errno = 0;\n+        id = strtoull(c->cmd + CMD_JOBKICK_LEN, &end_buf, 10);\n+        if (errno) return twarn(\"strtoull\"), reply_msg(c, MSG_BAD_FORMAT);\n+\n+        op_ct[type]++;\n+\n+        j = job_find(id);\n+        if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+\n+        if (kick_buried_job(c->srv, j) || kick_delayed_job(c->srv, j)) {\n+            reply(c, MSG_KICKED, MSG_KICKED_LEN, STATE_SENDWORD);\n+        } else {\n+            return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+        }\n+        break;\n     case OP_TOUCH:\n         errno = 0;\n         id = strtoull(c->cmd + CMD_TOUCH_LEN, &end_buf, 10);\n\ndiff --git a/doc/protocol.txt b/doc/protocol.txt\n--- a/doc/protocol.txt\n+++ b/doc/protocol.txt\n@@ -395,6 +395,22 @@ KICKED <count>\\r\\n\n \n  - <count> is an integer indicating the number of jobs actually kicked.\n \n+The kick-job command is a variant of kick that operates with a single job\n+identified by its job id. If the given job id exists and is in a buried or\n+delayed state, it will be moved to the ready queue of the the same tube where it\n+currently belongs. The syntax is:\n+\n+kick-job <id>\\r\\n\n+\n+ - <id> is the job id to kick.\n+\n+The response is one of:\n+\n+ - \"NOT_FOUND\\r\\n\" if the job does not exist or is not in a kickable state. This\n+   can also happen upon internal errors.\n+\n+ - \"KICKED\\r\\n\" when the operation succeeded.\n+\n The stats-job command gives statistical information about the specified job if\n it exists. Its form is:\n \n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -10,7 +10,6 @@\n #include <sys/types.h>\n #include <sys/socket.h>\n #include <netinet/in.h>\n-#include <ctype.h>\n #include <inttypes.h>\n #include <stdarg.h>\n #include \"dat.h\"\n\ndiff --git a/mk/vers.sh b/mk/vers.sh\n--- a/mk/vers.sh\n+++ b/mk/vers.sh\n@@ -1,6 +1,11 @@\n #!/bin/sh\n \n-git describe | sed s/^v// | tr - + | tr -d '\\n'\n-if ! git diff --quiet HEAD\n-then printf +mod\n+if git describe >/dev/null 2>&1\n+then\n+    git describe | sed s/^v// | tr - + | tr -d '\\n'\n+    if ! git diff --quiet HEAD\n+    then printf +mod\n+    fi\n+else\n+    printf unknown\n fi\n", "test_patch": "", "problem_statement": "New command: kick-job  (take 2)\nAdd a new command to kick a single job, update the protocol documentation, a tiny cleanup and a compilation suggestion.\n\nTrying to fulfill #120", "version": "1.7", "language": "C", "created_at": "2012-09-13T18:27:42Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-421", "repo": "beanstalkd/beanstalkd", "pull_number": 421, "base_commit": "6660aa5f4dd20e6cc3eaac38a0d62a1c4442c71d", "patch": "diff --git a/.gitignore b/.gitignore\n--- a/.gitignore\n+++ b/.gitignore\n@@ -1,3 +1,5 @@\n+*.gcda\n+*.gcno\n *.o\n /vers.c\n /beanstalkd\n\ndiff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -12,10 +12,21 @@ os:\n     - linux\n     - osx\n \n+env:\n+    global:\n+        - MAKEJOBS=\"-j$(getconf _NPROCESSORS_ONLN)\"\n+        - TRAVIS_COMMIT_LOG=`git log --format=fuller -2`\n+\n before_install:\n     - $CC --version\n-    - export MAKEJOBS=\"-j$(getconf _NPROCESSORS_ONLN)\"\n-    - export TRAVIS_COMMIT_LOG=`git log --format=fuller -2`\n+\n+install:\n+    - |\n+      if [[ \"${TRAVIS_OS_NAME}\" == \"linux\" ]]; then\n+          export LDFLAGS=\" -lgcov --coverage\"\n+          export CFLAGS=\"-O0 -ggdb -fprofile-arcs -ftest-coverage\"\n+          export CXXFLAGS=\"-O0 -ggdb -fprofile-arcs -ftest-coverage\"\n+      fi\n \n script:\n     - make $MAKEJOBS || ( echo \"Build failure. Verbose build follows.\" && make V=1 ; false )\n@@ -26,4 +37,7 @@ after_script:\n     - printf \"$TRAVIS_COMMIT_LOG\\n\"\n \n after_success:\n-    - if [[ ! -z \"${CODECOV_TOKEN}\" ]]; then (bash <(curl -s https://codecov.io/bash) || echo \"Codecov did not collect coverage reports\"); fi;\n+    - |\n+      if [ ! -z \"${CODECOV_TOKEN}\" ] && [ \"${TRAVIS_OS_NAME}\" == \"linux\" ]; then\n+          (bash <(curl -s https://codecov.io/bash) || echo \"Codecov did not collect coverage reports\")\n+      fi\n\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -1,10 +1,9 @@\n PREFIX=/usr/local\n BINDIR=$(DESTDIR)$(PREFIX)/bin\n-CFLAGS=-Wall -Werror\\\n-\t-Wformat=2\\\n-\t-g\\\n \n-LDFLAGS=\n+override CFLAGS+=-Wall -Werror -Wformat=2 -g\n+override LDFLAGS?=\n+\n OS=$(shell uname|tr A-Z a-z)\n INSTALL=install\n \n@@ -48,6 +47,8 @@ endif\n \n CLEANFILES=\\\n \tvers.c\\\n+\t*.gcda\\\n+\t*.gcno\\\n \n .PHONY: all\n all: $(TARG)\n\ndiff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -22,10 +22,12 @@ before_install:\n \n install:\n     - |\n+    # Currently works only with gcc on linux\n       if [[ \"${TRAVIS_OS_NAME}\" == \"linux\" ]]; then\n-          export LDFLAGS=\" -lgcov --coverage\"\n-          export CFLAGS=\"-O0 -ggdb -fprofile-arcs -ftest-coverage\"\n-          export CXXFLAGS=\"-O0 -ggdb -fprofile-arcs -ftest-coverage\"\n+          if [[ \"${TRAVIS_COMPILER} == \"gcc\" ]]; then\n+              export LDFLAGS=\" -lgcov --coverage\"\n+              export CFLAGS=\"-O0 -ggdb -fprofile-arcs -ftest-coverage\"\n+          fi\n       fi\n \n script:\n@@ -38,6 +40,14 @@ after_script:\n \n after_success:\n     - |\n-      if [ ! -z \"${CODECOV_TOKEN}\" ] && [ \"${TRAVIS_OS_NAME}\" == \"linux\" ]; then\n-          (bash <(curl -s https://codecov.io/bash) || echo \"Codecov did not collect coverage reports\")\n+      if [[ \"${TRAVIS_OS_NAME}\" == \"linux\" ]]; then\n+          if [[ \"${TRAVIS_COMPILER} == \"gcc\" ]]; then\n+              curl -sSl https://codecov.io/bash -o \"./codecov\"\n+              chmod +x codecov\n+              ./codecov\n+          else\n+              echo \"Skip collecting coverage reports for clang\"\n+          fi\n+      else\n+          echo \"Skip coverage reports for OSX\"\n       fi\n\ndiff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -16,38 +16,23 @@ env:\n     global:\n         - MAKEJOBS=\"-j$(getconf _NPROCESSORS_ONLN)\"\n         - TRAVIS_COMMIT_LOG=`git log --format=fuller -2`\n+        - COVERAGE=OFF # Currently works only with gcc on linux\n \n-before_install:\n-    - $CC --version\n+before_script:\n+    - if [ \"${TRAVIS_OS_NAME}-${TRAVIS_COMPILER}\" = \"linux-gcc\" ]; then export COVERAGE=\"ON\"; fi\n \n-install:\n+script:\n     - |\n-    # Currently works only with gcc on linux\n-      if [[ \"${TRAVIS_OS_NAME}\" == \"linux\" ]]; then\n-          if [[ \"${TRAVIS_COMPILER} == \"gcc\" ]]; then\n-              export LDFLAGS=\" -lgcov --coverage\"\n-              export CFLAGS=\"-O0 -ggdb -fprofile-arcs -ftest-coverage\"\n-          fi\n+      if [ $COVERAGE = \"ON\" ]; then\n+          export LDFLAGS=\" -lgcov --coverage\"\n+          export CFLAGS=\"-O0 -ggdb -fprofile-arcs -ftest-coverage\"\n       fi\n-\n-script:\n     - make $MAKEJOBS || ( echo \"Build failure. Verbose build follows.\" && make V=1 ; false )\n     - make check $MAKEJOBS VERBOSE=1\n \n+after_success:\n+    - if [ $COVERAGE = \"ON\" ]; then (bash <(curl -s https://codecov.io/bash) || echo \"Codecov did not collect coverage reports\"); fi;\n+\n after_script:\n     - printf \"$TRAVIS_COMMIT_RANGE\\n\"\n     - printf \"$TRAVIS_COMMIT_LOG\\n\"\n-\n-after_success:\n-    - |\n-      if [[ \"${TRAVIS_OS_NAME}\" == \"linux\" ]]; then\n-          if [[ \"${TRAVIS_COMPILER} == \"gcc\" ]]; then\n-              curl -sSl https://codecov.io/bash -o \"./codecov\"\n-              chmod +x codecov\n-              ./codecov\n-          else\n-              echo \"Skip collecting coverage reports for clang\"\n-          fi\n-      else\n-          echo \"Skip coverage reports for OSX\"\n-      fi\n", "test_patch": "", "problem_statement": "Enable code coverage on Travis CI\nAdded code coverage instrumentation for Travis CI using gcov (GCC) on Linux, with reporting via Codecov. Coverage is currently 32.71%. Enabled only for Linux due to unresolved macOS issues: `ld: library not found for -lgcov` when linking with Clang, and `lcov` unavailable by default (would require `brew install lcov`). On Linux, Clang also fails\u2014gcov reports version mismatches ('402*' vs '408*') and runs out of memory during analysis (e.g., attempting to allocate ~14GB), likely due to incompatible gcno formats. Thus, coverage is restricted to GCC on Linux. This provides visibility into test coverage, aiding code quality and maintenance. macOS support remains pending. Closes: #420, #396.", "version": "1.10", "language": "C", "created_at": "2019-06-27T21:28:33Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-468", "repo": "beanstalkd/beanstalkd", "pull_number": 468, "base_commit": "cc7484e39c596758831bafaf701b1118e8043b2c", "patch": "diff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -701,8 +701,8 @@ cttest_reserve_ttr_deadline_soon()\n     ckrespsub(prod, \"OK \");\n     ckrespsub(prod, \"\\nstate: reserved\\n\");\n \n-    // After 0.5s the job should time out and be ready again.\n-    usleep(500000);\n+    // After 0.6s the job should time out and be ready again.\n+    usleep(600000);\n     mustsend(prod, \"stats-job 1\\r\\n\");\n     ckrespsub(prod, \"OK \");\n     ckrespsub(prod, \"\\nstate: ready\\n\");\n", "test_patch": "", "problem_statement": "fix flaky deadline-soon test\nTest should spend more time than ttr to get job released back into the queue.", "version": "1.11", "language": "C", "created_at": "2019-07-15T08:53:23Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-340", "repo": "beanstalkd/beanstalkd", "pull_number": 340, "base_commit": "5c01de1acdc4129bbfc74e875dd67fdd09370436", "patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -1,11 +1,13 @@\n-PREFIX=/usr/local\n+PREFIX?=/usr/local\n BINDIR=$(DESTDIR)$(PREFIX)/bin\n \n override CFLAGS+=-Wall -Werror -Wformat=2 -g\n override LDFLAGS?=\n \n-OS=$(shell uname|tr A-Z a-z)\n-INSTALL=install\n+LDLIBS?=\n+\n+OS?=$(shell uname | tr 'A-Z' 'a-z')\n+INSTALL?=install\n \n VERS=$(shell ./vers.sh)\n TARG=beanstalkd\n@@ -39,16 +41,12 @@ HFILES=\\\n \tsd-daemon.h\\\n \n ifeq ($(OS),linux)\n-\n-LDLIBS=\\\n-\t-lrt\\\n-\n+   LDLIBS+=-lrt\n endif\n \n CLEANFILES=\\\n \tvers.c\\\n-\t*.gcda\\\n-\t*.gcno\\\n+\t$(wildcard *.gcda *.gcno)\n \n .PHONY: all\n all: $(TARG)\n@@ -63,13 +61,15 @@ $(BINDIR)/%: %\n \t$(INSTALL) -d $(dir $@)\n \t$(INSTALL) $< $@\n \n-CLEANFILES:=$(CLEANFILES) $(TARG)\n+CLEANFILES+=$(TARG)\n \n $(OFILES) $(MOFILE): $(HFILES)\n \n+CLEANFILES+=$(wildcard *.o)\n+\n .PHONY: clean\n clean:\n-\trm -f *.o $(CLEANFILES)\n+\trm -f $(CLEANFILES)\n \n .PHONY: check\n check: ct/_ctcheck\n@@ -89,7 +89,7 @@ ct/ct.o ct/_ctcheck.o: ct/ct.h ct/internal.h\n \n $(TOFILES): $(HFILES) ct/ct.h\n \n-CLEANFILES:=$(CLEANFILES) ct/_* ct/*.o\n+CLEANFILES+=$(wildcard ct/_* ct/*.o)\n \n ifneq ($(shell ./verc.sh),$(shell cat vers.c 2>/dev/null))\n .PHONY: vers.c\n", "test_patch": "", "problem_statement": "Have a more cross-compilation friendly Makefile\nIn the OpenWRT, builds are often done under one system (like x86\r\nUbuntu) for an ARM image of OpenWRT.  CFLAGS, GCC, LDFLAGS, LD,\r\nDESTDIR, PREFIX, etc. all need to be supplied for the target\r\nsystem.\r\n\r\nAddresses issue #339.", "version": "1.11", "language": "C", "created_at": "2017-02-17T02:15:19Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-459", "repo": "beanstalkd/beanstalkd", "pull_number": 459, "base_commit": "1823981b1d4b22ea787081e17e225031e3b15372", "patch": "diff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -69,6 +69,15 @@ jobs:\n       script:\n           - make $MAKEJOBS\n           - make $MAKEJOBS bench\n+    - stage: Benchmark\n+      os: linux\n+      compiler: gcc\n+      before_script:\n+          - export COVERAGE=OFF\n+          - export CFLAGS=\"-O3\"\n+      script:\n+          - make $MAKEJOBS\n+          - make $MAKEJOBS bench\n     - stage: Benchmark\n       os: osx\n       compiler: clang\n\ndiff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -72,9 +72,10 @@ jobs:\n     - stage: Benchmark\n       os: linux\n       compiler: gcc\n+      env:\n+          - CFLAGS=\"-O3\"\n       before_script:\n           - export COVERAGE=OFF\n-          - export CFLAGS=\"-O3\"\n       script:\n           - make $MAKEJOBS\n           - make $MAKEJOBS bench\n\ndiff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -73,7 +73,7 @@ jobs:\n       os: linux\n       compiler: gcc\n       env:\n-          - CFLAGS=\"-O3\"\n+          - CFLAGS=\"-march=native -mtune=native -O3\"\n       before_script:\n           - export COVERAGE=OFF\n       script:\n\ndiff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -79,6 +79,16 @@ jobs:\n       script:\n           - make $MAKEJOBS\n           - make $MAKEJOBS bench\n+    - stage: Benchmark\n+      os: osx\n+      compiler: clang\n+      env:\n+          - CFLAGS=\"-march=native -mtune=native -O3\"\n+      before_script:\n+          - export COVERAGE=OFF\n+      script:\n+          - make $MAKEJOBS\n+          - make $MAKEJOBS bench\n     - stage: Benchmark\n       os: osx\n       compiler: clang\n", "test_patch": "", "problem_statement": "Use optimization flags on benchmark\nCloses: https://github.com/beanstalkd/beanstalkd/issues/423\n\nAdds -march=native, -mtune=native, and -O3 to CFLAGS for benchmark compilation to enable architecture-specific optimizations and higher optimization levels, yielding more realistic performance measurements. Results show significant speedups in compute-intensive operations:\n\ngcc 4.8.4 (Ubuntu):\n- ctbench_heap_insert: 750 \u2192 209 ns/op\n- ctbench_heap_remove: 1317 \u2192 624 ns/op\n- ctbench_make_job: 256 \u2192 203 ns/op\n\nClang 9.1.0 (Apple):\n- ctbench_heap_insert: 640 \u2192 226 ns/op\n- ctbench_heap_remove: 1146 \u2192 459 ns/op\n- ctbench_make_job: 392 \u2192 307 ns/op\n- Throughput improved in put/delete tests (e.g., 64k: 122.47 \u2192 125.10 MB/s)\n\nNon-I/O benchmarks benefit significantly; I/O-bound tests show minor gains. Ensures benchmarks reflect optimized real-world performance, aiding accurate evaluation and comparison.", "version": "1.11", "language": "C", "created_at": "2019-07-12T09:22:49Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-428", "repo": "beanstalkd/beanstalkd", "pull_number": 428, "base_commit": "de8e42e6a1b092a6dc1c764c8b8cba9fb29f8f05", "patch": "diff --git a/pkg/dist.sh b/pkg/dist.sh\n--- a/pkg/dist.sh\n+++ b/pkg/dist.sh\n@@ -27,7 +27,7 @@ test -n \"$prev\" || die no prev ver\n test -f News || die no News\n \n export GIT_INDEX_FILE\n-GIT_INDEX_FILE=`mktemp -t beanstalkd-dist-index`\n+GIT_INDEX_FILE=`mktemp -t beanstalkd-dist-index-XXX`\n trap clean EXIT\n \n git read-tree dev$ver\n", "test_patch": "", "problem_statement": "fix mktemp argument to work on ubuntu 18.04\nSigned-off-by: Thomas Parrott <tomp@tomp.uk>", "version": "1.11", "language": "C", "created_at": "2019-06-29T13:52:34Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-461", "repo": "beanstalkd/beanstalkd", "pull_number": 461, "base_commit": "59fd062c654e4df87733ad48604ad01d3583ca21", "patch": "diff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -673,6 +673,68 @@ cttest_reserve_with_timeout_2conns()\n     ckresp(fd0, \"TIMED_OUT\\r\\n\");\n }\n \n+void\n+cttest_reserve_ttr_deadline_soon()\n+{\n+    port = SERVER();\n+    int prod = mustdiallocal(port);\n+\n+    mustsend(prod, \"put 0 0 1 1\\r\\n\");\n+    mustsend(prod, \"a\\r\\n\");\n+    ckresp(prod, \"INSERTED 1\\r\\n\");\n+\n+    mustsend(prod, \"reserve-with-timeout 1\\r\\n\");\n+    ckresp(prod, \"RESERVED 1 1\\r\\n\");\n+    ckresp(prod, \"a\\r\\n\");\n+\n+    // After 0.5s the job should be still reserved.\n+    usleep(500000);\n+    mustsend(prod, \"stats-job 1\\r\\n\");\n+    ckrespsub(prod, \"OK \");\n+    ckrespsub(prod, \"\\nstate: reserved\\n\");\n+\n+    mustsend(prod, \"reserve-with-timeout 1\\r\\n\");\n+    ckresp(prod, \"DEADLINE_SOON\\r\\n\");\n+\n+    // Job should be reserved; last \"reserve\" took less than 1s.\n+    mustsend(prod, \"stats-job 1\\r\\n\");\n+    ckrespsub(prod, \"OK \");\n+    ckrespsub(prod, \"\\nstate: reserved\\n\");\n+\n+    // After 0.5s the job should time out and be ready again.\n+    usleep(500000);\n+    mustsend(prod, \"stats-job 1\\r\\n\");\n+    ckrespsub(prod, \"OK \");\n+    ckrespsub(prod, \"\\nstate: ready\\n\");\n+}\n+\n+void\n+cttest_close_frees_job()\n+{\n+    port = SERVER();\n+    int cons = mustdiallocal(port);\n+    int prod = mustdiallocal(port);\n+    mustsend(cons, \"reserve-with-timeout 1\\r\\n\");\n+\n+    mustsend(prod, \"put 0 0 100 1\\r\\n\");\n+    mustsend(prod, \"a\\r\\n\");\n+    ckresp(prod, \"INSERTED 1\\r\\n\");\n+\n+    ckresp(cons, \"RESERVED 1 1\\r\\n\");\n+    ckresp(cons, \"a\\r\\n\");\n+\n+    mustsend(prod, \"stats-job 1\\r\\n\");\n+    ckrespsub(prod, \"OK \");\n+    ckrespsub(prod, \"\\nstate: reserved\\n\");\n+\n+    // Closed consumer connection should make the job ready again.\n+    close(cons);\n+\n+    mustsend(prod, \"stats-job 1\\r\\n\");\n+    ckrespsub(prod, \"OK \");\n+    ckrespsub(prod, \"\\nstate: ready\\n\");\n+}\n+\n void\n cttest_unpause_tube()\n {\n", "test_patch": "", "problem_statement": "test the \"deadline_soon\" and the connclose function\nUpdates #424", "version": "1.11", "language": "C", "created_at": "2019-07-12T13:40:39Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-513", "repo": "beanstalkd/beanstalkd", "pull_number": 513, "base_commit": "c6157f701ca83ed5d5194a53ec8b72c99aa503a9", "patch": "diff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -38,12 +38,12 @@ make_conn(int fd, char start_state, Tube *use, Tube *watch)\n     Conn *c;\n \n     c = new(Conn);\n-    if (!c) return twarnerr(\"OOM\"), NULL;\n+    if (!c) return twarn(\"OOM\"), NULL;\n \n     ms_init(&c->watch, (ms_event_fn) on_watch, (ms_event_fn) on_ignore);\n     if (!ms_append(&c->watch, watch)) {\n         free(c);\n-        return twarnerr(\"OOM\"), NULL;\n+        return twarn(\"OOM\"), NULL;\n     }\n \n     TUBE_ASSIGN(c->use, use);\n\ndiff --git a/darwin.c b/darwin.c\n--- a/darwin.c\n+++ b/darwin.c\n@@ -41,7 +41,7 @@ sockinit(void)\n {\n     kq = kqueue();\n     if (kq == -1) {\n-        twarnerr(\"kqueue\");\n+        twarn(\"kqueue\");\n         return -1;\n     }\n     return 0;\n@@ -100,7 +100,7 @@ socknext(Socket **s, int64 timeout)\n     ts.tv_nsec = timeout % 1000000000;\n     r = kevent(kq, NULL, 0, &ev, 1, &ts);\n     if (r == -1 && errno != EINTR) {\n-        twarnerr(\"kevent\");\n+        twarn(\"kevent\");\n         return -1;\n     }\n \n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -231,19 +231,13 @@ struct Tube {\n };\n \n \n-#define twarnerr(fmt, args...) \\\n-    warnerr(\"%s:%d in %s: \" fmt, __FILE__, __LINE__, __func__, ##args)\n-#define twarn(fmt, args...) \\\n-    warn(\"%s:%d in %s: \" fmt, __FILE__, __LINE__, __func__, ##args)\n+#define twarn(fmt, args...) warn(\"%s:%d in %s: \" fmt, \\\n+                                 __FILE__, __LINE__, __func__, ##args)\n+#define twarnx(fmt, args...) warnx(\"%s:%d in %s: \" fmt, \\\n+                                   __FILE__, __LINE__, __func__, ##args)\n \n-// warnerr prints fmt and the error message based on errno into stderr:\n-// \"progname: fmt: error message\"\n-void warnerr(const char *fmt, ...) __attribute__((format(printf, 1, 2)));\n-\n-// warn prints fmt into stderr:\n-// \"progname: fmt\"\n void warn(const char *fmt, ...) __attribute__((format(printf, 1, 2)));\n-\n+void warnx(const char *fmt, ...) __attribute__((format(printf, 1, 2)));\n char* fmtalloc(char *fmt, ...) __attribute__((format(printf, 1, 2)));\n void* zalloc(int n);\n #define new(T) zalloc(sizeof(T))\n@@ -254,8 +248,7 @@ extern const char *progname;\n int64 nanoseconds(void);\n int   rawfalloc(int fd, int len);\n \n-#define make_job(pri,delay,ttr,body_size,tube) \\\n-    make_job_with_id(pri,delay,ttr,body_size,tube,0)\n+#define make_job(pri,delay,ttr,body_size,tube) make_job_with_id(pri,delay,ttr,body_size,tube,0)\n \n Job *allocate_job(int body_size);\n Job *make_job_with_id(uint pri, int64 delay, int64 ttr,\n\ndiff --git a/file.c b/file.c\n--- a/file.c\n+++ b/file.c\n@@ -124,7 +124,7 @@ fileread(File *f, Job *list)\n         return err;\n     }\n \n-    warn(\"%s: unknown version: %d\", f->path, v);\n+    warnx(\"%s: unknown version: %d\", f->path, v);\n     return 1;\n }\n \n@@ -144,7 +144,7 @@ readrec(File *f, Job *l, int *err)\n \n     r = read(f->fd, &namelen, sizeof(int));\n     if (r == -1) {\n-        twarnerr(\"read\");\n+        twarn(\"read\");\n         warnpos(f, 0, \"error\");\n         *err = 1;\n         return 0;\n@@ -274,7 +274,7 @@ readrec5(File *f, Job *l, int *err)\n \n     r = read(f->fd, &namelen, sizeof(namelen));\n     if (r == -1) {\n-        twarnerr(\"read\");\n+        twarn(\"read\");\n         warnpos(f, 0, \"error\");\n         *err = 1;\n         return 0;\n@@ -403,7 +403,7 @@ readfull(File *f, void *c, int n, int *err, char *desc)\n \n     r = read(f->fd, c, n);\n     if (r == -1) {\n-        twarnerr(\"read\");\n+        twarn(\"read\");\n         warnpos(f, 0, \"error reading %s\", desc);\n         *err = 1;\n         return 0;\n@@ -443,25 +443,25 @@ filewopen(File *f)\n \n     fd = open(f->path, O_WRONLY|O_CREAT, 0400);\n     if (fd < 0) {\n-        twarnerr(\"open %s\", f->path);\n+        twarn(\"open %s\", f->path);\n         return;\n     }\n \n     r = falloc(fd, f->w->filesize);\n     if (r) {\n         close(fd);\n         errno = r;\n-        twarnerr(\"falloc %s\", f->path);\n+        twarn(\"falloc %s\", f->path);\n         r = unlink(f->path);\n         if (r) {\n-            twarnerr(\"unlink %s\", f->path);\n+            twarn(\"unlink %s\", f->path);\n         }\n         return;\n     }\n \n     n = write(fd, &ver, sizeof(int));\n     if (n < 0 || (size_t)n < sizeof(int)) {\n-        twarnerr(\"write %s\", f->path);\n+        twarn(\"write %s\", f->path);\n         close(fd);\n         return;\n     }\n@@ -481,7 +481,7 @@ filewrite(File *f, Job *j, void *buf, int len)\n \n     r = write(f->fd, buf, len);\n     if (r != len) {\n-        twarnerr(\"write\");\n+        twarn(\"write\");\n         return 0;\n     }\n \n@@ -535,7 +535,7 @@ filewclose(File *f)\n     if (f->free) {\n         errno = 0;\n         if (ftruncate(f->fd, f->w->filesize - f->free) != 0) {\n-            twarnerr(\"ftruncate\");\n+            twarn(\"ftruncate\");\n         }\n     }\n     close(f->fd);\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -54,7 +54,7 @@ rehash(int is_upscaling)\n     all_jobs_cap = primes[cur_prime];\n     all_jobs = calloc(all_jobs_cap, sizeof(Job *));\n     if (!all_jobs) {\n-        twarn(\"Failed to allocate %zu new hash buckets\", all_jobs_cap);\n+        twarnx(\"Failed to allocate %zu new hash buckets\", all_jobs_cap);\n         hash_table_was_oom = 1;\n         cur_prime = old_prime;\n         all_jobs = old;\n@@ -96,7 +96,7 @@ allocate_job(int body_size)\n \n     j = malloc(sizeof(Job) + body_size);\n     if (!j) {\n-        twarn(\"OOM\");\n+        twarnx(\"OOM\");\n         return (Job *) 0;\n     }\n \n@@ -115,7 +115,7 @@ make_job_with_id(uint32 pri, int64 delay, int64 ttr,\n     Job *j;\n \n     j = allocate_job(body_size);\n-    if (!j) return twarn(\"OOM\"), (Job *) 0;\n+    if (!j) return twarnx(\"OOM\"), (Job *) 0;\n \n     if (id) {\n         j->r.id = id;\n@@ -195,7 +195,7 @@ job_copy(Job *j)\n     if (!j) return NULL;\n \n     n = malloc(sizeof(Job) + j->r.body_size);\n-    if (!n) return twarn(\"OOM\"), (Job *) 0;\n+    if (!n) return twarnx(\"OOM\"), (Job *) 0;\n \n     memcpy(n, j, sizeof(Job) + j->r.body_size);\n     n->next = n->prev = n; /* not in a linked list */\n\ndiff --git a/linux.c b/linux.c\n--- a/linux.c\n+++ b/linux.c\n@@ -31,7 +31,7 @@ sockinit(void)\n {\n     epfd = epoll_create(1);\n     if (epfd == -1) {\n-        twarnerr(\"epoll_create\");\n+        twarn(\"epoll_create\");\n         return -1;\n     }\n     return 0;\n@@ -78,7 +78,7 @@ socknext(Socket **s, int64 timeout)\n \n     r = epoll_wait(epfd, &ev, 1, (int)(timeout/1000000));\n     if (r == -1 && errno != EINTR) {\n-        twarnerr(\"epoll_wait\");\n+        twarn(\"epoll_wait\");\n         exit(1);\n     }\n \n\ndiff --git a/main.c b/main.c\n--- a/main.c\n+++ b/main.c\n@@ -15,23 +15,23 @@ su(const char *user)\n     errno = 0;\n     struct passwd *pwent = getpwnam(user);\n     if (errno) {\n-        twarnerr(\"getpwnam(\\\"%s\\\")\", user);\n+        twarn(\"getpwnam(\\\"%s\\\")\", user);\n         exit(32);\n     }\n     if (!pwent) {\n-        twarn(\"getpwnam(\\\"%s\\\"): no such user\", user);\n+        twarnx(\"getpwnam(\\\"%s\\\"): no such user\", user);\n         exit(33);\n     }\n \n     int r = setgid(pwent->pw_gid);\n     if (r == -1) {\n-        twarnerr(\"setgid(%d \\\"%s\\\")\", pwent->pw_gid, user);\n+        twarn(\"setgid(%d \\\"%s\\\")\", pwent->pw_gid, user);\n         exit(34);\n     }\n \n     r = setuid(pwent->pw_uid);\n     if (r == -1) {\n-        twarnerr(\"setuid(%d \\\"%s\\\")\", pwent->pw_uid, user);\n+        twarn(\"setuid(%d \\\"%s\\\")\", pwent->pw_uid, user);\n         exit(34);\n     }\n }\n@@ -45,20 +45,20 @@ set_sig_handlers()\n     sa.sa_flags = 0;\n     int r = sigemptyset(&sa.sa_mask);\n     if (r == -1) {\n-        twarnerr(\"sigemptyset()\");\n+        twarn(\"sigemptyset()\");\n         exit(111);\n     }\n \n     r = sigaction(SIGPIPE, &sa, 0);\n     if (r == -1) {\n-        twarnerr(\"sigaction(SIGPIPE)\");\n+        twarn(\"sigaction(SIGPIPE)\");\n         exit(111);\n     }\n \n     sa.sa_handler = enter_drain_mode;\n     r = sigaction(SIGUSR1, &sa, 0);\n     if (r == -1) {\n-        twarnerr(\"sigaction(SIGUSR1)\");\n+        twarn(\"sigaction(SIGUSR1)\");\n         exit(111);\n     }\n }\n@@ -78,7 +78,7 @@ main(int argc, char **argv)\n \n     int r = make_server_socket(srv.addr, srv.port);\n     if (r == -1) {\n-        twarn(\"make_server_socket()\");\n+        twarnx(\"make_server_socket()\");\n         exit(111);\n     }\n \n@@ -95,7 +95,7 @@ main(int argc, char **argv)\n         // to use the wal directory at a time. So acquire a lock\n         // now and never release it.\n         if (!waldirlock(&srv.wal)) {\n-            twarn(\"failed to lock wal dir %s\", srv.wal.dir);\n+            twarnx(\"failed to lock wal dir %s\", srv.wal.dir);\n             exit(10);\n         }\n \n@@ -104,7 +104,7 @@ main(int argc, char **argv)\n         walinit(&srv.wal, &list);\n         r = prot_replay(&srv, &list);\n         if (!r) {\n-            twarn(\"failed to replay log\");\n+            twarnx(\"failed to replay log\");\n             exit(1);\n         }\n     }\n\ndiff --git a/net.c b/net.c\n--- a/net.c\n+++ b/net.c\n@@ -22,22 +22,22 @@ make_server_socket(char *host, char *port)\n      * return. */\n     r = sd_listen_fds(1);\n     if (r < 0) {\n-        return twarnerr(\"sd_listen_fds\"), -1;\n+        return twarn(\"sd_listen_fds\"), -1;\n     }\n     if (r > 0) {\n         if (r > 1) {\n-            twarn(\"inherited more than one listen socket;\"\n+            twarnx(\"inherited more than one listen socket;\"\n                    \" ignoring all but the first\");\n         }\n         fd = SD_LISTEN_FDS_START;\n         r = sd_is_socket_inet(fd, 0, SOCK_STREAM, 1, 0);\n         if (r < 0) {\n             errno = -r;\n-            twarnerr(\"sd_is_socket_inet\");\n+            twarn(\"sd_is_socket_inet\");\n             return -1;\n         }\n         if (!r) {\n-            twarn(\"inherited fd is not a TCP listen socket\");\n+            twarnx(\"inherited fd is not a TCP listen socket\");\n             return -1;\n         }\n         return fd;\n@@ -49,60 +49,60 @@ make_server_socket(char *host, char *port)\n     hints.ai_flags = AI_PASSIVE;\n     r = getaddrinfo(host, port, &hints, &airoot);\n     if (r != 0) {\n-      twarn(\"getaddrinfo(): %s\", gai_strerror(r));\n+      twarnx(\"getaddrinfo(): %s\", gai_strerror(r));\n       return -1;\n     }\n \n     for(ai = airoot; ai; ai = ai->ai_next) {\n       fd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n       if (fd == -1) {\n-        twarnerr(\"socket()\");\n+        twarn(\"socket()\");\n         continue;\n       }\n \n       flags = fcntl(fd, F_GETFL, 0);\n       if (flags < 0) {\n-        twarnerr(\"getting flags\");\n+        twarn(\"getting flags\");\n         close(fd);\n         continue;\n       }\n \n       r = fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n       if (r == -1) {\n-        twarnerr(\"setting O_NONBLOCK\");\n+        twarn(\"setting O_NONBLOCK\");\n         close(fd);\n         continue;\n       }\n \n       flags = 1;\n       r = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &flags, sizeof flags);\n       if (r == -1) {\n-        twarnerr(\"setting SO_REUSEADDR on fd %d\", fd);\n+        twarn(\"setting SO_REUSEADDR on fd %d\", fd);\n         close(fd);\n         continue;\n       }\n       r = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &flags, sizeof flags);\n       if (r == -1) {\n-        twarnerr(\"setting SO_KEEPALIVE on fd %d\", fd);\n+        twarn(\"setting SO_KEEPALIVE on fd %d\", fd);\n         close(fd);\n         continue;\n       }\n       r = setsockopt(fd, SOL_SOCKET, SO_LINGER, &linger, sizeof linger);\n       if (r == -1) {\n-        twarnerr(\"setting SO_LINGER on fd %d\", fd);\n+        twarn(\"setting SO_LINGER on fd %d\", fd);\n         close(fd);\n         continue;\n       }\n       r = setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flags, sizeof flags);\n       if (r == -1) {\n-        twarnerr(\"setting TCP_NODELAY on fd %d\", fd);\n+        twarn(\"setting TCP_NODELAY on fd %d\", fd);\n         close(fd);\n         continue;\n       }\n \n       r = bind(fd, ai->ai_addr, ai->ai_addrlen);\n       if (r == -1) {\n-        twarnerr(\"bind()\");\n+        twarn(\"bind()\");\n         close(fd);\n         continue;\n       }\n@@ -132,7 +132,7 @@ make_server_socket(char *host, char *port)\n \n       r = listen(fd, 1024);\n       if (r == -1) {\n-        twarnerr(\"listen()\");\n+        twarn(\"listen()\");\n         close(fd);\n         continue;\n       }\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -315,7 +315,7 @@ protrmdirty(Conn *c)\n \n #define reply_msg(c,m) reply((c),(m),CONSTSTRLEN(m),STATE_SENDWORD)\n \n-#define reply_serr(c,e) (twarn(\"server error: %s\",(e)),\\\n+#define reply_serr(c,e) (twarnx(\"server error: %s\",(e)),\\\n                          reply_msg((c),(e)))\n \n static void\n@@ -701,7 +701,7 @@ check_err(Conn *c, const char *s)\n     if (errno == EINTR) return;\n     if (errno == EWOULDBLOCK) return;\n \n-    twarnerr(\"%s\", s);\n+    twarn(\"%s\", s);\n     c->state = STATE_CLOSE;\n     return;\n }\n@@ -1269,7 +1269,7 @@ dispatch_cmd(Conn *c)\n         /* OOM? */\n         if (!c->in_job) {\n             /* throw away the job body and respond with OUT_OF_MEMORY */\n-            twarn(\"server error: \" MSG_OUT_OF_MEMORY);\n+            twarnx(\"server error: \" MSG_OUT_OF_MEMORY);\n             return skip(c, body_size + 2, MSG_OUT_OF_MEMORY);\n         }\n \n@@ -1852,7 +1852,7 @@ update_conns()\n         c->next = NULL;\n         r = sockwant(&c->sock, c->rw);\n         if (r == -1) {\n-            twarnerr(\"sockwant\");\n+            twarn(\"sockwant\");\n             connclose(c);\n         }\n     }\n@@ -1862,7 +1862,7 @@ static void\n h_conn(const int fd, const short which, Conn *c)\n {\n     if (fd != c->sock.fd) {\n-        twarn(\"Argh! event fd doesn't match conn fd.\");\n+        twarnx(\"Argh! event fd doesn't match conn fd.\");\n         close(fd);\n         connclose(c);\n         update_conns();\n@@ -1956,7 +1956,7 @@ h_accept(const int fd, const short which, Server *s)\n     socklen_t addrlen = sizeof addr;\n     int cfd = accept(fd, (struct sockaddr *)&addr, &addrlen);\n     if (cfd == -1) {\n-        if (errno != EAGAIN && errno != EWOULDBLOCK) twarnerr(\"accept()\");\n+        if (errno != EAGAIN && errno != EWOULDBLOCK) twarn(\"accept()\");\n         update_conns();\n         return;\n     }\n@@ -1966,7 +1966,7 @@ h_accept(const int fd, const short which, Server *s)\n \n     int flags = fcntl(cfd, F_GETFL, 0);\n     if (flags < 0) {\n-        twarnerr(\"getting flags\");\n+        twarn(\"getting flags\");\n         close(cfd);\n         if (verbose) {\n             printf(\"close %d\\n\", cfd);\n@@ -1977,7 +1977,7 @@ h_accept(const int fd, const short which, Server *s)\n \n     int r = fcntl(cfd, F_SETFL, flags | O_NONBLOCK);\n     if (r < 0) {\n-        twarnerr(\"setting O_NONBLOCK\");\n+        twarn(\"setting O_NONBLOCK\");\n         close(cfd);\n         if (verbose) {\n             printf(\"close %d\\n\", cfd);\n@@ -1988,7 +1988,7 @@ h_accept(const int fd, const short which, Server *s)\n \n     Conn *c = make_conn(cfd, STATE_WANTCOMMAND, default_tube, default_tube);\n     if (!c) {\n-        twarn(\"make_conn() failed\");\n+        twarnx(\"make_conn() failed\");\n         close(cfd);\n         if (verbose) {\n             printf(\"close %d\\n\", cfd);\n@@ -2003,7 +2003,7 @@ h_accept(const int fd, const short which, Server *s)\n \n     r = sockwant(&c->sock, 'r');\n     if (r == -1) {\n-        twarnerr(\"sockwant\");\n+        twarn(\"sockwant\");\n         close(cfd);\n         if (verbose) {\n             printf(\"close %d\\n\", cfd);\n@@ -2022,15 +2022,15 @@ prot_init()\n \n     int dev_random = open(\"/dev/urandom\", O_RDONLY);\n     if (dev_random < 0) {\n-        twarnerr(\"open /dev/urandom\");\n+        twarn(\"open /dev/urandom\");\n         exit(50);\n     }\n \n     int i, r;\n     byte rand_data[NumIdBytes];\n     r = read(dev_random, &rand_data, NumIdBytes);\n     if (r != NumIdBytes) {\n-        twarnerr(\"read /dev/urandom\");\n+        twarn(\"read /dev/urandom\");\n         exit(50);\n     }\n     for (i = 0; i < NumIdBytes; i++) {\n@@ -2039,14 +2039,14 @@ prot_init()\n     close(dev_random);\n \n     if (uname(&node_info) == -1) {\n-        twarn(\"uname\");\n+        warn(\"uname\");\n         exit(50);\n     }\n \n     ms_init(&tubes, NULL, NULL);\n \n     TUBE_ASSIGN(default_tube, tube_find_or_make(\"default\"));\n-    if (!default_tube) twarn(\"Out of memory during startup!\");\n+    if (!default_tube) twarnx(\"Out of memory during startup!\");\n }\n \n // For each job in list, inserts the job into the appropriate data\n@@ -2065,7 +2065,7 @@ prot_replay(Server *s, Job *list)\n         job_remove(j);\n         z = walresvupdate(&s->wal);\n         if (!z) {\n-            twarn(\"failed to reserve space\");\n+            twarnx(\"failed to reserve space\");\n             return 0;\n         }\n         delay = 0;\n@@ -2081,7 +2081,7 @@ prot_replay(Server *s, Job *list)\n             /* fall through */\n         default:\n             r = enqueue_job(s, j, delay, 0);\n-            if (r < 1) twarn(\"error recovering job %\"PRIu64, j->r.id);\n+            if (r < 1) twarnx(\"error recovering job %\"PRIu64, j->r.id);\n         }\n     }\n     return 1;\n\ndiff --git a/serv.c b/serv.c\n--- a/serv.c\n+++ b/serv.c\n@@ -19,7 +19,7 @@ srvserve(Server *s)\n     int64 period;\n \n     if (sockinit() == -1) {\n-        twarn(\"sockinit\");\n+        twarnx(\"sockinit\");\n         exit(1);\n     }\n \n@@ -30,13 +30,13 @@ srvserve(Server *s)\n \n     r = listen(s->sock.fd, 1024);\n     if (r == -1) {\n-        twarnerr(\"listen\");\n+        twarn(\"listen\");\n         return;\n     }\n \n     r = sockwant(&s->sock, 'r');\n     if (r == -1) {\n-        twarnerr(\"sockwant\");\n+        twarn(\"sockwant\");\n         exit(2);\n     }\n \n@@ -46,7 +46,7 @@ srvserve(Server *s)\n \n         int rw = socknext(&sock, period);\n         if (rw == -1) {\n-            twarn(\"socknext\");\n+            twarnx(\"socknext\");\n             exit(1);\n         }\n \n\ndiff --git a/sunos.c b/sunos.c\n--- a/sunos.c\n+++ b/sunos.c\n@@ -35,7 +35,7 @@ sockinit(void)\n {\n     portfd = port_create();\n     if (portfd == -1) {\n-        twarnerr(\"port_create\");\n+        twarn(\"port_create\");\n         return -1;\n     }\n     return 0;\n@@ -86,7 +86,7 @@ socknext(Socket **s, int64 timeout)\n     ts.tv_nsec = timeout % 1000000000;\n     r = port_getn(portfd, &pe, 1, &n, &ts);\n     if (r == -1 && errno != ETIME && errno != EINTR) {\n-        twarnerr(\"port_getn\");\n+        twarn(\"port_getn\");\n         return -1;\n     }\n \n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -47,7 +47,7 @@ muststart(char *a0, char *a1, char *a2, char *a3, char *a4)\n {\n     srvpid = fork();\n     if (srvpid < 0) {\n-        twarnerr(\"fork\");\n+        twarn(\"fork\");\n         exit(1);\n     }\n \n@@ -74,26 +74,26 @@ mustdiallocal(int port)\n     int r = inet_aton(\"127.0.0.1\", &addr.sin_addr);\n     if (!r) {\n         errno = EINVAL;\n-        twarnerr(\"inet_aton\");\n+        twarn(\"inet_aton\");\n         exit(1);\n     }\n \n     int fd = socket(AF_INET, SOCK_STREAM, 0);\n     if (fd == -1) {\n-        twarnerr(\"socket\");\n+        twarn(\"socket\");\n         exit(1);\n     }\n \n     // Fix of the benchmarking issue on Linux. See issue #430.\n     int flags = 1;\n     if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flags, sizeof(int))) {\n-        twarnerr(\"setting TCP_NODELAY on fd %d\", fd);\n+        twarn(\"setting TCP_NODELAY on fd %d\", fd);\n         exit(1);\n     }\n \n     r = connect(fd, (struct sockaddr *)&addr, sizeof addr);\n     if (r == -1) {\n-        twarnerr(\"connect\");\n+        twarn(\"connect\");\n         exit(1);\n     }\n \n@@ -115,15 +115,15 @@ set_sig_handler()\n     sa.sa_flags = 0;\n     int r = sigemptyset(&sa.sa_mask);\n     if (r == -1) {\n-        twarnerr(\"sigemptyset()\");\n+        twarn(\"sigemptyset()\");\n         exit(111);\n     }\n \n     // This is required to trigger gcov on exit. See issue #443.\n     sa.sa_handler = exit_process;\n     r = sigaction(SIGTERM, &sa, 0);\n     if (r == -1) {\n-        twarnerr(\"sigaction(SIGTERM)\");\n+        twarn(\"sigaction(SIGTERM)\");\n         exit(111);\n     }\n }\n@@ -167,7 +167,7 @@ mustforksrv(void)\n     int port = ntohs(addr.sin_port);\n     srvpid = fork();\n     if (srvpid < 0) {\n-        twarnerr(\"fork\");\n+        twarn(\"fork\");\n         exit(1);\n     }\n \n@@ -188,7 +188,7 @@ mustforksrv(void)\n         // to use the wal directory at a time. So acquire a lock\n         // now and never release it.\n         if (!waldirlock(&srv.wal)) {\n-            twarn(\"failed to lock wal dir %s\", srv.wal.dir);\n+            twarnx(\"failed to lock wal dir %s\", srv.wal.dir);\n             exit(10);\n         }\n \n@@ -200,7 +200,7 @@ mustforksrv(void)\n         walinit(&srv.wal, &list);\n         int ok = prot_replay(&srv, &list);\n         if (!ok) {\n-            twarn(\"failed to replay log\");\n+            twarnx(\"failed to replay log\");\n             exit(11);\n         }\n     }\n@@ -307,7 +307,7 @@ filesize(char *path)\n \n     int r = stat(path, &s);\n     if (r == -1) {\n-        twarnerr(\"stat\");\n+        twarn(\"stat\");\n         exit(1);\n     }\n     return s.st_size;\n\ndiff --git a/time.c b/time.c\n--- a/time.c\n+++ b/time.c\n@@ -10,7 +10,7 @@ nanoseconds(void)\n     struct timeval tv;\n \n     r = gettimeofday(&tv, 0);\n-    if (r != 0) return warn(\"gettimeofday\"), -1; // can't happen\n+    if (r != 0) return warnx(\"gettimeofday\"), -1; // can't happen\n \n     return ((int64)tv.tv_sec)*1000000000 + ((int64)tv.tv_usec)*1000;\n }\n\ndiff --git a/tube.c b/tube.c\n--- a/tube.c\n+++ b/tube.c\n@@ -16,7 +16,7 @@ make_tube(const char *name)\n     t->name[MAX_TUBE_NAME_LEN - 1] = '\\0';\n     strncpy(t->name, name, MAX_TUBE_NAME_LEN - 1);\n     if (t->name[MAX_TUBE_NAME_LEN - 1] != '\\0')\n-        twarn(\"truncating tube name\");\n+        twarnx(\"truncating tube name\");\n \n     t->ready.less = job_pri_less;\n     t->delay.less = job_delay_less;\n@@ -46,7 +46,7 @@ tube_dref(Tube *t)\n {\n     if (!t) return;\n     if (t->refs < 1)\n-        return twarn(\"refs is zero for tube: %s\", t->name);\n+        return twarnx(\"refs is zero for tube: %s\", t->name);\n \n     --t->refs;\n     if (t->refs < 1)\n\ndiff --git a/util.c b/util.c\n--- a/util.c\n+++ b/util.c\n@@ -10,40 +10,37 @@\n const char *progname;\n \n static void\n-_warnerr(const char *err, const char *fmt, va_list args)\n+vwarnx(const char *err, const char *fmt, va_list args)\n __attribute__((format(printf, 2, 0)));\n \n-// _warnerr prints formatted text prefixed by progname into stderr.\n-// If err is not NULL, it is printed at last.\n static void\n-_warnerr(const char *err, const char *fmt, va_list args)\n+vwarnx(const char *err, const char *fmt, va_list args)\n {\n     fprintf(stderr, \"%s: \", progname);\n     if (fmt) {\n         vfprintf(stderr, fmt, args);\n-        if (err)\n-            fprintf(stderr, \": %s\", err);\n+        if (err) fprintf(stderr, \": %s\", err);\n     }\n     fputc('\\n', stderr);\n }\n \n void\n-warnerr(const char *fmt, ...)\n+warn(const char *fmt, ...)\n {\n     char *err = strerror(errno); /* must be done first thing */\n     va_list args;\n \n     va_start(args, fmt);\n-    _warnerr(err, fmt, args);\n+    vwarnx(err, fmt, args);\n     va_end(args);\n }\n \n void\n-warn(const char *fmt, ...)\n+warnx(const char *fmt, ...)\n {\n     va_list args;\n     va_start(args, fmt);\n-    _warnerr(NULL, fmt, args);\n+    vwarnx(NULL, fmt, args);\n     va_end(args);\n }\n \n@@ -90,7 +87,7 @@ static void\n warn_systemd_ignored_option(char *opt, char *arg)\n {\n     if (sd_listen_fds(0) > 0) {\n-        warn(\"inherited listen fd; ignoring option: %s %s\", opt, arg);\n+        warnx(\"inherited listen fd; ignoring option: %s %s\", opt, arg);\n     }\n }\n \n@@ -129,7 +126,7 @@ static char *flagusage(char *flag) __attribute__ ((noreturn));\n static char *\n flagusage(char *flag)\n {\n-    warn(\"flag requires an argument: %s\", flag);\n+    warnx(\"flag requires an argument: %s\", flag);\n     usage(5);\n }\n \n@@ -142,7 +139,7 @@ parse_size_t(char *str)\n \n     r = sscanf(str, \"%zu%c\", &size, &x);\n     if (1 != r) {\n-        warn(\"invalid size: %s\", str);\n+        warnx(\"invalid size: %s\", str);\n         usage(5);\n     }\n     return size;\n@@ -170,7 +167,7 @@ optparse(Server *s, char **argv)\n                 case 'z':\n                     job_data_size_limit = parse_size_t(EARGF(flagusage(\"-z\")));\n                     if (job_data_size_limit > JOB_DATA_SIZE_LIMIT_MAX) {\n-                        warn(\"maximum job size was set to %d\", JOB_DATA_SIZE_LIMIT_MAX);\n+                        warnx(\"maximum job size was set to %d\", JOB_DATA_SIZE_LIMIT_MAX);\n                         job_data_size_limit = JOB_DATA_SIZE_LIMIT_MAX;\n                     }\n                     break;\n@@ -207,13 +204,13 @@ optparse(Server *s, char **argv)\n                     verbose++;\n                     break;\n                 default:\n-                    warn(\"unknown flag: %s\", arg-2);\n+                    warnx(\"unknown flag: %s\", arg-2);\n                     usage(5);\n             }\n         }\n     }\n     if (arg) {\n-        warn(\"unknown argument: %s\", arg-1);\n+        warnx(\"unknown argument: %s\", arg-1);\n         usage(5);\n     }\n }\n\ndiff --git a/walg.c b/walg.c\n--- a/walg.c\n+++ b/walg.c\n@@ -78,7 +78,7 @@ usenext(Wal *w)\n \n     f = w->cur;\n     if (!f->next) {\n-        twarn(\"there is no next wal file\");\n+        twarnx(\"there is no next wal file\");\n         return 0;\n     }\n \n@@ -130,7 +130,7 @@ moveone(Wal *w)\n     j = w->head->jlist.fnext;\n     if (!j || j == &w->head->jlist) {\n         // head holds no jlist; can't happen\n-        twarn(\"head holds no jlist\");\n+        twarnx(\"head holds no jlist\");\n         return;\n     }\n \n@@ -165,7 +165,7 @@ walsync(Wal *w)\n     if (w->wantsync && now >= w->lastsync+w->syncrate) {\n         w->lastsync = now;\n         if (fsync(w->cur->fd) == -1) {\n-            twarnerr(\"fsync\");\n+            twarn(\"fsync\");\n         }\n     }\n }\n@@ -216,13 +216,13 @@ makenextfile(Wal *w)\n \n     f = new(File);\n     if (!f) {\n-        twarn(\"OOM\");\n+        twarnx(\"OOM\");\n         return 0;\n     }\n \n     if (!fileinit(f, w, w->next)) {\n         free(f);\n-        twarn(\"OOM\");\n+        twarnx(\"OOM\");\n         return 0;\n     }\n \n@@ -286,7 +286,7 @@ balancerest(Wal *w, File *b, int n)\n     }\n \n     if (needfree(w, r) != r) {\n-        twarn(\"needfree\");\n+        twarnx(\"needfree\");\n         return 0;\n     }\n     moveresv(w->tail, b, r);\n@@ -316,7 +316,7 @@ balance(Wal *w, int n)\n \n         r = needfree(w, m);\n         if (r != m) {\n-            twarn(\"needfree\");\n+            twarnx(\"needfree\");\n             return 0;\n         }\n \n@@ -347,7 +347,7 @@ reserve(Wal *w, int n)\n \n     r = needfree(w, n);\n     if (r != n) {\n-        twarn(\"needfree\");\n+        twarnx(\"needfree\");\n         return 0;\n     }\n \n@@ -409,15 +409,15 @@ waldirlock(Wal *w)\n \n     path_length = strlen(w->dir) + strlen(\"/lock\") + 1;\n     if ((path = malloc(path_length)) == NULL) {\n-        twarnerr(\"malloc\");\n+        twarn(\"malloc\");\n         return 0;\n     }\n     r = snprintf(path, path_length, \"%s/lock\", w->dir);\n \n     fd = open(path, O_WRONLY|O_CREAT, 0600);\n     free(path);\n     if (fd == -1) {\n-        twarnerr(\"open\");\n+        twarn(\"open\");\n         return 0;\n     }\n \n@@ -427,7 +427,7 @@ waldirlock(Wal *w)\n     lk.l_len = 0;\n     r = fcntl(fd, F_SETLK, &lk);\n     if (r) {\n-        twarnerr(\"fcntl\");\n+        twarn(\"fcntl\");\n         return 0;\n     }\n \n@@ -447,19 +447,19 @@ walread(Wal *w, Job *list, int min)\n     for (i = min; i < w->next; i++) {\n         f = new(File);\n         if (!f) {\n-            twarn(\"OOM\");\n+            twarnx(\"OOM\");\n             exit(1);\n         }\n \n         if (!fileinit(f, w, i)) {\n             free(f);\n-            twarn(\"OOM\");\n+            twarnx(\"OOM\");\n             exit(1);\n         }\n \n         fd = open(f->path, O_RDONLY);\n         if (fd < 0) {\n-            twarnerr(\"open %s\", f->path);\n+            twarn(\"open %s\", f->path);\n             free(f->path);\n             free(f);\n             continue;\n@@ -472,8 +472,8 @@ walread(Wal *w, Job *list, int min)\n     }\n \n     if (err) {\n-        warn(\"Errors reading one or more WAL files.\");\n-        warn(\"Continuing. You may be missing data.\");\n+        warnx(\"Errors reading one or more WAL files.\");\n+        warnx(\"Continuing. You may be missing data.\");\n     }\n }\n \n@@ -488,7 +488,7 @@ walinit(Wal *w, Job *list)\n \n     // first writable file\n     if (!makenextfile(w)) {\n-        twarn(\"makenextfile\");\n+        twarnx(\"makenextfile\");\n         exit(1);\n     }\n \n", "test_patch": "", "problem_statement": "Revert \"make names of warn* functions and macros consistent\"\nThis reverts commit c6157f701ca83ed5d5194a53ec8b72c99aa503a9.", "version": "1.11", "language": "C", "created_at": "2019-07-29T15:44:45Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-456", "repo": "beanstalkd/beanstalkd", "pull_number": 456, "base_commit": "7cffa894298d881aa658d6a1df69290ac0b9a654", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -62,7 +62,12 @@ typedef int(FAlloc)(int, int);\n #define URGENT_THRESHOLD 1024\n #define JOB_DATA_SIZE_LIMIT_DEFAULT ((1 << 16) - 1)\n \n-/* Maximum value (uint32) allowed in pri, delay and ttr parameters */\n+// The maximum value that job_data_size_limit can be set to via \"-z\".\n+// It could be up to INT32_MAX-2 (~2GB), but set it to 1024^3 (1GB).\n+// The width is restricted by Jobrec.body_size that is int32.\n+#define JOB_DATA_SIZE_LIMIT_MAX 1073741824\n+\n+// Maximum value (uint32) allowed in pri, delay and ttr parameters\n #define MAX_UINT32 4294967295\n \n #define UNUSED_PARAMETER(x) (void)(x)\n@@ -127,7 +132,10 @@ enum // Jobrec.state\n     Copy\n };\n \n-// if you modify this struct, you must increment Walver above\n+// If you modify this struct, you must increment Walver above,\n+// Beanstalkd does not handle migration between different versions:\n+// it will reject the old data and exit from the server.\n+// TODO: Handle Walver migrations automatically.\n struct Jobrec {\n     uint64 id;\n     uint32 pri;\n@@ -297,8 +305,8 @@ struct Conn {\n     // while in_job_read is nonzero, we are in bit bucket mode and\n     // in_job_read's meaning is inverted -- then it counts the bytes that\n     // remain to be thrown away.\n-    int in_job_read;\n-    job in_job; // a job to be read from the client\n+    int32 in_job_read;\n+    job   in_job; // a job to be read from the client\n \n     job out_job;\n     int out_job_sent;\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -774,14 +774,13 @@ which_cmd(Conn *c)\n static void\n fill_extra_data(Conn *c)\n {\n-    int extra_bytes, job_data_bytes = 0, cmd_bytes;\n-\n     if (!c->sock.fd) return; /* the connection was closed */\n     if (!c->cmd_len) return; /* we don't have a complete command */\n \n     /* how many extra bytes did we read? */\n-    extra_bytes = c->cmd_read - c->cmd_len;\n+    int32 extra_bytes = c->cmd_read - c->cmd_len;\n \n+    int32 job_data_bytes = 0;\n     /* how many bytes should we put into the job body? */\n     if (c->in_job) {\n         job_data_bytes = min(extra_bytes, c->in_job->r.body_size);\n@@ -794,32 +793,33 @@ fill_extra_data(Conn *c)\n     }\n \n     /* how many bytes are left to go into the future cmd? */\n-    cmd_bytes = extra_bytes - job_data_bytes;\n+    int32 cmd_bytes = extra_bytes - job_data_bytes;\n     memmove(c->cmd, c->cmd + c->cmd_len + job_data_bytes, cmd_bytes);\n     c->cmd_read = cmd_bytes;\n     c->cmd_len = 0; /* we no longer know the length of the new command */\n }\n \n+#define skip(conn,n,msg) (_skip(conn,n,msg,CONSTSTRLEN(msg)))\n+\n static void\n-_skip(Conn *c, int n, char *line, int len)\n+_skip(Conn *c, int32 n, char *msg, int msglen)\n {\n     /* Invert the meaning of in_job_read while throwing away data -- it\n      * counts the bytes that remain to be thrown away. */\n     c->in_job = 0;\n     c->in_job_read = n;\n     fill_extra_data(c);\n \n-    if (c->in_job_read == 0) return reply(c, line, len, STATE_SENDWORD);\n+    if (c->in_job_read == 0)\n+        return reply(c, msg, msglen, STATE_SENDWORD);\n \n-    c->reply = line;\n-    c->reply_len = len;\n+    c->reply = msg;\n+    c->reply_len = msglen;\n     c->reply_sent = 0;\n     c->state = STATE_BITBUCKET;\n     return;\n }\n \n-#define skip(c,n,m) (_skip(c,n,m,CONSTSTRLEN(m)))\n-\n static void\n enqueue_incoming_job(Conn *c)\n {\n@@ -1194,7 +1194,7 @@ dispatch_cmd(Conn *c)\n     byte type;\n     char *size_buf, *delay_buf, *ttr_buf, *pri_buf, *end_buf, *name;\n     uint32 pri;\n-    uint body_size;\n+    uint32 body_size;\n     int64 delay, ttr;\n     uint64 id;\n     tube t = NULL;\n@@ -1214,18 +1214,17 @@ dispatch_cmd(Conn *c)\n \n     switch (type) {\n     case OP_PUT:\n-        r = read_num(&pri, c->cmd + 4, &delay_buf);\n-        if (r) return reply_msg(c, MSG_BAD_FORMAT);\n+        if (read_num(&pri, c->cmd + 4, &delay_buf))\n+            return reply_msg(c, MSG_BAD_FORMAT);\n \n-        r = read_duration(&delay, delay_buf, &ttr_buf);\n-        if (r) return reply_msg(c, MSG_BAD_FORMAT);\n+        if (read_duration(&delay, delay_buf, &ttr_buf))\n+            return reply_msg(c, MSG_BAD_FORMAT);\n \n-        r = read_duration(&ttr, ttr_buf, &size_buf);\n-        if (r) return reply_msg(c, MSG_BAD_FORMAT);\n+        if (read_duration(&ttr, ttr_buf, &size_buf))\n+            return reply_msg(c, MSG_BAD_FORMAT);\n \n-        errno = 0;\n-        body_size = strtoul(size_buf, &end_buf, 10);\n-        if (errno) return reply_msg(c, MSG_BAD_FORMAT);\n+        if (read_num(&body_size, size_buf, &end_buf))\n+            return reply_msg(c, MSG_BAD_FORMAT);\n \n         op_ct[type]++;\n \n@@ -1235,7 +1234,8 @@ dispatch_cmd(Conn *c)\n         }\n \n         /* don't allow trailing garbage */\n-        if (end_buf[0] != '\\0') return reply_msg(c, MSG_BAD_FORMAT);\n+        if (end_buf[0] != '\\0')\n+            return reply_msg(c, MSG_BAD_FORMAT);\n \n         connsetproducer(c);\n \n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -508,6 +508,46 @@ cttest_too_big()\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n }\n \n+void\n+cttest_job_size_invalid()\n+{\n+    job_data_size_limit = JOB_DATA_SIZE_LIMIT_MAX;\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"put 0 0 0 4294967296\\r\\n\");\n+    mustsend(fd, \"put 0 0 0 10b\\r\\n\");\n+    mustsend(fd, \"put 0 0 0 --!@#$%^&&**()0b\\r\\n\");\n+    mustsend(fd, \"put 0 0 0 1\\r\\n\");\n+    mustsend(fd, \"x\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+}\n+\n+void\n+cttest_job_size_max_plus_1()\n+{\n+    /* verify that server reject the job larger than maximum allowed. */\n+    job_data_size_limit = JOB_DATA_SIZE_LIMIT_MAX;\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"put 0 0 0 1073741825\\r\\n\");\n+\n+    const int len = 1024*1024;\n+    char body[len+1];\n+    memset(body, 'a', len);\n+    body[len] = 0;\n+\n+    int i;\n+    for (i=0; i<JOB_DATA_SIZE_LIMIT_MAX; i+=len) {\n+        mustsend(fd, body);\n+    }\n+    mustsend(fd, \"x\");\n+    mustsend(fd, \"\\r\\n\");\n+    ckresp(fd, \"JOB_TOO_BIG\\r\\n\");\n+}\n+\n void\n cttest_delete_ready()\n {\n\ndiff --git a/testutil.c b/testutil.c\n--- a/testutil.c\n+++ b/testutil.c\n@@ -104,6 +104,18 @@ cttest_optz()\n     assert(job_data_size_limit == 1234);\n }\n \n+void\n+cttest_optz_more_than_max()\n+{\n+    char *args[] = {\n+        \"-z1073741825\",\n+        NULL,\n+    };\n+\n+    optparse(&srv, args);\n+    assert(job_data_size_limit == 1073741824);\n+}\n+\n void\n cttest_opts()\n {\n\ndiff --git a/util.c b/util.c\n--- a/util.c\n+++ b/util.c\n@@ -106,15 +106,18 @@ usage(int code)\n             \" -l ADDR  listen on address (default is 0.0.0.0)\\n\"\n             \" -p PORT  listen on port (default is \" Portdef \")\\n\"\n             \" -u USER  become user and group\\n\"\n-            \" -z BYTES set the maximum job size in bytes (default is %d)\\n\"\n+            \" -z BYTES set the maximum job size in bytes (default is %d, max allowed is %d)\\n\"\n             \" -s BYTES set the size of each write-ahead log file (default is %d)\\n\"\n             \"            (will be rounded up to a multiple of 512 bytes)\\n\"\n             \" -c       compact the binlog (default)\\n\"\n             \" -n       do not compact the binlog\\n\"\n             \" -v       show version information\\n\"\n             \" -V       increase verbosity\\n\"\n             \" -h       show this help\\n\",\n-            progname, JOB_DATA_SIZE_LIMIT_DEFAULT, Filesizedef);\n+            progname,\n+            JOB_DATA_SIZE_LIMIT_DEFAULT,\n+            JOB_DATA_SIZE_LIMIT_MAX,\n+            Filesizedef);\n     exit(code);\n }\n \n@@ -163,6 +166,10 @@ optparse(Server *s, char **argv)\n                     break;\n                 case 'z':\n                     job_data_size_limit = parse_size_t(EARGF(flagusage(\"-z\")));\n+                    if (job_data_size_limit > JOB_DATA_SIZE_LIMIT_MAX) {\n+                        warnx(\"maximum job size was set to %d\", JOB_DATA_SIZE_LIMIT_MAX);\n+                        job_data_size_limit = JOB_DATA_SIZE_LIMIT_MAX;\n+                    }\n                     break;\n                 case 's':\n                     s->wal.filesize = parse_size_t(EARGF(flagusage(\"-s\")));\n", "test_patch": "", "problem_statement": "fix the job size overflowing the int type and set hard limit on it\nI have set the maximum allowed limit for the job size to 1024^3 bytes (1GB).\r\nWhen user tries to specify (-z) the limit for the job size larger than that,\r\nhe will get a warning that limit was capped to 1GB.\r\n\r\nThe program stores body_size in int32 (see struct Jobrec) and verifies that \r\nparameter in the put command can be parsed and fit into int32. \r\nI have propagated changes to the type of all involved functions.\r\n\r\nFixes #401", "version": "1.11", "language": "C", "created_at": "2019-07-11T10:57:35Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-454", "repo": "beanstalkd/beanstalkd", "pull_number": 454, "base_commit": "44abcf34bba67d84e70dfa1db29d169ce3cdaac5", "patch": "diff --git a/file.c b/file.c\n--- a/file.c\n+++ b/file.c\n@@ -533,7 +533,10 @@ filewclose(File *f)\n     if (!f) return;\n     if (!f->iswopen) return;\n     if (f->free) {\n-        (void)ftruncate(f->fd, f->w->filesize - f->free);\n+        errno = 0;\n+        if (ftruncate(f->fd, f->w->filesize - f->free) != 0) {\n+            twarn(\"ftruncate\");\n+        }\n     }\n     close(f->fd);\n     f->iswopen = 0;\n", "test_patch": "", "problem_statement": "check the return value of ftruncate for possible error\nThis prevented compilation with -O2, -O3 levels on Linux with GCC.\r\n\r\nUpdates #423", "version": "1.11", "language": "C", "created_at": "2019-07-10T12:39:34Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-448", "repo": "beanstalkd/beanstalkd", "pull_number": 448, "base_commit": "5028e0408bed3401993c4a23ff63f49482321ae7", "patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -46,7 +46,7 @@ endif\n \n CLEANFILES=\\\n \tvers.c\\\n-\t$(wildcard *.gcda *.gcno)\n+\t$(wildcard *.gc*)\n \n .PHONY: all\n all: $(TARG)\n@@ -89,7 +89,7 @@ ct/ct.o ct/_ctcheck.o: ct/ct.h ct/internal.h\n \n $(TOFILES): $(HFILES) ct/ct.h\n \n-CLEANFILES+=$(wildcard ct/_* ct/*.o)\n+CLEANFILES+=$(wildcard ct/_* ct/*.o ct/*.gc*)\n \n ifneq ($(shell ./verc.sh),$(shell cat vers.c 2>/dev/null))\n .PHONY: vers.c\n\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -1,3 +1,6 @@\n+[![Build Status](https://travis-ci.org/beanstalkd/beanstalkd.svg?branch=master)](https://travis-ci.org/beanstalkd/beanstalkd)\n+[![codecov](https://codecov.io/gh/beanstalkd/beanstalkd/branch/master/graph/badge.svg)](https://codecov.io/gh/beanstalkd/beanstalkd)\n+\n # beanstalkd\n \n Simple and fast general purpose work queue.\n@@ -46,7 +49,3 @@ See http://github.com/rtomayko/ronn.\n Unit tests are in test*.c. See https://github.com/kr/ct for\n information on how to write them.\n \n-## Code Status\n-[![Build Status](https://travis-ci.org/beanstalkd/beanstalkd.svg?branch=master)](https://travis-ci.org/beanstalkd/beanstalkd)\n-[![codecov](https://codecov.io/gh/beanstalkd/beanstalkd/branch/master/graph/badge.svg)](https://codecov.io/gh/beanstalkd/beanstalkd)\n-\n\ndiff --git a/main.c b/main.c\n--- a/main.c\n+++ b/main.c\n@@ -36,7 +36,6 @@ su(const char *user)\n     }\n }\n \n-\n static void\n set_sig_handlers()\n {\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -60,19 +60,18 @@ muststart(char *a0, char *a1, char *a2, char *a3, char *a4)\n static int\n mustdiallocal(int port)\n {\n-    int r, fd;\n     struct sockaddr_in addr = {};\n \n     addr.sin_family = AF_INET;\n     addr.sin_port = htons(port);\n-    r = inet_aton(\"127.0.0.1\", &addr.sin_addr);\n+    int r = inet_aton(\"127.0.0.1\", &addr.sin_addr);\n     if (!r) {\n         errno = EINVAL;\n         twarn(\"inet_aton\");\n         exit(1);\n     }\n \n-    fd = socket(PF_INET, SOCK_STREAM, 0);\n+    int fd = socket(PF_INET, SOCK_STREAM, 0);\n     if (fd == -1) {\n         twarn(\"socket\");\n         exit(1);\n@@ -87,12 +86,43 @@ mustdiallocal(int port)\n     return fd;\n }\n \n-#define SERVER() (progname = __func__, mustforksrv())\n+#ifdef WITHCOV\n+void __gcov_flush (void);\n+\n+void\n+gcov_flush(int signum)\n+{\n+    __gcov_flush(); /* dump coverage data  */\n+    usleep(500000); /* .5s; time to write data */\n+    exit(1);        /* some tests are stuck without it */\n+}\n+\n+static void\n+set_sig_usr2()\n+{\n+    struct sigaction sa;\n+\n+    sa.sa_flags = 0;\n+    int r = sigemptyset(&sa.sa_mask);\n+    if (r == -1) {\n+        twarn(\"sigemptyset()\");\n+        exit(111);\n+    }\n+\n+    sa.sa_handler = gcov_flush;\n+    r = sigaction(SIGUSR2, &sa, 0);\n+    if (r == -1) {\n+        twarn(\"sigaction(SIGUSR2)\");\n+        exit(111);\n+    }\n+}\n+#endif\n+\n+#define SERVER() (progname=__func__, mustforksrv())\n \n static int\n mustforksrv()\n {\n-    int r, len, port, ok;\n     struct sockaddr_in addr;\n \n     srv.sock.fd = make_server_socket(\"127.0.0.1\", \"0\");\n@@ -101,14 +131,14 @@ mustforksrv()\n         exit(1);\n     }\n \n-    len = sizeof(addr);\n-    r = getsockname(srv.sock.fd, (struct sockaddr *)&addr, (socklen_t *)&len);\n+    size_t len = sizeof(addr);\n+    int r = getsockname(srv.sock.fd, (struct sockaddr*)&addr, (socklen_t*)&len);\n     if (r == -1 || len > sizeof(addr)) {\n         puts(\"mustforksrv failed\");\n         exit(1);\n     }\n \n-    port = ntohs(addr.sin_port);\n+    int port = ntohs(addr.sin_port);\n     srvpid = fork();\n     if (srvpid < 0) {\n         twarn(\"fork\");\n@@ -123,6 +153,9 @@ mustforksrv()\n     /* now in child */\n \n     prot_init();\n+#ifdef WITHCOV\n+    set_sig_usr2();\n+#endif\n \n     if (srv.wal.use) {\n         struct job list = {};\n@@ -136,7 +169,7 @@ mustforksrv()\n \n         list.prev = list.next = &list;\n         walinit(&srv.wal, &list);\n-        ok = prot_replay(&srv, &list);\n+        int ok = prot_replay(&srv, &list);\n         if (!ok) {\n             twarnx(\"failed to replay log\");\n             exit(11);\n@@ -150,20 +183,21 @@ mustforksrv()\n static char *\n readline(int fd)\n {\n-    int r, i = 0;\n     char c = 0, p = 0;\n     static char buf[1024];\n     fd_set rfd;\n     struct timeval tv;\n \n     printf(\"<%d \", fd);\n     fflush(stdout);\n+\n+    size_t i = 0;\n     for (;;) {\n         FD_ZERO(&rfd);\n         FD_SET(fd, &rfd);\n         tv.tv_sec = timeout / 1000000000;\n         tv.tv_usec = (timeout/1000) % 1000000;\n-        r = select(fd+1, &rfd, NULL, NULL, &tv);\n+        int r = select(fd+1, &rfd, NULL, NULL, &tv);\n         switch (r) {\n         case 1:\n             break;\n@@ -202,18 +236,14 @@ readline(int fd)\n static void\n ckresp(int fd, char *exp)\n {\n-    char *line;\n-\n-    line = readline(fd);\n+    char *line = readline(fd);\n     assertf(strcmp(exp, line) == 0, \"\\\"%s\\\" != \\\"%s\\\"\", exp, line);\n }\n \n static void\n ckrespsub(int fd, char *sub)\n {\n-    char *line;\n-\n-    line = readline(fd);\n+    char *line = readline(fd);\n     assertf(strstr(line, sub), \"\\\"%s\\\" not in \\\"%s\\\"\", sub, line);\n }\n \n@@ -242,10 +272,9 @@ mustsend(int fd, char *s)\n static int\n filesize(char *path)\n {\n-    int r;\n     struct stat s;\n \n-    r = stat(path, &s);\n+    int r = stat(path, &s);\n     if (r == -1) {\n         twarn(\"stat\");\n         exit(1);\n@@ -256,10 +285,9 @@ filesize(char *path)\n static int\n exist(char *path)\n {\n-    int r;\n     struct stat s;\n \n-    r = stat(path, &s);\n+    int r = stat(path, &s);\n     return r != -1;\n }\n \n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -86,19 +86,15 @@ mustdiallocal(int port)\n     return fd;\n }\n \n-#ifdef WITHCOV\n-void __gcov_flush (void);\n-\n-void\n-gcov_flush(int signum)\n+static void\n+exit_process(int signum)\n {\n-    __gcov_flush(); /* dump coverage data  */\n-    usleep(500000); /* .5s; time to write data */\n-    exit(1);        /* some tests are stuck without it */\n+    printf(\"exiting from child\\n\");\n+    exit(0);\n }\n \n static void\n-set_sig_usr2()\n+set_sig_handler()\n {\n     struct sigaction sa;\n \n@@ -109,14 +105,31 @@ set_sig_usr2()\n         exit(111);\n     }\n \n-    sa.sa_handler = gcov_flush;\n-    r = sigaction(SIGUSR2, &sa, 0);\n+    sa.sa_handler = exit_process;\n+    r = sigaction(SIGTERM, &sa, 0);\n     if (r == -1) {\n-        twarn(\"sigaction(SIGUSR2)\");\n+        twarn(\"sigaction(SIGTERM)\");\n         exit(111);\n     }\n }\n-#endif\n+\n+static void\n+kill_srv_atexit(void)\n+{\n+    /* if we are already in child do not exit.\n+       Code below can make tests pass,\n+       but decreases coverage from 58.5 to 46.2%. */\n+    /* if (srvpid != 0) */\n+    /*     return; */\n+\n+    /* printf statements are for debugging purposes */\n+    printf(\"killing %d\\n\", srvpid);\n+    kill(srvpid, SIGTERM);\n+\n+    printf(\"waiting %d\\n\", srvpid);\n+    waitpid(srvpid, 0, 0);\n+    printf(\"exited %d\\n\", srvpid);\n+}\n \n #define SERVER() (progname=__func__, mustforksrv())\n \n@@ -146,16 +159,17 @@ mustforksrv()\n     }\n \n     if (srvpid > 0) {\n+        /* srvpid is of a child. */\n+        /* When the parent (test) has finished it will send sigterm to the child */\n+        atexit(kill_srv_atexit);\n         printf(\"start server port=%d pid=%d\\n\", port, srvpid);\n         return port;\n     }\n \n     /* now in child */\n \n     prot_init();\n-#ifdef WITHCOV\n-    set_sig_usr2();\n-#endif\n+    set_sig_handler();\n \n     if (srv.wal.use) {\n         struct job list = {};\n@@ -700,7 +714,7 @@ cttest_binlog_empty_exit()\n \n     port = SERVER();\n \n-    kill(srvpid, 9);\n+    kill(srvpid, SIGTERM);\n     waitpid(srvpid, NULL, 0);\n \n     port = SERVER();\n@@ -742,7 +756,7 @@ cttest_binlog_basic()\n     mustsend(fd, \"\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n \n-    kill(srvpid, 9);\n+    kill(srvpid, SIGTERM);\n     waitpid(srvpid, NULL, 0);\n \n     port = SERVER();\n@@ -836,7 +850,7 @@ cttest_binlog_read()\n     mustsend(fd, \"delete 2\\r\\n\");\n     ckresp(fd, \"DELETED\\r\\n\");\n \n-    kill(srvpid, 9);\n+    kill(srvpid, SIGTERM);\n     waitpid(srvpid, NULL, 0);\n \n     port = SERVER();\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -1,3 +1,4 @@\n+#include <stdbool.h>\n #include <stdint.h>\n #include <stdlib.h>\n #include <string.h>\n@@ -89,7 +90,6 @@ mustdiallocal(int port)\n static void\n exit_process(int signum)\n {\n-    printf(\"exiting from child\\n\");\n     exit(0);\n }\n \n@@ -113,28 +113,20 @@ set_sig_handler()\n     }\n }\n \n+// Kill the child process with our chosen signal to give it a chance\n+// to write gcov data to the filesystem before ct kills it with SIGKILL.\n static void\n kill_srv_atexit(void)\n {\n-    /* if we are already in child do not exit.\n-       Code below can make tests pass,\n-       but decreases coverage from 58.5 to 46.2%. */\n-    /* if (srvpid != 0) */\n-    /*     return; */\n-\n-    /* printf statements are for debugging purposes */\n-    printf(\"killing %d\\n\", srvpid);\n     kill(srvpid, SIGTERM);\n-\n-    printf(\"waiting %d\\n\", srvpid);\n     waitpid(srvpid, 0, 0);\n-    printf(\"exited %d\\n\", srvpid);\n }\n \n-#define SERVER() (progname=__func__, mustforksrv())\n+#define SERVER() (progname=__func__, mustforksrv(true))\n+#define SERVER_NO_ATEXIT() (progname=__func__, mustforksrv(false))\n \n static int\n-mustforksrv()\n+mustforksrv(bool set_atexit)\n {\n     struct sockaddr_in addr;\n \n@@ -159,17 +151,18 @@ mustforksrv()\n     }\n \n     if (srvpid > 0) {\n-        /* srvpid is of a child. */\n-        /* When the parent (test) has finished it will send sigterm to the child */\n-        atexit(kill_srv_atexit);\n+        /* When the parent (test) is finished it will send SIGTERM to the child */\n+        if (set_atexit) {\n+            atexit(kill_srv_atexit);\n+        }\n         printf(\"start server port=%d pid=%d\\n\", port, srvpid);\n         return port;\n     }\n \n     /* now in child */\n \n-    prot_init();\n     set_sig_handler();\n+    prot_init();\n \n     if (srv.wal.use) {\n         struct job list = {};\n@@ -712,7 +705,7 @@ cttest_binlog_empty_exit()\n     srv.wal.use = 1;\n     job_data_size_limit = 10;\n \n-    port = SERVER();\n+    port = SERVER_NO_ATEXIT();\n \n     kill(srvpid, SIGTERM);\n     waitpid(srvpid, NULL, 0);\n@@ -750,7 +743,7 @@ cttest_binlog_basic()\n     srv.wal.use = 1;\n     job_data_size_limit = 10;\n \n-    port = SERVER();\n+    port = SERVER_NO_ATEXIT();\n     fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 100 0\\r\\n\");\n     mustsend(fd, \"\\r\\n\");\n@@ -827,7 +820,7 @@ cttest_binlog_read()\n     srv.wal.syncrate = 0;\n     srv.wal.wantsync = 1;\n \n-    port = SERVER();\n+    port = SERVER_NO_ATEXIT();\n     fd = mustdiallocal(port);\n     mustsend(fd, \"use test\\r\\n\");\n     ckresp(fd, \"USING test\\r\\n\");\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -1,4 +1,3 @@\n-#include <stdbool.h>\n #include <stdint.h>\n #include <stdlib.h>\n #include <string.h>\n@@ -105,6 +104,7 @@ set_sig_handler()\n         exit(111);\n     }\n \n+    // This is required to trigger gcov on exit. See issue #443.\n     sa.sa_handler = exit_process;\n     r = sigaction(SIGTERM, &sa, 0);\n     if (r == -1) {\n@@ -113,20 +113,23 @@ set_sig_handler()\n     }\n }\n \n-// Kill the child process with our chosen signal to give it a chance\n+// Kill the srvpid (child process) with SIGTERM to give it a chance\n // to write gcov data to the filesystem before ct kills it with SIGKILL.\n+// Do nothing in case of srvpid==0; child was already killed.\n static void\n-kill_srv_atexit(void)\n+kill_srvpid(void)\n {\n+    if (!srvpid)\n+        return;\n     kill(srvpid, SIGTERM);\n     waitpid(srvpid, 0, 0);\n+    srvpid = 0;\n }\n \n-#define SERVER() (progname=__func__, mustforksrv(true))\n-#define SERVER_NO_ATEXIT() (progname=__func__, mustforksrv(false))\n+#define SERVER() (progname=__func__, mustforksrv())\n \n static int\n-mustforksrv(bool set_atexit)\n+mustforksrv(void)\n {\n     struct sockaddr_in addr;\n \n@@ -137,7 +140,7 @@ mustforksrv(bool set_atexit)\n     }\n \n     size_t len = sizeof(addr);\n-    int r = getsockname(srv.sock.fd, (struct sockaddr*)&addr, (socklen_t*)&len);\n+    int r = getsockname(srv.sock.fd, (struct sockaddr *)&addr, (socklen_t *)&len);\n     if (r == -1 || len > sizeof(addr)) {\n         puts(\"mustforksrv failed\");\n         exit(1);\n@@ -151,10 +154,8 @@ mustforksrv(bool set_atexit)\n     }\n \n     if (srvpid > 0) {\n-        /* When the parent (test) is finished it will send SIGTERM to the child */\n-        if (set_atexit) {\n-            atexit(kill_srv_atexit);\n-        }\n+        // On exit the parent (test) sends SIGTERM to the child.\n+        atexit(kill_srvpid);\n         printf(\"start server port=%d pid=%d\\n\", port, srvpid);\n         return port;\n     }\n@@ -705,10 +706,8 @@ cttest_binlog_empty_exit()\n     srv.wal.use = 1;\n     job_data_size_limit = 10;\n \n-    port = SERVER_NO_ATEXIT();\n-\n-    kill(srvpid, SIGTERM);\n-    waitpid(srvpid, NULL, 0);\n+    port = SERVER();\n+    kill_srvpid();\n \n     port = SERVER();\n     fd = mustdiallocal(port);\n@@ -743,14 +742,13 @@ cttest_binlog_basic()\n     srv.wal.use = 1;\n     job_data_size_limit = 10;\n \n-    port = SERVER_NO_ATEXIT();\n+    port = SERVER();\n     fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 100 0\\r\\n\");\n     mustsend(fd, \"\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n \n-    kill(srvpid, SIGTERM);\n-    waitpid(srvpid, NULL, 0);\n+    kill_srvpid();\n \n     port = SERVER();\n     fd = mustdiallocal(port);\n@@ -820,7 +818,7 @@ cttest_binlog_read()\n     srv.wal.syncrate = 0;\n     srv.wal.wantsync = 1;\n \n-    port = SERVER_NO_ATEXIT();\n+    port = SERVER();\n     fd = mustdiallocal(port);\n     mustsend(fd, \"use test\\r\\n\");\n     ckresp(fd, \"USING test\\r\\n\");\n@@ -843,8 +841,7 @@ cttest_binlog_read()\n     mustsend(fd, \"delete 2\\r\\n\");\n     ckresp(fd, \"DELETED\\r\\n\");\n \n-    kill(srvpid, SIGTERM);\n-    waitpid(srvpid, NULL, 0);\n+    kill_srvpid();\n \n     port = SERVER();\n     fd = mustdiallocal(port);\n@@ -1081,7 +1078,7 @@ cttest_binlog_v5()\n     ckrespsub(fd, \"OK \");\n     ckrespsub(fd, \"\\nkicks: 0\\n\");\n \n-    kill(srvpid, 9);\n+    kill(srvpid, SIGTERM);\n     waitpid(srvpid, NULL, 0);\n \n     srv.wal.dir = ctdir();\n", "test_patch": "", "problem_statement": "fix coverage for forked processes\nPreviously, the forked process with a server was killed by SIGKILL. \r\nThis prevented the process from writing coverage data.\r\n\r\nThis patch enables the child processes to handle the SIGUSR2 signal.\r\ntestserv.c setups a handler that flushes coverage data prior exiting.\r\nThis handler is setup only when WITHCOV is defined in CFLAGS.\r\n\r\nCoverage after the patch:\r\n\r\nlines: 64.9% (1434 out of 2209)\r\nbranches: 50.9% (649 out of 1274)\r\n\r\nUpdates #424\r\nFixes #433", "version": "1.11", "language": "C", "created_at": "2019-07-08T06:37:00Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-469", "repo": "beanstalkd/beanstalkd", "pull_number": 469, "base_commit": "ae6bcba174c784003e6fd0e8b20681a0dd843f00", "patch": "diff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -818,8 +818,8 @@ cttest_reserve_ttr_deadline_soon()\n     ckresp(prod, \"RESERVED 1 1\\r\\n\");\n     ckresp(prod, \"a\\r\\n\");\n \n-    // After 0.5s the job should be still reserved.\n-    usleep(500000);\n+    // After 0.3s the job should be still reserved.\n+    usleep(300000);\n     mustsend(prod, \"stats-job 1\\r\\n\");\n     ckrespsub(prod, \"OK \");\n     ckrespsub(prod, \"\\nstate: reserved\\n\");\n@@ -832,8 +832,9 @@ cttest_reserve_ttr_deadline_soon()\n     ckrespsub(prod, \"OK \");\n     ckrespsub(prod, \"\\nstate: reserved\\n\");\n \n-    // After 0.7s the job should time out and be ready again.\n-    usleep(700000);\n+    // We don't want to process the job, so release it and check that it's ready.\n+    mustsend(prod, \"release 1 0 0\\r\\n\");\n+    ckresp(prod, \"RELEASED\\r\\n\");\n     mustsend(prod, \"stats-job 1\\r\\n\");\n     ckrespsub(prod, \"OK \");\n     ckrespsub(prod, \"\\nstate: ready\\n\");\n", "test_patch": "", "problem_statement": "fix the deadline_soon test with explicit release of the job\nIt looks like Linux has some issues with performance or events\r\nhandling: even after 0.2s after the deadline has expired, sometimes\r\nthe job is not released automatically.\r\n\r\nThis might be related to poor performance in\r\nthroughout benchmarks on Linux: it is 60-100 times slower than macOS.", "version": "1.11", "language": "C", "created_at": "2019-07-15T14:23:03Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-476", "repo": "beanstalkd/beanstalkd", "pull_number": 476, "base_commit": "8fdb6aad986cdeb4a8f7ce812066eb935510aeae", "patch": "diff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -19,8 +19,13 @@\n #include <errno.h>\n \n static int srvpid, port, fd, size;\n-static int64 timeout = 5000000000LL; // 5s\n \n+// Global timeout set for reading response in tests; 5sec.\n+static int64 timeout = 5000000000LL;\n+\n+// Allocation pattern for wrapfalloc that replaces falloc in tests.\n+// Zero value at N-th element means that N-th call to the falloc\n+// should fail with ENOSPC result.\n static byte fallocpat[3];\n \n \n@@ -130,6 +135,9 @@ kill_srvpid(void)\n \n #define SERVER() (progname=__func__, mustforksrv())\n \n+// Forks the server storing the pid in srvpid.\n+// The parent process returns port assigned.\n+// The child process serves until the SIGTERM is received by it.\n static int\n mustforksrv(void)\n {\n@@ -885,7 +893,7 @@ cttest_reserve_ttr_deadline_soon()\n }\n \n void\n-cttest_close_frees_job()\n+cttest_close_releases_job()\n {\n     port = SERVER();\n     int cons = mustdiallocal(port);\n@@ -903,12 +911,14 @@ cttest_close_frees_job()\n     ckrespsub(prod, \"OK \");\n     ckrespsub(prod, \"\\nstate: reserved\\n\");\n \n-    // Closed consumer connection should make the job ready again.\n+    // Closed consumer connection should make the job ready sooner than ttr=100.\n     close(cons);\n \n-    mustsend(prod, \"stats-job 1\\r\\n\");\n-    ckrespsub(prod, \"OK \");\n-    ckrespsub(prod, \"\\nstate: ready\\n\");\n+    // Job should be released in less than 1s. It is low expectation,\n+    // but we do not make guarantees about how soon jobs should be released.\n+    mustsend(prod, \"reserve-with-timeout 1\\r\\n\");\n+    ckresp(prod, \"RESERVED 1 1\\r\\n\");\n+    ckresp(prod, \"a\\r\\n\");\n }\n \n void\n", "test_patch": "", "problem_statement": "fix the close_releases_job test\nOn some machines the release might not happen soon enough\r\nafter the connection holding the job was closed. Instead of\r\nadding artifical timeout I have added reserving with timeout of 1 second.\r\nTest will pass if the job is released sooner than in 1 second.\r\nIt should be enought even for the most slow machines.\r\n\r\nFixes #475", "version": "1.11", "language": "C", "created_at": "2019-07-17T15:30:41Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-439", "repo": "beanstalkd/beanstalkd", "pull_number": 439, "base_commit": "4b452b4481a6cc849cc338821a491f3566ca0cde", "patch": "diff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -935,56 +935,49 @@ fmt_stats(char *buf, size_t size, void *x)\n             node_info.nodename);\n }\n \n-/* Read a priority value from the given buffer and place it in pri.\n+/* Read a number value from the given buffer and place it in num.\n  * Update end to point to the address after the last character consumed.\n- * Pri and end can be NULL. If they are both NULL, read_pri() will do the\n+ * num and end can be NULL. If they are both NULL, read_num() will do the\n  * conversion and return the status code but not update any values. This is an\n  * easy way to check for errors.\n- * If end is NULL, read_pri will also check that the entire input string was\n+ * If end is NULL, read_num will also check that the entire input string was\n  * consumed and return an error code otherwise.\n  * Return 0 on success, or nonzero on failure.\n- * If a failure occurs, pri and end are not modified. */\n+ * If a failure occurs, num and end are not modified. */\n static int\n-read_pri(uint *pri, const char *buf, char **end)\n+read_num(uint *num, const char *buf, char **end)\n {\n+    uint tnum;\n     char *tend;\n-    uint tpri;\n \n     errno = 0;\n     while (buf[0] == ' ') buf++;\n     if (buf[0] < '0' || '9' < buf[0]) return -1;\n-    tpri = strtoul(buf, &tend, 10);\n+    tnum = strtoul(buf, &tend, 10);\n     if (tend == buf) return -1;\n     if (errno && errno != ERANGE) return -1;\n     if (!end && tend[0] != '\\0') return -1;\n \n-    if (pri) *pri = tpri;\n+    if (num) *num = tnum;\n     if (end) *end = tend;\n     return 0;\n }\n \n-/* Read a delay value from the given buffer and place it in delay.\n- * The interface and behavior are analogous to read_pri(). */\n+/* Read a delay value in seconds from the given buffer and\n+   place it in duration in nanoseconds.\n+   The interface and behavior are analogous to read_num(). */\n static int\n-read_delay(int64 *delay, const char *buf, char **end)\n+read_duration(int64 *duration, const char *buf, char **end)\n {\n     int r;\n-    uint delay_sec;\n+    uint dur_sec;\n \n-    r = read_pri(&delay_sec, buf, end);\n+    r = read_num(&dur_sec, buf, end);\n     if (r) return r;\n-    *delay = ((int64) delay_sec) * 1000000000;\n+    *duration = ((int64) dur_sec) * 1000000000;\n     return 0;\n }\n \n-/* Read a timeout value from the given buffer and place it in ttr.\n- * The interface and behavior are the same as in read_delay(). */\n-static int\n-read_ttr(int64 *ttr, const char *buf, char **end)\n-{\n-    return read_delay(ttr, buf, end);\n-}\n-\n /* Read a tube name from the given buffer moving the buffer to the name start */\n static int\n read_tube_name(char **tubename, char *buf, char **end)\n@@ -1207,13 +1200,13 @@ dispatch_cmd(Conn *c)\n \n     switch (type) {\n     case OP_PUT:\n-        r = read_pri(&pri, c->cmd + 4, &delay_buf);\n+        r = read_num(&pri, c->cmd + 4, &delay_buf);\n         if (r) return reply_msg(c, MSG_BAD_FORMAT);\n \n-        r = read_delay(&delay, delay_buf, &ttr_buf);\n+        r = read_duration(&delay, delay_buf, &ttr_buf);\n         if (r) return reply_msg(c, MSG_BAD_FORMAT);\n \n-        r = read_ttr(&ttr, ttr_buf, &size_buf);\n+        r = read_duration(&ttr, ttr_buf, &size_buf);\n         if (r) return reply_msg(c, MSG_BAD_FORMAT);\n \n         errno = 0;\n@@ -1360,10 +1353,10 @@ dispatch_cmd(Conn *c)\n         id = strtoull(c->cmd + CMD_RELEASE_LEN, &pri_buf, 10);\n         if (errno) return reply_msg(c, MSG_BAD_FORMAT);\n \n-        r = read_pri(&pri, pri_buf, &delay_buf);\n+        r = read_num(&pri, pri_buf, &delay_buf);\n         if (r) return reply_msg(c, MSG_BAD_FORMAT);\n \n-        r = read_delay(&delay, delay_buf, NULL);\n+        r = read_duration(&delay, delay_buf, NULL);\n         if (r) return reply_msg(c, MSG_BAD_FORMAT);\n         op_ct[type]++;\n \n@@ -1398,7 +1391,7 @@ dispatch_cmd(Conn *c)\n         id = strtoull(c->cmd + CMD_BURY_LEN, &pri_buf, 10);\n         if (errno) return reply_msg(c, MSG_BAD_FORMAT);\n \n-        r = read_pri(&pri, pri_buf, NULL);\n+        r = read_num(&pri, pri_buf, NULL);\n         if (r) return reply_msg(c, MSG_BAD_FORMAT);\n         op_ct[type]++;\n \n@@ -1576,7 +1569,7 @@ dispatch_cmd(Conn *c)\n         r = read_tube_name(&name, c->cmd + CMD_PAUSE_TUBE_LEN, &delay_buf);\n         if (r) return reply_msg(c, MSG_BAD_FORMAT);\n \n-        r = read_delay(&delay, delay_buf, NULL);\n+        r = read_duration(&delay, delay_buf, NULL);\n         if (r) return reply_msg(c, MSG_BAD_FORMAT);\n \n         *delay_buf = '\\0';\n", "test_patch": "", "problem_statement": "rename functions read_pri to read_num, read_ttr to read_duration\nChoose better names for these functions to reflect their purpose.\r\nRemove the read_ttr function and use \"read_duration\" in it's place.\r\n\r\nUpdates #230", "version": "1.11", "language": "C", "created_at": "2019-07-04T08:46:41Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-506", "repo": "beanstalkd/beanstalkd", "pull_number": 506, "base_commit": "a5182f602350c5b6d867a54bbe645d89a268dabb", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -213,21 +213,21 @@ struct Job {\n     int walresv;\n     int walused;\n \n-    char body[];                // written separately to the wal\n+    char *body;                 // written separately to the wal\n };\n \n struct Tube {\n     uint refs;\n     char name[MAX_TUBE_NAME_LEN];\n     Heap ready;\n     Heap delay;\n-    Ms waiting; /* set of conns */\n+    Ms waiting;                 // set of conns\n     struct stats stat;\n     uint using_ct;\n     uint watching_ct;\n     int64 pause;\n     int64 deadline_at;\n-    Job buried;\n+    Job buried;                 // linked list header\n };\n \n \n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -95,12 +95,16 @@ allocate_job(int body_size)\n     Job *j;\n \n     j = malloc(sizeof(Job) + body_size);\n-    if (!j) return twarnx(\"OOM\"), (Job *) 0;\n+    if (!j) {\n+        twarnx(\"OOM\");\n+        return (Job *) 0;\n+    }\n \n     memset(j, 0, sizeof(Job));\n     j->r.created_at = nanoseconds();\n     j->r.body_size = body_size;\n-    j->next = j->prev = j; /* not in a linked list */\n+    j->body = (char *)j + sizeof(Job);\n+    j->next = j->prev = j;      // not in a linked list\n     return j;\n }\n \n", "test_patch": "", "problem_statement": "convert body to *char and adjust the job's allocation\nThis PR updates the job body field to a `*char` pointer and adjusts `allocate_job` to initialize it correctly. Memory is still allocated and freed as a single contiguous block, ensuring no fragmentation. The change reduces compiler warnings, aiding `-pedantic` compatibility, and shows minor performance improvements in microbenchmarks, though significance is uncertain due to limited benchmarking.  \n\nBefore:  \n`ctbench_make_job` 272 ns/op; `put_delete_1k` 351k ns/op (3.06 MB/s); `put_delete_8k` 413k ns/op (24.00 MB/s)  \nAfter:  \n`ctbench_make_job` 254 ns/op; `put_delete_1k` 320k ns/op (4.83 MB/s); `put_delete_8k` 371k ns/op (37.72 MB/s)  \n\nImprovements in `make_job` and `put_delete` suggest slight gains, but variance is possible. Code is now cleaner and more maintainable. Fixes #487.", "version": "1.11", "language": "C", "created_at": "2019-07-27T19:41:56Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-508", "repo": "beanstalkd/beanstalkd", "pull_number": 508, "base_commit": "9f8f5a872183a48ffc21f636cfb4d13d8d8d507b", "patch": "diff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -87,14 +87,6 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define MSG_INSERTED_FMT \"INSERTED %\"PRIu64\"\\r\\n\"\n #define MSG_NOT_IGNORED \"NOT_IGNORED\\r\\n\"\n \n-#define MSG_NOTFOUND_LEN CONSTSTRLEN(MSG_NOTFOUND)\n-#define MSG_DELETED_LEN CONSTSTRLEN(MSG_DELETED)\n-#define MSG_TOUCHED_LEN CONSTSTRLEN(MSG_TOUCHED)\n-#define MSG_RELEASED_LEN CONSTSTRLEN(MSG_RELEASED)\n-#define MSG_BURIED_LEN CONSTSTRLEN(MSG_BURIED)\n-#define MSG_KICKED_LEN CONSTSTRLEN(MSG_KICKED)\n-#define MSG_NOT_IGNORED_LEN CONSTSTRLEN(MSG_NOT_IGNORED)\n-\n #define MSG_OUT_OF_MEMORY \"OUT_OF_MEMORY\\r\\n\"\n #define MSG_INTERNAL_ERROR \"INTERNAL_ERROR\\r\\n\"\n #define MSG_DRAINING \"DRAINING\\r\\n\"\n@@ -1298,7 +1290,7 @@ dispatch_cmd(Conn *c)\n             j = job_copy(c->use->ready.data[0]);\n         }\n \n-        if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+        if (!j) return reply_msg(c, MSG_NOTFOUND);\n \n         reply_job(c, j, MSG_FOUND);\n         break;\n@@ -1313,7 +1305,7 @@ dispatch_cmd(Conn *c)\n             j = job_copy(c->use->delay.data[0]);\n         }\n \n-        if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+        if (!j) return reply_msg(c, MSG_NOTFOUND);\n \n         reply_job(c, j, MSG_FOUND);\n         break;\n@@ -1326,7 +1318,7 @@ dispatch_cmd(Conn *c)\n \n         j = job_copy(buried_job_p(c->use)? j = c->use->buried.next : NULL);\n \n-        if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+        if (!j) return reply_msg(c, MSG_NOTFOUND);\n \n         reply_job(c, j, MSG_FOUND);\n         break;\n@@ -1341,7 +1333,7 @@ dispatch_cmd(Conn *c)\n          * free the copy when it's done sending, in the \"reset_conn\" function. */\n         j = job_copy(peek_job(id));\n \n-        if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+        if (!j) return reply_msg(c, MSG_NOTFOUND);\n \n         reply_job(c, j, MSG_FOUND);\n         break;\n@@ -1379,7 +1371,7 @@ dispatch_cmd(Conn *c)\n             remove_delayed_job(j);\n \n         if (!j)\n-            return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+            return reply_msg(c, MSG_NOTFOUND);\n \n         j->tube->stat.total_delete_ct++;\n \n@@ -1391,7 +1383,7 @@ dispatch_cmd(Conn *c)\n         if (!r)\n             return reply_serr(c, MSG_INTERNAL_ERROR);\n \n-        reply(c, MSG_DELETED, MSG_DELETED_LEN, STATE_SENDWORD);\n+        reply_msg(c, MSG_DELETED);\n         break;\n     case OP_RELEASE:\n         if (read_u64(&id, c->cmd + CMD_RELEASE_LEN, &pri_buf))\n@@ -1407,7 +1399,7 @@ dispatch_cmd(Conn *c)\n         j = remove_reserved_job(c, job_find(id));\n \n         if (!j)\n-            return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+            return reply_msg(c, MSG_NOTFOUND);\n \n         /* We want to update the delay deadline on disk, so reserve space for\n          * that. */\n@@ -1426,12 +1418,12 @@ dispatch_cmd(Conn *c)\n         if (r < 0)\n             return reply_serr(c, MSG_INTERNAL_ERROR);\n         if (r == 1) {\n-            return reply(c, MSG_RELEASED, MSG_RELEASED_LEN, STATE_SENDWORD);\n+            return reply_msg(c, MSG_RELEASED);\n         }\n \n         /* out of memory trying to grow the queue, so it gets buried */\n         bury_job(c->srv, j, 0);\n-        reply(c, MSG_BURIED, MSG_BURIED_LEN, STATE_SENDWORD);\n+        reply_msg(c, MSG_BURIED);\n         break;\n     case OP_BURY:\n         if (read_u64(&id, c->cmd + CMD_BURY_LEN, &pri_buf))\n@@ -1445,13 +1437,13 @@ dispatch_cmd(Conn *c)\n         j = remove_reserved_job(c, job_find(id));\n \n         if (!j)\n-            return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+            return reply_msg(c, MSG_NOTFOUND);\n \n         j->r.pri = pri;\n         r = bury_job(c->srv, j, 1);\n         if (!r)\n             return reply_serr(c, MSG_INTERNAL_ERROR);\n-        reply(c, MSG_BURIED, MSG_BURIED_LEN, STATE_SENDWORD);\n+        reply_msg(c, MSG_BURIED);\n         break;\n     case OP_KICK:\n         errno = 0;\n@@ -1474,13 +1466,13 @@ dispatch_cmd(Conn *c)\n \n         j = job_find(id);\n         if (!j)\n-            return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+            return reply_msg(c, MSG_NOTFOUND);\n \n         if ((j->r.state == Buried && kick_buried_job(c->srv, j)) ||\n             (j->r.state == Delayed && kick_delayed_job(c->srv, j))) {\n-            reply(c, MSG_KICKED, MSG_KICKED_LEN, STATE_SENDWORD);\n+            reply_msg(c, MSG_KICKED);\n         } else {\n-            return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+            return reply_msg(c, MSG_NOTFOUND);\n         }\n         break;\n     case OP_TOUCH:\n@@ -1492,9 +1484,9 @@ dispatch_cmd(Conn *c)\n         j = touch_job(c, job_find(id));\n \n         if (j) {\n-            reply(c, MSG_TOUCHED, MSG_TOUCHED_LEN, STATE_SENDWORD);\n+            reply_msg(c, MSG_TOUCHED);\n         } else {\n-            return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+            return reply_msg(c, MSG_NOTFOUND);\n         }\n         break;\n     case OP_STATS:\n@@ -1515,7 +1507,7 @@ dispatch_cmd(Conn *c)\n \n         j = peek_job(id);\n         if (!j)\n-            return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+            return reply_msg(c, MSG_NOTFOUND);\n \n         if (!j->tube)\n             return reply_serr(c, MSG_INTERNAL_ERROR);\n", "test_patch": "", "problem_statement": "Cleanup message length macros\nFor consistency, use `reply_msg` macro instead.", "version": "1.11", "language": "C", "created_at": "2019-07-28T16:06:19Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-460", "repo": "beanstalkd/beanstalkd", "pull_number": 460, "base_commit": "f7803cab05dbbb21f606555676e1ac559afc1bd5", "patch": "diff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -1,11 +1,11 @@\n+#include \"dat.h\"\n+#include <errno.h>\n+#include <limits.h>\n #include <stdint.h>\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n-#include <errno.h>\n-#include <limits.h>\n #include <unistd.h>\n-#include \"dat.h\"\n \n #define SAFETY_MARGIN (1000000000) /* 1 second */\n \n\ndiff --git a/darwin.c b/darwin.c\n--- a/darwin.c\n+++ b/darwin.c\n@@ -1,3 +1,4 @@\n+#include \"dat.h\"\n #include <stdint.h>\n #include <sys/types.h>\n #include <unistd.h>\n@@ -6,7 +7,6 @@\n #include <errno.h>\n #include <sys/event.h>\n #include <sys/time.h>\n-#include \"dat.h\"\n \n enum\n {\n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -1,6 +1,5 @@\n-// Requirements:\n-// #include <stdint.h>\n-// #include <stdlib.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n \n typedef unsigned char uchar;\n typedef uchar         byte;\n@@ -10,18 +9,10 @@ typedef uint32_t      uint32;\n typedef int64_t       int64;\n typedef uint64_t      uint64;\n \n-#define int8_t   do_not_use_int8_t\n-#define uint8_t  do_not_use_uint8_t\n-#define int32_t  do_not_use_int32_t\n-#define uint32_t do_not_use_uint32_t\n-#define int64_t  do_not_use_int64_t\n-#define uint64_t do_not_use_uint64_t\n-\n /* TODO: typedefs of ms, job and tube should not hide the pointer.\n    Make them similar to other typedefs (Conn, Heap).\n    Maybem move each typedef next to the corresponding struct definition.\n    See issue #458. */\n-\n typedef struct ms     *ms;\n typedef struct job    *job;\n typedef struct tube   *tube;\n\ndiff --git a/file.c b/file.c\n--- a/file.c\n+++ b/file.c\n@@ -1,3 +1,4 @@\n+#include \"dat.h\"\n #include <stdint.h>\n #include <inttypes.h>\n #include <stddef.h>\n@@ -10,7 +11,6 @@\n #include <fcntl.h>\n #include <errno.h>\n #include <string.h>\n-#include \"dat.h\"\n \n static int  readrec(File*, job, int*);\n static int  readrec5(File*, job, int*);\n\ndiff --git a/heap.c b/heap.c\n--- a/heap.c\n+++ b/heap.c\n@@ -1,7 +1,7 @@\n+#include \"dat.h\"\n #include <stdint.h>\n #include <stdlib.h>\n #include <string.h>\n-#include \"dat.h\"\n \n \n static void\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -1,7 +1,7 @@\n+#include \"dat.h\"\n #include <stdint.h>\n #include <stdlib.h>\n #include <string.h>\n-#include \"dat.h\"\n \n static uint64 next_id = 1;\n \n\ndiff --git a/linux.c b/linux.c\n--- a/linux.c\n+++ b/linux.c\n@@ -1,12 +1,13 @@\n #define _XOPEN_SOURCE 600\n+\n+#include \"dat.h\"\n #include <unistd.h>\n #include <sys/types.h>\n #include <stdint.h>\n #include <fcntl.h>\n #include <stdlib.h>\n #include <errno.h>\n #include <sys/epoll.h>\n-#include \"dat.h\"\n \n #ifndef EPOLLRDHUP\n #define EPOLLRDHUP 0x2000\n\ndiff --git a/main.c b/main.c\n--- a/main.c\n+++ b/main.c\n@@ -1,3 +1,4 @@\n+#include \"dat.h\"\n #include <stdint.h>\n #include <signal.h>\n #include <stdio.h>\n@@ -7,7 +8,6 @@\n #include <unistd.h>\n #include <pwd.h>\n #include <fcntl.h>\n-#include \"dat.h\"\n \n static void\n su(const char *user) \n\ndiff --git a/ms.c b/ms.c\n--- a/ms.c\n+++ b/ms.c\n@@ -1,7 +1,7 @@\n+#include \"dat.h\"\n #include <stdint.h>\n #include <string.h>\n #include <stdlib.h>\n-#include \"dat.h\"\n \n void\n ms_init(ms a, ms_event_fn oninsert, ms_event_fn onremove)\n\ndiff --git a/net.c b/net.c\n--- a/net.c\n+++ b/net.c\n@@ -1,3 +1,5 @@\n+#include \"dat.h\"\n+#include \"sd-daemon.h\"\n #include <netdb.h>\n #include <stdio.h>\n #include <unistd.h>\n@@ -7,8 +9,6 @@\n #include <sys/socket.h>\n #include <netinet/in.h>\n #include <netinet/tcp.h>\n-#include \"dat.h\"\n-#include \"sd-daemon.h\"\n \n int\n make_server_socket(char *host, char *port)\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -1,3 +1,4 @@\n+#include \"dat.h\"\n #include <stdint.h>\n #include <stdlib.h>\n #include <stdio.h>\n@@ -13,7 +14,6 @@\n #include <netinet/in.h>\n #include <inttypes.h>\n #include <stdarg.h>\n-#include \"dat.h\"\n \n /* job body cannot be greater than this many bytes long */\n size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n\ndiff --git a/serv.c b/serv.c\n--- a/serv.c\n+++ b/serv.c\n@@ -1,7 +1,7 @@\n+#include \"dat.h\"\n #include <stdint.h>\n #include <stdlib.h>\n #include <sys/socket.h>\n-#include \"dat.h\"\n \n struct Server srv = {\n     .port = Portdef,\n\ndiff --git a/testheap.c b/testheap.c\n--- a/testheap.c\n+++ b/testheap.c\n@@ -1,10 +1,10 @@\n+#include \"dat.h\"\n #include <stdint.h>\n #include <stdlib.h>\n #include <stdio.h>\n #include <string.h>\n #include <sys/time.h>\n #include \"ct/ct.h\"\n-#include \"dat.h\"\n \n \n void\n\ndiff --git a/testjobs.c b/testjobs.c\n--- a/testjobs.c\n+++ b/testjobs.c\n@@ -1,10 +1,10 @@\n+#include \"ct/ct.h\"\n+#include \"dat.h\"\n #include <stdint.h>\n #include <stdlib.h>\n #include <stdio.h>\n #include <string.h>\n #include <sys/time.h>\n-#include \"ct/ct.h\"\n-#include \"dat.h\"\n \n static tube default_tube;\n \n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -1,3 +1,5 @@\n+#include \"ct/ct.h\"\n+#include \"dat.h\"\n #include <stdint.h>\n #include <stdlib.h>\n #include <string.h>\n@@ -15,8 +17,6 @@\n #include <fcntl.h>\n #include <sys/wait.h>\n #include <errno.h>\n-#include \"ct/ct.h\"\n-#include \"dat.h\"\n \n static int srvpid, port, fd, size;\n static int64 timeout = 5000000000LL; // 5s\n\ndiff --git a/testutil.c b/testutil.c\n--- a/testutil.c\n+++ b/testutil.c\n@@ -1,11 +1,11 @@\n+#include \"ct/ct.h\"\n+#include \"dat.h\"\n #include <stdint.h>\n #include <stdlib.h>\n #include <stdio.h>\n #include <string.h>\n #include <sys/time.h>\n #include <unistd.h>\n-#include \"ct/ct.h\"\n-#include \"dat.h\"\n \n void\n cttest_allocf()\n\ndiff --git a/time.c b/time.c\n--- a/time.c\n+++ b/time.c\n@@ -1,7 +1,7 @@\n+#include \"dat.h\"\n #include <stdint.h>\n #include <stdlib.h>\n #include <sys/time.h>\n-#include \"dat.h\"\n \n int64\n nanoseconds(void)\n\ndiff --git a/tube.c b/tube.c\n--- a/tube.c\n+++ b/tube.c\n@@ -1,7 +1,7 @@\n+#include \"dat.h\"\n #include <stdint.h>\n #include <stdlib.h>\n #include <string.h>\n-#include \"dat.h\"\n \n struct ms tubes;\n \n\ndiff --git a/util.c b/util.c\n--- a/util.c\n+++ b/util.c\n@@ -1,11 +1,11 @@\n+#include \"dat.h\"\n #include <stdint.h>\n #include <stdlib.h>\n #include <errno.h>\n #include <stdio.h>\n #include <string.h>\n #include <stdarg.h>\n #include \"sd-daemon.h\"\n-#include \"dat.h\"\n \n const char *progname;\n \n\ndiff --git a/walg.c b/walg.c\n--- a/walg.c\n+++ b/walg.c\n@@ -1,3 +1,4 @@\n+#include \"dat.h\"\n #include <stdint.h>\n #include <stdlib.h>\n #include <stdio.h>\n@@ -9,7 +10,6 @@\n #include <sys/uio.h>\n #include <sys/stat.h>\n #include <limits.h>\n-#include \"dat.h\"\n \n static int reserve(Wal *w, int n);\n \n", "test_patch": "", "problem_statement": "include dependent headers in the dat.h file\nBefore this fix my editor was hinting the `*_t` types as undefined. This was confusing.\r\n\r\nI have rearranged dat.h and sd-daemon.h before other headers to verify this.\r\nI have removed redefinitions of *_t types because it was producing redefinitions errors.", "version": "1.11", "language": "C", "created_at": "2019-07-12T11:08:14Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-495", "repo": "beanstalkd/beanstalkd", "pull_number": 495, "base_commit": "8a0987b1eb35f56a8ca06279678ce14c1032bce5", "patch": "diff --git a/testheap.c b/testheap.c\n--- a/testheap.c\n+++ b/testheap.c\n@@ -21,6 +21,10 @@ cttest_heap_insert_one()\n     heapinsert(&h, j);\n     assertf(h.len == 1, \"h should contain one item.\");\n     assertf(j->heap_index == 0, \"should match\");\n+\n+    assert(heapremove(&h, 0));\n+    job_free(j);\n+    free(h.data);\n }\n \n void\n@@ -40,6 +44,9 @@ cttest_heap_insert_and_remove_one()\n     job got = heapremove(&h, 0);\n     assertf(got == j1, \"j1 should come back out\");\n     assertf(h.len == 0, \"h should be empty.\");\n+\n+    free(h.data);\n+    job_free(j1);\n }\n \n void\n@@ -84,6 +91,11 @@ cttest_heap_priority()\n \n     j = heapremove(&h, 0);\n     assertf(j == j3, \"j3 should come out third.\");\n+\n+    free(h.data);\n+    job_free(j1);\n+    job_free(j2);\n+    job_free(j3);\n }\n \n void\n@@ -131,6 +143,11 @@ cttest_heap_fifo_property()\n \n     j = heapremove(&h, 0);\n     assertf(j == j3c, \"j3c should come out third.\");\n+\n+    free(h.data);\n+    job_free(j3a);\n+    job_free(j3b);\n+    job_free(j3c);\n }\n \n void\n@@ -156,7 +173,10 @@ cttest_heap_many_jobs()\n         j = heapremove(&h, 0);\n         assertf(j->r.pri >= last_pri, \"should come out in order\");\n         last_pri = j->r.pri;\n+        assert(j);\n+        job_free(j);\n     }\n+    free(h.data);\n }\n \n void\n@@ -166,7 +186,8 @@ cttest_heap_remove_k()\n         .less = job_pri_less,\n         .setpos = job_setpos,\n     };\n-    const int n = 20;\n+    const int n = 50;\n+    const int mid = 25;\n \n     int c, i;\n     for (c = 0; c < 50; c++) {\n@@ -178,16 +199,21 @@ cttest_heap_remove_k()\n         }\n \n         /* remove one from the middle */\n-        heapremove(&h, 25);\n+        job j0 = heapremove(&h, mid);\n+        assertf(j0, \"j0 should not be NULL\");\n+        job_free(j0);\n \n         /* now make sure the rest are still a valid heap */\n         uint last_pri = 0;\n         for (i = 1; i < n; i++) {\n             job j = heapremove(&h, 0);\n             assertf(j->r.pri >= last_pri, \"should come out in order\");\n             last_pri = j->r.pri;\n+            assertf(j, \"j should not be NULL\");\n+            job_free(j);\n         }\n     }\n+    free(h.data);\n }\n \n void\n\ndiff --git a/testms.c b/testms.c\n--- a/testms.c\n+++ b/testms.c\n@@ -17,14 +17,15 @@ cttest_ms_append()\n \n     int ok = ms_append(a, &i);\n     assertf(a->len == 1, \"a should contain one item\");\n-    assertf(ok, \"should be added\"); \n+    assertf(ok, \"should be added\");\n \n     ok = ms_append(a, &i);\n     assertf(a->len == 2, \"a should contain two items\");\n     assertf(ok, \"should be added\");\n \n     ms_clear(a);\n     assertf(a->len == 0, \"a should be empty\");\n+    free(a->items);\n     free(a);\n }\n \n@@ -49,6 +50,7 @@ cttest_ms_remove()\n     assertf(!ok, \"i was already removed\");\n \n     assertf(a->len == 0, \"a should be empty\");\n+    free(a->items);\n     free(a);\n }\n \n@@ -69,6 +71,7 @@ cttest_ms_contains()\n     assertf(!ok, \"j should not be in a\");\n \n     ms_clear(a);\n+    free(a->items);\n     free(a);\n }\n \n@@ -81,6 +84,7 @@ cttest_ms_clear_empty()\n \n     ms_clear(a);\n     assertf(a->len == 0, \"a should be empty\");\n+    free(a->items);\n     free(a);\n }\n \n@@ -106,6 +110,7 @@ cttest_ms_take()\n     n = (int *)ms_take(a);\n     assertf(n == NULL, \"n should be NULL; ms is empty\");\n \n+    free(a->items);\n     free(a);\n }\n \n@@ -128,6 +133,7 @@ cttest_ms_take_sequence()\n         assert(*got == e[i]);\n     }\n \n+    free(a->items);\n     free(a);\n }\n \n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -1218,7 +1218,6 @@ void\n cttest_binlog_size_limit()\n {\n     int i = 0;\n-    char *b2;\n     int gotsize;\n \n     size = 1024;\n@@ -1230,17 +1229,22 @@ cttest_binlog_size_limit()\n \n     port = SERVER();\n     fd = mustdiallocal(port);\n-    b2 = fmtalloc(\"%s/binlog.2\", ctdir());\n+    char *b2 = fmtalloc(\"%s/binlog.2\", ctdir());\n     while (!exist(b2)) {\n+        char *exp = fmtalloc(\"INSERTED %d\\r\\n\", ++i);\n         mustsend(fd, \"put 0 0 100 50\\r\\n\");\n         mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n-        ckresp(fd, fmtalloc(\"INSERTED %d\\r\\n\", ++i));\n+        ckresp(fd, exp);\n+        free(exp);\n     }\n \n-    gotsize = filesize(fmtalloc(\"%s/binlog.1\", ctdir()));\n+    char *b1 = fmtalloc(\"%s/binlog.1\", ctdir());\n+    gotsize = filesize(b1);\n     assertf(gotsize == size, \"binlog.1 %d != %d\", gotsize, size);\n     gotsize = filesize(b2);\n     assertf(gotsize == size, \"binlog.2 %d != %d\", gotsize, size);\n+    free(b1);\n+    free(b2);\n }\n \n void\n@@ -1258,13 +1262,17 @@ cttest_binlog_allocation()\n     port = SERVER();\n     fd = mustdiallocal(port);\n     for (i = 1; i <= 96; i++) {\n+        char *exp = fmtalloc(\"INSERTED %d\\r\\n\", i);\n         mustsend(fd, \"put 0 0 120 22\\r\\n\");\n         mustsend(fd, \"job payload xxxxxxxxxx\\r\\n\");\n-        ckresp(fd, fmtalloc(\"INSERTED %d\\r\\n\", i));\n+        ckresp(fd, exp);\n+        free(exp);\n     }\n     for (i = 1; i <= 96; i++) {\n-        mustsend(fd, fmtalloc(\"delete %d\\r\\n\", i));\n+        char *exp = fmtalloc(\"delete %d\\r\\n\", i);\n+        mustsend(fd, exp);\n         ckresp(fd, \"DELETED\\r\\n\");\n+        free(exp);\n     }\n }\n \n@@ -1424,7 +1432,9 @@ cttest_binlog_disk_full_delete()\n     mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n     ckresp(fd, \"OUT_OF_MEMORY\\r\\n\");\n \n-    assert(exist(fmtalloc(\"%s/binlog.1\", ctdir())));\n+    char *b1 = fmtalloc(\"%s/binlog.1\", ctdir());\n+    assert(exist(b1));\n+    free(b1);\n \n     mustsend(fd, \"delete 1\\r\\n\");\n     ckresp(fd, \"DELETED\\r\\n\");\n\ndiff --git a/testutil.c b/testutil.c\n--- a/testutil.c\n+++ b/testutil.c\n@@ -14,6 +14,7 @@ cttest_allocf()\n \n     got = fmtalloc(\"hello, %s %d\", \"world\", 5);\n     assertf(strcmp(\"hello, world 5\", got) == 0, \"got \\\"%s\\\"\", got);\n+    free(got);\n }\n \n void\n", "test_patch": "", "problem_statement": "fix leaks in heap, ms, util tests\nAdditionally, this patch fixes a bug in the cttest_heap_remove_k test. Leak in the server tests are not fixed and require an additional scrutiny. \r\n\r\nUpdates #382", "version": "1.11", "language": "C", "created_at": "2019-07-26T08:52:48Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-514", "repo": "beanstalkd/beanstalkd", "pull_number": 514, "base_commit": "7be3662bb11b566bf1a7de5048859cd061a8dce8", "patch": "diff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -175,7 +175,7 @@ connsoonestjob(Conn *c)\n \n     if (soonest == NULL) {\n         for (j = c->reserved_jobs.next; j != &c->reserved_jobs; j = j->next) {\n-            if (j->r.deadline_at <= (soonest ? : j)->r.deadline_at)\n+            if (j->r.deadline_at <= (soonest ? soonest : j)->r.deadline_at)\n                 soonest = j;\n         }\n     }\n\ndiff --git a/ms.c b/ms.c\n--- a/ms.c\n+++ b/ms.c\n@@ -16,7 +16,9 @@ static void\n grow(Ms *a)\n {\n     void **nitems;\n-    size_t ncap = (a->cap << 1) ? : 1;\n+    size_t ncap = a->cap << 1;\n+    if (!ncap)\n+        ncap = 1;\n \n     nitems = malloc(ncap * sizeof(void *));\n     if (!nitems)\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -1364,11 +1364,16 @@ dispatch_cmd(Conn *c)\n             return reply_msg(c, MSG_BAD_FORMAT);\n         op_ct[type]++;\n \n-        j = job_find(id);\n-        j = remove_reserved_job(c, j) ? :\n-            remove_ready_job(j) ? :\n-            remove_buried_job(j) ? :\n-            remove_delayed_job(j);\n+        {\n+            Job *jf = job_find(id);\n+            j = remove_reserved_job(c, jf);\n+            if (!j)\n+                j = remove_ready_job(jf);\n+            if (!j)\n+                j = remove_buried_job(jf);\n+            if (!j)\n+                j = remove_delayed_job(jf);\n+        }\n \n         if (!j)\n             return reply_msg(c, MSG_NOTFOUND);\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -672,6 +672,24 @@ cttest_delete_ready()\n     ckresp(fd, \"DELETED\\r\\n\");\n }\n \n+void\n+cttest_delete_reserved_by_other()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"a\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+\n+    int o = mustdiallocal(port);\n+    mustsend(o, \"reserve\\r\\n\");\n+    ckresp(o, \"RESERVED 1 1\\r\\n\");\n+    ckresp(o, \"a\\r\\n\");\n+\n+    mustsend(fd, \"delete 1\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+}\n+\n void\n cttest_delete_bad_format()\n {\n\ndiff --git a/tube.c b/tube.c\n--- a/tube.c\n+++ b/tube.c\n@@ -95,6 +95,9 @@ tube_find(const char *name)\n Tube *\n tube_find_or_make(const char *name)\n {\n-    return tube_find(name) ? : make_and_insert_tube(name);\n+    Tube *t = tube_find(name);\n+    if (t)\n+        return t;\n+    return make_and_insert_tube(name);\n }\n \n", "test_patch": "", "problem_statement": "fix ternary operators to not use GNU extension\nDiscovered by -std=c99 -pedantic", "version": "1.11", "language": "C", "created_at": "2019-07-29T19:29:58Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-489", "repo": "beanstalkd/beanstalkd", "pull_number": 489, "base_commit": "c25be6b7948ec0c9c3e5a2cd5373613d0f162eb7", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -71,9 +71,6 @@ typedef int(FAlloc)(int, int);\n // The width is restricted by Jobrec.body_size that is int32.\n #define JOB_DATA_SIZE_LIMIT_MAX 1073741824\n \n-// Maximum value (uint32) allowed in pri, delay and ttr parameters\n-#define MAX_UINT32 4294967295\n-\n // Use this macro to designate unused parameters in functions.\n #define UNUSED_PARAMETER(x) (void)(x)\n \n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -34,7 +34,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define CMD_RELEASE \"release \"\n #define CMD_BURY \"bury \"\n #define CMD_KICK \"kick \"\n-#define CMD_JOBKICK \"kick-job \"\n+#define CMD_KICKJOB \"kick-job \"\n #define CMD_TOUCH \"touch \"\n #define CMD_STATS \"stats\"\n #define CMD_STATSJOB \"stats-job \"\n@@ -60,7 +60,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define CMD_RELEASE_LEN CONSTSTRLEN(CMD_RELEASE)\n #define CMD_BURY_LEN CONSTSTRLEN(CMD_BURY)\n #define CMD_KICK_LEN CONSTSTRLEN(CMD_KICK)\n-#define CMD_JOBKICK_LEN CONSTSTRLEN(CMD_JOBKICK)\n+#define CMD_KICKJOB_LEN CONSTSTRLEN(CMD_KICKJOB)\n #define CMD_TOUCH_LEN CONSTSTRLEN(CMD_TOUCH)\n #define CMD_STATS_LEN CONSTSTRLEN(CMD_STATS)\n #define CMD_STATSJOB_LEN CONSTSTRLEN(CMD_STATSJOB)\n@@ -135,7 +135,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define OP_TOUCH 21\n #define OP_QUIT 22\n #define OP_PAUSE_TUBE 23\n-#define OP_JOBKICK 24\n+#define OP_KICKJOB 24\n #define TOTAL_OPS 25\n \n #define STATS_FMT \"---\\n\" \\\n@@ -273,7 +273,7 @@ static const char * op_names[] = {\n     CMD_TOUCH,\n     CMD_QUIT,\n     CMD_PAUSE_TUBE,\n-    CMD_JOBKICK,\n+    CMD_KICKJOB,\n };\n \n static job remove_buried_job(job j);\n@@ -752,7 +752,7 @@ which_cmd(Conn *c)\n     TEST_CMD(c->cmd, CMD_RELEASE, OP_RELEASE);\n     TEST_CMD(c->cmd, CMD_BURY, OP_BURY);\n     TEST_CMD(c->cmd, CMD_KICK, OP_KICK);\n-    TEST_CMD(c->cmd, CMD_JOBKICK, OP_JOBKICK);\n+    TEST_CMD(c->cmd, CMD_KICKJOB, OP_KICKJOB);\n     TEST_CMD(c->cmd, CMD_TOUCH, OP_TOUCH);\n     TEST_CMD(c->cmd, CMD_STATSJOB, OP_STATSJOB);\n     TEST_CMD(c->cmd, CMD_STATS_TUBE, OP_STATS_TUBE);\n@@ -939,19 +939,19 @@ fmt_stats(char *buf, size_t size, void *x)\n }\n \n /* Read an integer from the given buffer and place it in num.\n- * Parsed integer should fit into uint32.\n+ * Parsed integer should fit into uint64.\n  * Update end to point to the address after the last character consumed.\n- * num and end can be NULL. If they are both NULL, read_num() will do the\n+ * num and end can be NULL. If they are both NULL, read_u64() will do the\n  * conversion and return the status code but not update any values.\n  * This is an easy way to check for errors.\n- * If end is NULL, read_num will also check that the entire input string was\n- * consumed and return an error code otherwise.\n+ * If end is NULL, read_u64() will also check that the entire input string\n+ * was consumed and return an error code otherwise.\n  * Return 0 on success, or nonzero on failure.\n  * If a failure occurs, num and end are not modified. */\n static int\n-read_num(uint32 *num, const char *buf, char **end)\n+read_u64(uint64 *num, const char *buf, char **end)\n {\n-    uint64 tnum;\n+    uintmax_t tnum;\n     char *tend;\n \n     errno = 0;\n@@ -962,11 +962,38 @@ read_num(uint32 *num, const char *buf, char **end)\n     tnum = strtoumax(buf, &tend, 10);\n     if (tend == buf)\n         return -1;\n-    if (errno && errno != ERANGE)\n+    if (errno)\n         return -1;\n     if (!end && tend[0] != '\\0')\n         return -1;\n-    if (tnum > MAX_UINT32)\n+    if (tnum > UINT64_MAX)\n+        return -1;\n+\n+    if (num) *num = (uint64)tnum;\n+    if (end) *end = tend;\n+    return 0;\n+}\n+\n+// Indentical to read_u64() but instead reads into uint32.\n+static int\n+read_u32(uint32 *num, const char *buf, char **end)\n+{\n+    uintmax_t tnum;\n+    char *tend;\n+\n+    errno = 0;\n+    while (buf[0] == ' ')\n+        buf++;\n+    if (buf[0] < '0' || '9' < buf[0])\n+        return -1;\n+    tnum = strtoumax(buf, &tend, 10);\n+    if (tend == buf)\n+        return -1;\n+    if (errno)\n+        return -1;\n+    if (!end && tend[0] != '\\0')\n+        return -1;\n+    if (tnum > UINT32_MAX)\n         return -1;\n \n     if (num) *num = (uint32)tnum;\n@@ -976,14 +1003,14 @@ read_num(uint32 *num, const char *buf, char **end)\n \n /* Read a delay value in seconds from the given buffer and\n    place it in duration in nanoseconds.\n-   The interface and behavior are analogous to read_num(). */\n+   The interface and behavior are analogous to read_u32(). */\n static int\n read_duration(int64 *duration, const char *buf, char **end)\n {\n     int r;\n     uint32 dur_sec;\n \n-    r = read_num(&dur_sec, buf, end);\n+    r = read_u32(&dur_sec, buf, end);\n     if (r)\n         return r;\n     *duration = ((int64) dur_sec) * 1000000000;\n@@ -1214,7 +1241,7 @@ dispatch_cmd(Conn *c)\n \n     switch (type) {\n     case OP_PUT:\n-        if (read_num(&pri, c->cmd + 4, &delay_buf))\n+        if (read_u32(&pri, c->cmd + 4, &delay_buf))\n             return reply_msg(c, MSG_BAD_FORMAT);\n \n         if (read_duration(&delay, delay_buf, &ttr_buf))\n@@ -1223,7 +1250,7 @@ dispatch_cmd(Conn *c)\n         if (read_duration(&ttr, ttr_buf, &size_buf))\n             return reply_msg(c, MSG_BAD_FORMAT);\n \n-        if (read_num(&body_size, size_buf, &end_buf))\n+        if (read_u32(&body_size, size_buf, &end_buf))\n             return reply_msg(c, MSG_BAD_FORMAT);\n \n         op_ct[type]++;\n@@ -1302,9 +1329,9 @@ dispatch_cmd(Conn *c)\n         reply_job(c, j, MSG_FOUND);\n         break;\n     case OP_PEEKJOB:\n-        errno = 0;\n-        id = strtoull(c->cmd + CMD_PEEKJOB_LEN, &end_buf, 10);\n-        if (errno) return reply_msg(c, MSG_BAD_FORMAT);\n+        if (read_u64(&id, c->cmd + CMD_PEEKJOB_LEN, NULL))\n+            return reply_msg(c, MSG_BAD_FORMAT);\n+\n         op_ct[type]++;\n \n         /* So, peek is annoying, because some other connection might free the\n@@ -1319,7 +1346,8 @@ dispatch_cmd(Conn *c)\n     case OP_RESERVE_TIMEOUT:\n         errno = 0;\n         timeout = strtol(c->cmd + CMD_RESERVE_TIMEOUT_LEN, &end_buf, 10);\n-        if (errno) return reply_msg(c, MSG_BAD_FORMAT);\n+        if (errno)\n+            return reply_msg(c, MSG_BAD_FORMAT);\n     case OP_RESERVE: /* FALLTHROUGH */\n         /* don't allow trailing garbage */\n         if (type == OP_RESERVE && c->cmd_len != CMD_RESERVE_LEN + 2) {\n@@ -1338,9 +1366,8 @@ dispatch_cmd(Conn *c)\n         process_queue();\n         break;\n     case OP_DELETE:\n-        errno = 0;\n-        id = strtoull(c->cmd + CMD_DELETE_LEN, &end_buf, 10);\n-        if (errno) return reply_msg(c, MSG_BAD_FORMAT);\n+        if (read_u64(&id, c->cmd + CMD_DELETE_LEN, NULL))\n+            return reply_msg(c, MSG_BAD_FORMAT);\n         op_ct[type]++;\n \n         j = job_find(id);\n@@ -1349,7 +1376,8 @@ dispatch_cmd(Conn *c)\n             remove_buried_job(j) ? :\n             remove_delayed_job(j);\n \n-        if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+        if (!j)\n+            return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n \n         j->tube->stat.total_delete_ct++;\n \n@@ -1358,31 +1386,33 @@ dispatch_cmd(Conn *c)\n         walmaint(&c->srv->wal);\n         job_free(j);\n \n-        if (!r) return reply_serr(c, MSG_INTERNAL_ERROR);\n+        if (!r)\n+            return reply_serr(c, MSG_INTERNAL_ERROR);\n \n         reply(c, MSG_DELETED, MSG_DELETED_LEN, STATE_SENDWORD);\n         break;\n     case OP_RELEASE:\n-        errno = 0;\n-        id = strtoull(c->cmd + CMD_RELEASE_LEN, &pri_buf, 10);\n-        if (errno) return reply_msg(c, MSG_BAD_FORMAT);\n+        if (read_u64(&id, c->cmd + CMD_RELEASE_LEN, &pri_buf))\n+            return reply_msg(c, MSG_BAD_FORMAT);\n \n-        r = read_num(&pri, pri_buf, &delay_buf);\n-        if (r) return reply_msg(c, MSG_BAD_FORMAT);\n+        if (read_u32(&pri, pri_buf, &delay_buf))\n+            return reply_msg(c, MSG_BAD_FORMAT);\n \n-        r = read_duration(&delay, delay_buf, NULL);\n-        if (r) return reply_msg(c, MSG_BAD_FORMAT);\n+        if (read_duration(&delay, delay_buf, NULL))\n+            return reply_msg(c, MSG_BAD_FORMAT);\n         op_ct[type]++;\n \n         j = remove_reserved_job(c, job_find(id));\n \n-        if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+        if (!j)\n+            return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n \n         /* We want to update the delay deadline on disk, so reserve space for\n          * that. */\n         if (delay) {\n             int z = walresvupdate(&c->srv->wal);\n-            if (!z) return reply_serr(c, MSG_OUT_OF_MEMORY);\n+            if (!z)\n+                return reply_serr(c, MSG_OUT_OF_MEMORY);\n             j->walresv += z;\n         }\n \n@@ -1391,7 +1421,8 @@ dispatch_cmd(Conn *c)\n         j->r.release_ct++;\n \n         r = enqueue_job(c->srv, j, delay, !!delay);\n-        if (r < 0) return reply_serr(c, MSG_INTERNAL_ERROR);\n+        if (r < 0)\n+            return reply_serr(c, MSG_INTERNAL_ERROR);\n         if (r == 1) {\n             return reply(c, MSG_RELEASED, MSG_RELEASED_LEN, STATE_SENDWORD);\n         }\n@@ -1401,21 +1432,23 @@ dispatch_cmd(Conn *c)\n         reply(c, MSG_BURIED, MSG_BURIED_LEN, STATE_SENDWORD);\n         break;\n     case OP_BURY:\n-        errno = 0;\n-        id = strtoull(c->cmd + CMD_BURY_LEN, &pri_buf, 10);\n-        if (errno) return reply_msg(c, MSG_BAD_FORMAT);\n+        if (read_u64(&id, c->cmd + CMD_BURY_LEN, &pri_buf))\n+            return reply_msg(c, MSG_BAD_FORMAT);\n+\n+        if (read_u32(&pri, pri_buf, NULL))\n+            return reply_msg(c, MSG_BAD_FORMAT);\n \n-        r = read_num(&pri, pri_buf, NULL);\n-        if (r) return reply_msg(c, MSG_BAD_FORMAT);\n         op_ct[type]++;\n \n         j = remove_reserved_job(c, job_find(id));\n \n-        if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+        if (!j)\n+            return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n \n         j->r.pri = pri;\n         r = bury_job(c->srv, j, 1);\n-        if (!r) return reply_serr(c, MSG_INTERNAL_ERROR);\n+        if (!r)\n+            return reply_serr(c, MSG_INTERNAL_ERROR);\n         reply(c, MSG_BURIED, MSG_BURIED_LEN, STATE_SENDWORD);\n         break;\n     case OP_KICK:\n@@ -1431,15 +1464,15 @@ dispatch_cmd(Conn *c)\n         i = kick_jobs(c->srv, c->use, count);\n \n         return reply_line(c, STATE_SENDWORD, \"KICKED %u\\r\\n\", i);\n-    case OP_JOBKICK:\n-        errno = 0;\n-        id = strtoull(c->cmd + CMD_JOBKICK_LEN, &end_buf, 10);\n-        if (errno) return twarn(\"strtoull\"), reply_msg(c, MSG_BAD_FORMAT);\n+    case OP_KICKJOB:\n+        if (read_u64(&id, c->cmd + CMD_KICKJOB_LEN, NULL))\n+            return reply_msg(c, MSG_BAD_FORMAT);\n \n         op_ct[type]++;\n \n         j = job_find(id);\n-        if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+        if (!j)\n+            return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n \n         if ((j->r.state == Buried && kick_buried_job(c->srv, j)) ||\n             (j->r.state == Delayed && kick_delayed_job(c->srv, j))) {\n@@ -1449,9 +1482,8 @@ dispatch_cmd(Conn *c)\n         }\n         break;\n     case OP_TOUCH:\n-        errno = 0;\n-        id = strtoull(c->cmd + CMD_TOUCH_LEN, &end_buf, 10);\n-        if (errno) return twarn(\"strtoull\"), reply_msg(c, MSG_BAD_FORMAT);\n+        if (read_u64(&id, c->cmd + CMD_TOUCH_LEN, NULL))\n+            return reply_msg(c, MSG_BAD_FORMAT);\n \n         op_ct[type]++;\n \n@@ -1474,16 +1506,17 @@ dispatch_cmd(Conn *c)\n         do_stats(c, fmt_stats, c->srv);\n         break;\n     case OP_STATSJOB:\n-        errno = 0;\n-        id = strtoull(c->cmd + CMD_STATSJOB_LEN, &end_buf, 10);\n-        if (errno) return reply_msg(c, MSG_BAD_FORMAT);\n+        if (read_u64(&id, c->cmd + CMD_STATSJOB_LEN, NULL))\n+            return reply_msg(c, MSG_BAD_FORMAT);\n \n         op_ct[type]++;\n \n         j = peek_job(id);\n-        if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n+        if (!j)\n+            return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n \n-        if (!j->tube) return reply_serr(c, MSG_INTERNAL_ERROR);\n+        if (!j->tube)\n+            return reply_serr(c, MSG_INTERNAL_ERROR);\n         do_stats(c, (fmt_fn) fmt_job_stats, j);\n         break;\n     case OP_STATS_TUBE:\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -379,24 +379,24 @@ cttest_peek_not_found()\n \n     mustsend(fd, \"peek 2\\r\\n\");\n     ckresp(fd, \"NOT_FOUND\\r\\n\");\n-    mustsend(fd, \"peek 18446744073709551615\\r\\n\");  // max uint64\n+    mustsend(fd, \"peek 18446744073709551615\\r\\n\");  // UINT64_MAX\n     ckresp(fd, \"NOT_FOUND\\r\\n\");\n }\n \n-/*\n-  TODO: Enable this test after fixing #464.\n void\n cttest_peek_bad_format()\n {\n     port = SERVER();\n     fd = mustdiallocal(port);\n-    mustsend(fd, \"peek 18446744073709551616\\r\\n\");\n+    mustsend(fd, \"peek 18446744073709551616\\r\\n\"); // UINT64_MAX+1\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    mustsend(fd, \"peek 184467440737095516160000000000000000000000000000\\r\\n\");\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n-\n     mustsend(fd, \"peek foo111\\r\\n\");\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    mustsend(fd, \"peek 111foo\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n }\n-*/\n \n void\n cttest_peek_delayed()\n@@ -443,37 +443,131 @@ cttest_peek_buried_kick()\n     mustsend(fd, \"A\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n \n+    // cannot bury unreserved job\n     mustsend(fd, \"bury 1 0\\r\\n\");\n     ckresp(fd, \"NOT_FOUND\\r\\n\");\n-\n     mustsend(fd, \"peek-buried\\r\\n\");\n     ckresp(fd, \"NOT_FOUND\\r\\n\");\n \n     mustsend(fd, \"reserve-with-timeout 0\\r\\n\");\n     ckresp(fd, \"RESERVED 1 1\\r\\n\");\n     ckresp(fd, \"A\\r\\n\");\n \n+    // now we can bury\n     mustsend(fd, \"bury 1 0\\r\\n\");\n     ckresp(fd, \"BURIED\\r\\n\");\n-\n     mustsend(fd, \"peek-buried\\r\\n\");\n     ckresp(fd, \"FOUND 1 1\\r\\n\");\n     ckresp(fd, \"A\\r\\n\");\n \n+    // kick and verify the job is ready\n     mustsend(fd, \"kick 1\\r\\n\");\n     ckresp(fd, \"KICKED 1\\r\\n\");\n-\n     mustsend(fd, \"peek-buried\\r\\n\");\n     ckresp(fd, \"NOT_FOUND\\r\\n\");\n-\n     mustsend(fd, \"peek-ready\\r\\n\");\n     ckresp(fd, \"FOUND 1 1\\r\\n\");\n     ckresp(fd, \"A\\r\\n\");\n \n+    // nothing is left to kick\n     mustsend(fd, \"kick 1\\r\\n\");\n     ckresp(fd, \"KICKED 0\\r\\n\");\n }\n \n+void\n+cttest_touch_bad_format()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"touch a111\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    mustsend(fd, \"touch 111a\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    mustsend(fd, \"touch !@#!@#\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+}\n+\n+void\n+cttest_touch_not_found()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"touch 1\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+    mustsend(fd, \"touch 100000000000000\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+}\n+\n+void\n+cttest_bury_bad_format()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"bury 111abc 2\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    mustsend(fd, \"bury 111\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    mustsend(fd, \"bury 111 222abc\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+}\n+\n+void\n+cttest_kickjob_bad_format()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"kick-job a111\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    mustsend(fd, \"kick-job 111a\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    mustsend(fd, \"kick-job !@#!@#\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+}\n+\n+void\n+cttest_kickjob_buried()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"A\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+\n+    mustsend(fd, \"reserve\\r\\n\");\n+    ckresp(fd, \"RESERVED 1 1\\r\\n\");\n+    ckresp(fd, \"A\\r\\n\");\n+    mustsend(fd, \"bury 1 0\\r\\n\");\n+    ckresp(fd, \"BURIED\\r\\n\");\n+\n+    mustsend(fd, \"kick-job 100\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+    mustsend(fd, \"kick-job 1\\r\\n\");\n+    ckresp(fd, \"KICKED\\r\\n\");\n+    mustsend(fd, \"kick-job 1\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+}\n+\n+void\n+cttest_kickjob_delayed()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    // jid=1 - no delay, jid=2 - delay\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"A\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+    mustsend(fd, \"put 0 10 1 1\\r\\n\");\n+    mustsend(fd, \"B\\r\\n\");\n+    ckresp(fd, \"INSERTED 2\\r\\n\");\n+\n+    mustsend(fd, \"kick-job 1\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+    mustsend(fd, \"kick-job 2\\r\\n\");\n+    ckresp(fd, \"KICKED\\r\\n\");\n+    mustsend(fd, \"kick-job 2\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+}\n+\n void\n cttest_pause()\n {\n@@ -578,6 +672,21 @@ cttest_delete_ready()\n     ckresp(fd, \"DELETED\\r\\n\");\n }\n \n+void\n+cttest_delete_bad_format()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"delete 18446744073709551616\\r\\n\"); // UINT64_MAX+1\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    mustsend(fd, \"delete 184467440737095516160000000000000000000000000000\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    mustsend(fd, \"delete foo111\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    mustsend(fd, \"delete 111foo\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+}\n+\n void\n cttest_multi_tube()\n {\n@@ -675,6 +784,19 @@ cttest_small_delay()\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n }\n \n+void\n+cttest_statsjob_ck_format()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"stats-job 111ABC\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    mustsend(fd, \"stats-job 111 222\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    mustsend(fd, \"stats-job 111\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+}\n+\n void\n cttest_stats_tube()\n {\n@@ -902,6 +1024,40 @@ cttest_reserve_ttr_deadline_soon()\n     ckrespsub(prod, \"\\nstate: ready\\n\");\n }\n \n+void\n+cttest_release_bad_format()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+\n+    // bad id\n+    mustsend(fd, \"release 18446744073709551616 1 1\\r\\n\"); // UINT64_MAX+1\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    mustsend(fd, \"release 184467440737095516160000000000000000000000000000 1 1\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    mustsend(fd, \"release foo111\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    mustsend(fd, \"release 111foo\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+\n+    // bad priority\n+    mustsend(fd, \"release 18446744073709551615 abc 1\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+\n+    // bad duration\n+    mustsend(fd, \"release 18446744073709551615 1 abc\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+}\n+\n+void\n+cttest_release_not_found()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"release 1 1 1\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+}\n+\n void\n cttest_close_releases_job()\n {\n", "test_patch": "", "problem_statement": "fix the id parsing in all commands and add tests\nThis change fixes how IDs are parsed in all commands.\r\nThey are parsed into uint64 with full spectrum of checks.\r\nI added the read_uint64 function identical to read_uint32 (former read_num).\r\nAlso read_uint* functions report values not falling into the range as invalid.\r\n\r\nI have renamed definitions *_JOBKICK to *_KICKJOB because it was inverted from\r\nactual command.\r\n\r\nUpdates #424\r\nFixes #464", "version": "1.11", "language": "C", "created_at": "2019-07-23T09:43:57Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-346", "repo": "beanstalkd/beanstalkd", "pull_number": 346, "base_commit": "6225c62c26a0cbd844236944b4ebdef715e81824", "patch": "diff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -14,7 +14,7 @@ static size_t all_jobs_used = 0;\n \n static int hash_table_was_oom = 0;\n \n-static void rehash();\n+static void rehash(int);\n \n static int\n _get_job_hash_index(uint64 job_id)\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -246,12 +246,6 @@ job_insert(job head, job j)\n     head->prev = j;\n }\n \n-uint64\n-total_jobs()\n-{\n-    return next_id - 1;\n-}\n-\n /* for unit tests */\n size_t\n get_all_jobs_used()\n", "test_patch": "", "problem_statement": "call to function without a real prototype\nFixes #345", "version": "1.10", "language": "C", "created_at": "2017-03-19T18:12:29Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-492", "repo": "beanstalkd/beanstalkd", "pull_number": 492, "base_commit": "24ca568b8139a3cdb1f260f4ed2c2de99001dd49", "patch": "diff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -30,7 +30,10 @@ also try,\n     $ make install\n     $ make install PREFIX=/usr\n \n-Requires Linux (2.6.17 or later), Mac OS X, or FreeBSD.\n+Requires Linux (2.6.17 or later), Mac OS X, FreeBSD, or Illumos.\n+\n+Currently beanstalkd is tested with GCC and clang, but it should work\n+with any compiler that supports C99.\n \n Uses ronn to generate the manual.\n See http://github.com/rtomayko/ronn.\n", "test_patch": "", "problem_statement": "README.md: mention C99 as required compiler, Illumos as supported OS\nFixes #465", "version": "1.11", "language": "C", "created_at": "2019-07-23T15:32:20Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-491", "repo": "beanstalkd/beanstalkd", "pull_number": 491, "base_commit": "0235831a0c44d919bd7adc811a281defef5b2846", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -152,11 +152,6 @@ int ms_contains(ms a, void *item);\n void *ms_take(ms a);\n \n \n-enum\n-{\n-    Walver = 7\n-};\n-\n enum // Jobrec.state\n {\n     Invalid,\n@@ -167,10 +162,31 @@ enum // Jobrec.state\n     Copy\n };\n \n-// If you modify this struct, you must increment Walver above,\n-// Beanstalkd does not handle migration between different versions:\n-// it will reject the old data and exit from the server.\n-// TODO: Handle Walver migrations automatically.\n+enum\n+{\n+    Walver = 7\n+};\n+\n+// If you modify Jobrec struct, you must increment Walver above.\n+//\n+// This workflow is expected:\n+// 1. If any change needs to be made to the format, first increment Walver.\n+// 2. If and only if this is the first such change since the last release:\n+//    a. Copy-paste relevant file-reading functions in file.c and\n+//       add the old version number to their names. For example,\n+//       if you are incrementing Walver from 7 to 8, copy readrec to readrec7.\n+//       (Currently, there is only one such function, readrec. But if\n+//       a future readrec calls other version-specific functions,\n+//       those will have to be copied too.)\n+// 3. Add a switch case to fileread for the old version.\n+// 4. Modify the current reading function (readrec) to reflect your change.\n+//\n+// Incrementing Walver for every change, even if not every version\n+// will be released, is helpful even if it \"wastes\" version numbers.\n+// It is a really easy thing to do and it means during development\n+// you won't have to worry about misinterpreting the contents of a binlog\n+// that you generated with a dev copy of beanstalkd.\n+\n struct Jobrec {\n     uint64 id;\n     uint32 pri;\n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -71,9 +71,6 @@ typedef int(FAlloc)(int, int);\n // The width is restricted by Jobrec.body_size that is int32.\n #define JOB_DATA_SIZE_LIMIT_MAX 1073741824\n \n-// Maximum value (uint32) allowed in pri, delay and ttr parameters\n-#define MAX_UINT32 4294967295\n-\n // Use this macro to designate unused parameters in functions.\n #define UNUSED_PARAMETER(x) (void)(x)\n \n", "test_patch": "", "problem_statement": "dat.h: fix misleading comment about Walver\nFixes #479", "version": "1.11", "language": "C", "created_at": "2019-07-23T15:23:56Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-498", "repo": "beanstalkd/beanstalkd", "pull_number": 498, "base_commit": "bb53ddabe42513d0248cf4496fcd21f16579906a", "patch": "diff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -14,7 +14,7 @@ static uint tot_conn_ct = 0;\n int verbose = 0;\n \n static void\n-on_watch(ms a, tube t, size_t i)\n+on_watch(Ms *a, tube t, size_t i)\n {\n     UNUSED_PARAMETER(a);\n     UNUSED_PARAMETER(i);\n@@ -23,7 +23,7 @@ on_watch(ms a, tube t, size_t i)\n }\n \n static void\n-on_ignore(ms a, tube t, size_t i)\n+on_ignore(Ms *a, tube t, size_t i)\n {\n     UNUSED_PARAMETER(a);\n     UNUSED_PARAMETER(i);\n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -9,11 +9,10 @@ typedef uint32_t      uint32;\n typedef int64_t       int64;\n typedef uint64_t      uint64;\n \n-/* TODO: typedefs of ms, job and tube should not hide the pointer.\n+/* TODO: typedefs of job and tube should not hide the pointer.\n    Make them similar to other typedefs (Conn, Heap).\n-   Maybem move each typedef next to the corresponding struct definition.\n    See issue #458. */\n-typedef struct ms     *ms;\n+typedef struct Ms     Ms;\n typedef struct job    *job;\n typedef struct tube   *tube;\n typedef struct Conn   Conn;\n@@ -128,10 +127,10 @@ int socknext(Socket**, int64);\n \n \n // ms_event_fn is called with the element being inserted/removed and its position.\n-typedef void(*ms_event_fn)(ms a, void *item, size_t i);\n+typedef void(*ms_event_fn)(Ms *a, void *item, size_t i);\n \n // Resizable multiset\n-struct ms {\n+struct Ms {\n     size_t len;                // amount of stored elements\n     size_t cap;                // capacity\n     size_t last;               // position of last taken element\n@@ -141,12 +140,12 @@ struct ms {\n     ms_event_fn onremove;      // called on removal of an element\n };\n \n-void ms_init(ms a, ms_event_fn oninsert, ms_event_fn onremove);\n-void ms_clear(ms a);\n-int ms_append(ms a, void *item);\n-int ms_remove(ms a, void *item);\n-int ms_contains(ms a, void *item);\n-void *ms_take(ms a);\n+void ms_init(Ms *a, ms_event_fn oninsert, ms_event_fn onremove);\n+void ms_clear(Ms *a);\n+int ms_append(Ms *a, void *item);\n+int ms_remove(Ms *a, void *item);\n+int ms_contains(Ms *a, void *item);\n+void *ms_take(Ms *a);\n \n \n enum // Jobrec.state\n@@ -225,7 +224,7 @@ struct tube {\n     char name[MAX_TUBE_NAME_LEN];\n     Heap ready;\n     Heap delay;\n-    struct ms waiting; /* set of conns */\n+    struct Ms waiting; /* set of conns */\n     struct stats stat;\n     uint using_ct;\n     uint watching_ct;\n@@ -279,7 +278,7 @@ void job_insert(job head, job j);\n size_t get_all_jobs_used(void);\n \n \n-extern struct ms tubes;\n+extern struct Ms tubes;\n \n tube make_tube(const char *name);\n void tube_dref(tube t);\n@@ -352,7 +351,7 @@ struct Conn {\n     job out_job;\n     int out_job_sent;\n \n-    struct ms  watch;\n+    struct Ms  watch;\n     struct job reserved_jobs; // linked list header\n };\n int  conn_less(void *ax, void *bx);\n\ndiff --git a/ms.c b/ms.c\n--- a/ms.c\n+++ b/ms.c\n@@ -4,7 +4,7 @@\n #include <stdlib.h>\n \n void\n-ms_init(ms a, ms_event_fn oninsert, ms_event_fn onremove)\n+ms_init(Ms *a, ms_event_fn oninsert, ms_event_fn onremove)\n {\n     a->len = a->cap = a->last = 0;\n     a->items = NULL;\n@@ -13,7 +13,7 @@ ms_init(ms a, ms_event_fn oninsert, ms_event_fn onremove)\n }\n \n static void\n-grow(ms a)\n+grow(Ms *a)\n {\n     void **nitems;\n     size_t ncap = (a->cap << 1) ? : 1;\n@@ -29,7 +29,7 @@ grow(ms a)\n }\n \n int\n-ms_append(ms a, void *item)\n+ms_append(Ms *a, void *item)\n {\n     if (a->len >= a->cap)\n         grow(a);\n@@ -43,7 +43,7 @@ ms_append(ms a, void *item)\n }\n \n static int\n-ms_delete(ms a, size_t i)\n+ms_delete(Ms *a, size_t i)\n {\n     void *item;\n \n@@ -59,15 +59,15 @@ ms_delete(ms a, size_t i)\n }\n \n void\n-ms_clear(ms a)\n+ms_clear(Ms *a)\n {\n     while (ms_delete(a, 0));\n     free(a->items);\n     ms_init(a, a->oninsert, a->onremove);\n }\n \n int\n-ms_remove(ms a, void *item)\n+ms_remove(Ms *a, void *item)\n {\n     size_t i;\n \n@@ -79,7 +79,7 @@ ms_remove(ms a, void *item)\n }\n \n int\n-ms_contains(ms a, void *item)\n+ms_contains(Ms *a, void *item)\n {\n     size_t i;\n \n@@ -91,7 +91,7 @@ ms_contains(ms a, void *item)\n }\n \n void *\n-ms_take(ms a)\n+ms_take(Ms *a)\n {\n     void *item;\n \n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -1072,7 +1072,7 @@ do_stats(Conn *c, fmt_fn fmt, void *data)\n }\n \n static void\n-do_list_tubes(Conn *c, ms l)\n+do_list_tubes(Conn *c, Ms *l)\n {\n     char *buf;\n     tube t;\n\ndiff --git a/testms.c b/testms.c\n--- a/testms.c\n+++ b/testms.c\n@@ -10,7 +10,7 @@\n void\n cttest_ms_append()\n {\n-    ms a = new(struct ms);\n+    Ms *a = new(struct Ms);\n     ms_init(a, NULL, NULL);\n \n     int i = 10;\n@@ -33,7 +33,7 @@ void\n cttest_ms_remove()\n {\n \n-    ms a = new(struct ms);\n+    Ms *a = new(struct Ms);\n     ms_init(a, NULL, NULL);\n \n     int i = 1;\n@@ -58,7 +58,7 @@ void\n cttest_ms_contains()\n {\n \n-    ms a = new(struct ms);\n+    Ms *a = new(struct Ms);\n     ms_init(a, NULL, NULL);\n \n     int i = 1;\n@@ -79,7 +79,7 @@ void\n cttest_ms_clear_empty()\n {\n \n-    ms a = new(struct ms);\n+    Ms *a = new(struct Ms);\n     ms_init(a, NULL, NULL);\n \n     ms_clear(a);\n@@ -91,7 +91,7 @@ cttest_ms_clear_empty()\n void\n cttest_ms_take()\n {\n-    ms a = new(struct ms);\n+    Ms *a = new(struct Ms);\n     ms_init(a, NULL, NULL);\n \n     int i = 10;\n@@ -121,7 +121,7 @@ cttest_ms_take_sequence()\n     int s[] = {1, 2, 3, 4, 5, 6};\n     int e[] = {1, 2, 3, 6, 5, 4};\n \n-    ms a = new(struct ms);\n+    Ms *a = new(struct Ms);\n     ms_init(a, NULL, NULL);\n \n     size_t n = sizeof(s)/sizeof(s[0]);\n\ndiff --git a/tube.c b/tube.c\n--- a/tube.c\n+++ b/tube.c\n@@ -3,7 +3,7 @@\n #include <stdlib.h>\n #include <string.h>\n \n-struct ms tubes;\n+struct Ms tubes;\n \n tube\n make_tube(const char *name)\n", "test_patch": "", "problem_statement": "drop the pointer from the ms typedef\nUpdates #458", "version": "1.11", "language": "C", "created_at": "2019-07-26T18:07:42Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-493", "repo": "beanstalkd/beanstalkd", "pull_number": 493, "base_commit": "6b3e062fde338394a3e9d52e5af9f9dfa7c8702d", "patch": "diff --git a/testheap.c b/testheap.c\n--- a/testheap.c\n+++ b/testheap.c\n@@ -194,7 +194,6 @@ void\n ctbench_heap_insert(int n)\n {\n     job *j = calloc(n, sizeof *j);\n-    assert(j);\n     int i;\n     for (i = 0; i < n; i++) {\n         j[i] = make_job(1, 0, 1, 0, 0);\n@@ -205,10 +204,17 @@ ctbench_heap_insert(int n)\n         .less = job_pri_less,\n         .setpos = job_setpos,\n     };\n+\n     ctresettimer();\n     for (i = 0; i < n; i++) {\n         heapinsert(&h, j[i]);\n     }\n+    ctstoptimer();\n+\n+    for (i = 0; i < n; i++)\n+        job_free(heapremove(&h, 0));\n+    free(h.data);\n+    free(j);\n }\n \n void\n@@ -218,15 +224,21 @@ ctbench_heap_remove(int n)\n         .less = job_pri_less,\n         .setpos = job_setpos,\n     };\n-\n     int i;\n     for (i = 0; i < n; i++) {\n         job j = make_job(1, 0, 1, 0, 0);\n         assertf(j, \"allocate job\");\n         heapinsert(&h, j);\n     }\n+    job t[n];   // temp storage to deallocate jobs later\n+\n     ctresettimer();\n     for (i = 0; i < n; i++) {\n-        heapremove(&h, 0);\n+        t[i] = heapremove(&h, 0);\n     }\n+    ctstoptimer();\n+\n+    free(h.data);\n+    for (i = 0; i < n; i++)\n+        job_free(t[i]);\n }\n", "test_patch": "", "problem_statement": "fix memory leak in the heap benchmarks\nUpdates #382", "version": "1.11", "language": "C", "created_at": "2019-07-24T06:27:10Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-531", "repo": "beanstalkd/beanstalkd", "pull_number": 531, "base_commit": "07c75e338b66cd568fb90233b6320e97d7b805cc", "patch": "diff --git a/linux.c b/linux.c\n--- a/linux.c\n+++ b/linux.c\n@@ -22,7 +22,15 @@ static int epfd;\n int\n rawfalloc(int fd, int len)\n {\n-    return ftruncate(fd, len);\n+    // XSI-conformant systems might not extend the file and return an error.\n+    // ftruncate() might extend the file with a sequence of null bytes or a hole.\n+    // Latter means that disk blocks are not allocated before the write happens.\n+    // To ensure that write won't fail because disk space is exhausted,\n+    // we might use posix_fallocate() that ensures disk allocation, but it\n+    // has limited support for NFS. Optionally can revert to regular write as on osx.\n+    if (!ftruncate(fd, len))\n+        return 0;\n+    return errno;\n }\n \n \n", "test_patch": "", "problem_statement": "linux.c: fix rawfalloc to return errno on error\nftruncate() does not return errno.", "version": "1.11", "language": "C", "created_at": "2019-08-07T09:46:25Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-519", "repo": "beanstalkd/beanstalkd", "pull_number": 519, "base_commit": "74a362df237304ed5df14949eb8fa4e8769a3878", "patch": "diff --git a/doc/protocol.zh-CN.md b/doc/protocol.zh-CN.md\n--- a/doc/protocol.zh-CN.md\n+++ b/doc/protocol.zh-CN.md\n@@ -1,12 +1,12 @@\n-## Beanstalkd\u4e2d\u6587\u534f\u8bae\n+# Beanstalkd\u4e2d\u6587\u534f\u8bae\n \n ### \u603b\u62ec\n \n-`beanstalkd`\u534f\u8bae\u57fa\u4e8eASCII\u7f16\u7801\u8fd0\u884c\u5728tcp\u4e0a\u3002\u5ba2\u6237\u7aef\u8fde\u63a5\u670d\u52a1\u5668\u5e76\u53d1\u9001\u6307\u4ee4\u548c\u6570\u636e\uff0c\u7136\u540e\u7b49\u5f85\u54cd\u5e94\u5e76\u5173\u95ed\u8fde\u63a5\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u8fde\u63a5\uff0c\u670d\u52a1\u5668\u6309\u7167\u63a5\u6536\u547d\u4ee4\u7684\u5e8f\u5217\u4f9d\u6b21\u5904\u7406\u5e76\u54cd\u5e94\u3002\u6240\u6709\u6574\u578b\u503c\u90fd\u975e\u8d1f\u7684\u5341\u8fdb\u5236\u6570\uff0c\u9664\u975e\u6709\u7279\u522b\u58f0\u660e\u3002\n+`beanstalkd` \u534f\u8bae\u57fa\u4e8e ASCII \u7f16\u7801\u8fd0\u884c\u5728 tcp \u4e0a. \u5ba2\u6237\u7aef\u8fde\u63a5\u670d\u52a1\u5668\u5e76\u53d1\u9001\u6307\u4ee4\u548c\u6570\u636e\uff0c\u7136\u540e\u7b49\u5f85\u54cd\u5e94\u5e76\u5173\u95ed\u8fde\u63a5. \u5bf9\u4e8e\u6bcf\u4e2a\u8fde\u63a5\uff0c\u670d\u52a1\u5668\u6309\u7167\u63a5\u6536\u547d\u4ee4\u7684\u5e8f\u5217\u4f9d\u6b21\u5904\u7406\u5e76\u54cd\u5e94. \u6240\u6709\u6574\u578b\u503c\u90fd\u975e\u8d1f\u7684\u5341\u8fdb\u5236\u6570\uff0c\u9664\u975e\u6709\u7279\u522b\u58f0\u660e.\n \n ### \u540d\u79f0\u7ea6\u5b9a\n \n-\u6240\u6709\u540d\u79f0\u5fc5\u987b\u662fASCII\u7801\u5b57\u7b26\u4e32\uff0c\u5373\u5305\u62ec\uff1a\n+\u6240\u6709\u540d\u79f0\u5fc5\u987b\u662f ASCII \u7801\u5b57\u7b26\u4e32\uff0c\u5373\u5305\u62ec\uff1a\n \n * **\u5b57\u6bcd** (A-Z and a-z)\n * **\u6570\u5b57** (0-9)\n@@ -19,36 +19,38 @@\n * **\u4e0b\u5212\u7ebf** (\"_\")\n * **\u62ec\u53f7** (\"*(*\" and \"*)*\")\n \n-**\u6ce8\u610f**\uff1a\u540d\u79f0\u4e0d\u80fd\u4ee5\u8fde\u5b57\u7b26\u5f00\u59cb\uff0c\u5e76\u4e14\u662f\u4ee5\u7a7a\u767d\u5b57\u7b26\u7ed3\u675f\uff0c\u6bcf\u4e2a\u540d\u79f0\u81f3\u5c11\u5305\u542b\u4e00\u4e2a\u5b57\u7b26\u3002\n+**\u6ce8\u610f**\uff1a\u540d\u79f0\u4e0d\u80fd\u4ee5\u8fde\u5b57\u7b26\u5f00\u59cb\uff0c\u5e76\u4e14\u662f\u4ee5\u7a7a\u767d\u5b57\u7b26\u7ed3\u675f\uff0c\u6bcf\u4e2a\u540d\u79f0\u81f3\u5c11\u5305\u542b\u4e00\u4e2a\u5b57\u7b26.\n \n ### \u9519\u8bef\u8bf4\u660e\n \n | \u8fd4\u56de\u7684\u9519\u8bef                               | \u63cf\u8ff0       |\n | --------------------------------------- | -------- |\n-| `OUT_OF_MEMORY\\r\\n`                     | \u670d\u52a1\u5668\u6ca1\u6709\u8db3\u591f\u7684\u5185\u5b58\u5206\u914d\u7ed9\u7279\u5b9a\u7684job\uff0c\u5ba2\u6237\u7aef\u5e94\u8be5\u7a0d\u540e\u91cd\u8bd5 |\n-| `INTERNAL_ERROR\\r\\n`                    | \u670d\u52a1\u5668\u5185\u90e8\u9519\u8bef\uff0c\u8be5\u9519\u8bef\u4e0d\u5e94\u8be5\u53d1\u751f\uff0c\u5982\u679c\u53d1\u751f\u4e86\uff0c\u8bf7\u62a5\u544a\uff1ahttp://groups.google.com/group/beanstalk-talk. |\n-| `BAD_FORMAT\\r\\n`                         | \u683c\u5f0f\u4e0d\u6b63\u786e\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u7684\u6307\u4ee4\u683c\u5f0f\u51fa\u9519\uff0c\u6709\u53ef\u80fd\u4e0d\u662f\u4ee5\\r\\n\u7ed3\u5c3e\uff0c\u6216\u8005\u8981\u6c42\u6574\u578b\u503c\u7b49\u7b49 |\n+| `OUT_OF_MEMORY\\r\\n`                     | \u670d\u52a1\u5668\u6ca1\u6709\u8db3\u591f\u7684\u5185\u5b58\u5206\u914d\u7ed9\u7279\u5b9a\u7684 job\uff0c\u5ba2\u6237\u7aef\u5e94\u8be5\u7a0d\u540e\u91cd\u8bd5 |\n+| `INTERNAL_ERROR\\r\\n`                    | \u670d\u52a1\u5668\u5185\u90e8\u9519\u8bef\uff0c\u8be5\u9519\u8bef\u4e0d\u5e94\u8be5\u53d1\u751f\uff0c\u5982\u679c\u53d1\u751f\u4e86\uff0c\u8bf7\u62a5\u544a: [http://groups.google.com/group/beanstalk-talk](http://groups.google.com/group/beanstalk-talk).|\n+| `BAD_FORMAT\\r\\n`                         | \u683c\u5f0f\u4e0d\u6b63\u786e\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u7684\u6307\u4ee4\u683c\u5f0f\u51fa\u9519\uff0c\u6709\u53ef\u80fd\u4e0d\u662f\u4ee5 `\\r\\n` \u7ed3\u5c3e\uff0c\u6216\u8005\u8981\u6c42\u6574\u578b\u503c\u7b49\u7b49 |\n | `UNKNOWN_COMMAND\\r\\n`                   | \u672a\u77e5\u7684\u547d\u4ee4\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u7684\u6307\u4ee4\u670d\u52a1\u5668\u4e0d\u7406\u89e3 |\n \n-### job\u7684\u751f\u547d\u5468\u671f\n-\u4e00\u4e2a\u5de5\u4f5c\u4efb\u52a1job\u5f53client\u4f7f\u7528put\u547d\u4ee4\u65f6\u521b\u5efa\u3002\u5728\u6574\u4e2a\u751f\u547d\u5468\u671f\u4e2djob\u53ef\u80fd\u6709\u56db\u4e2a\u5de5\u4f5c\u72b6\u6001\uff1aready\uff0creserved\uff0cdelayed\uff0cburied\u3002\u5728put\u4e4b\u540e\uff0c\u4e00\u4e2ajob\u7684\u5178\u578b\u72b6\u6001\u662fready\uff0c\u5728ready\u961f\u5217\u4e2d\uff0c\u5b83\u5c06\u7b49\u5f85\u4e00\u4e2aworker\u53d6\u51fa\u6b64job\u5e76\u8bbe\u7f6e\u4e3a\u5176\u4e3areserved\u72b6\u6001\u3002worker\u5360\u6709\u6b64job\u5e76\u6267\u884c\uff0c\u5f53job\u6267\u884c\u5b8c\u6bd5\uff0cworker\u53ef\u4ee5\u53d1\u9001\u4e00\u4e2adelete\u6307\u4ee4\u5220\u9664\u6b64job\u3002\n+### job \u7684\u751f\u547d\u5468\u671f\n+\n+Client \u4f7f\u7528 put \u547d\u4ee4\u521b\u5efa\u4e00\u4e2a\u5de5\u4f5c\u4efb\u52a1 job. \u5728\u6574\u4e2a\u751f\u547d\u5468\u671f\u4e2d job \u53ef\u80fd\u6709\u56db\u4e2a\u5de5\u4f5c\u72b6\u6001\uff1aready\u3001reserved\u3001delayed\u3001buried. \u5728 put \u64cd\u4f5c\u4e4b\u540e\uff0c\u4e00\u4e2a job \u7684\u5178\u578b\u72b6\u6001\u662f ready\uff0c\u5728 ready \u961f\u5217\u4e2d\uff0c\u5b83\u5c06\u7b49\u5f85\u4e00\u4e2a worker \u53d6\u51fa\u6b64 job \u5e76\u8bbe\u7f6e\u4e3a\u5176\u4e3a reserved \u72b6\u6001. worker\u5360\u6709\u6b64 job \u5e76\u6267\u884c\uff0c\u5f53 job \u6267\u884c\u5b8c\u6bd5\uff0cworker \u53ef\u4ee5\u53d1\u9001\u4e00\u4e2a delete \u6307\u4ee4\u5220\u9664\u6b64 job.\n \n | Status              | Description   |\n | --------------------| ------------- |\n | `ready`             | \u7b49\u5f85\u88ab\u53d6\u51fa\u5e76\u5904\u7406 |\n-| `reserved`          | \u5982\u679cjob\u88abworker\u53d6\u51fa\uff0c\u5c06\u88ab\u6b64worker\u9884\u8ba2\uff0cworker\u5c06\u6267\u884c\u6b64job |\n-| `delayed`           | \u7b49\u5f85\u7279\u5b9a\u65f6\u95f4\u4e4b\u540e\uff0c\u72b6\u6001\u518d\u8fc1\u79fb\u4e3aready\u72b6\u6001 |\n-| `buried`            | \u7b49\u5f85\u5524\u9192\uff0c\u901a\u5e38\u5728job\u5904\u7406\u5931\u8d25\u65f6\n+| `reserved`          | \u5982\u679c job \u88ab worker \u53d6\u51fa\uff0c\u5c06\u88ab\u6b64 worker \u9884\u8ba2\uff0cworker \u5c06\u6267\u884c\u6b64 job |\n+| `delayed`           | \u7b49\u5f85\u7279\u5b9a\u65f6\u95f4\u4e4b\u540e\uff0c\u72b6\u6001\u518d\u8fc1\u79fb\u4e3a `ready` \u72b6\u6001 |\n+| `buried`            | \u7b49\u5f85\u5524\u9192\uff0c\u901a\u5e38\u5728 job \u5904\u7406\u5931\u8d25\u65f6\u8fdb\u5165\u8be5\u72b6\u6001\n \n-job\u5178\u578b\u7684\u751f\u547d\u5468\u671f\n+#### job \u5178\u578b\u7684\u751f\u547d\u5468\u671f\n \n-```\n+```text\n    put            reserve               delete\n   -----> [READY] ---------> [RESERVED] --------> *poof*\n ```\n \n-job\u53ef\u80fd\u7684\u72b6\u6001\u8fc1\u79fb\n-```\n+#### job \u53ef\u80fd\u7684\u72b6\u6001\u8fc1\u79fb\n+\n+```text\n    put with delay               release with delay\n   ----------------> [DELAYED] <------------.\n                         |                   |\n@@ -70,404 +72,552 @@ job\u53ef\u80fd\u7684\u72b6\u6001\u8fc1\u79fb\n ```\n \n ## Tubes\n-\u4e00\u4e2a\u670d\u52a1\u5668\u6709\u4e00\u4e2a\u6216\u8005\u591a\u4e2atubes\uff0c\u7528\u6765\u50a8\u5b58\u7edf\u4e00\u7c7b\u578b\u7684job\u3002\u6bcf\u4e2atube\u7531\u4e00\u4e2a\u5c31\u7eea\u961f\u5217\u4e0e\u5ef6\u8fdf\u961f\u5217\u7ec4\u6210\u3002\u6bcf\u4e2ajob\u6240\u6709\u7684\u72b6\u6001\u8fc1\u79fb\u5728\u4e00\u4e2atube\u4e2d\u5b8c\u6210\u3002consumers\u6d88\u8d39\u8005\u53ef\u4ee5\u76d1\u63a7\u611f\u5174\u8da3\u7684tube\uff0c\u901a\u8fc7\u53d1\u9001watch\u6307\u4ee4\u3002consumers\u6d88\u8d39\u8005\u53ef\u4ee5\u53d6\u6d88\u76d1\u63a7tube\uff0c\u901a\u8fc7\u53d1\u9001ignore\u547d\u4ee4\u3002\u901a\u8fc7watch list\u547d\u4ee4\u8fd4\u56de\u6240\u6709\u76d1\u63a7\u7684tubes\uff0c\u5f53\u5ba2\u6237\u7aef\u9884\u8ba2\u4e00\u4e2ajob\uff0c\u6b64job\u53ef\u80fd\u6765\u81ea\u4efb\u4f55\u4e00\u4e2a\u5b83\u76d1\u63a7\u7684tube\u3002\n \n-\u5f53\u4e00\u4e2a\u5ba2\u6237\u7aef\u8fde\u63a5\u4e0a\u670d\u52a1\u5668\u65f6\uff0c\u5ba2\u6237\u7aef\u76d1\u63a7\u7684tube\u9ed8\u8ba4\u4e3adefaut\uff0c\u5982\u679c\u5ba2\u6237\u7aef\u63d0\u4ea4job\u65f6\uff0c\u6ca1\u6709\u4f7f\u7528use\u547d\u4ee4\uff0c\u90a3\u4e48\u8fd9\u4e9bjob\u5c31\u5b58\u4e8e\u540d\u4e3adefault\u7684tube\u4e2d\u3002\n+\u4e00\u4e2a beanstalkd \u5b9e\u4f8b\u670d\u52a1\u53ef\u80fd\u6709\u4e00\u4e2a\u6216\u8005\u591a\u4e2a tube\uff0c\u7528\u6765\u50a8\u5b58\u7edf\u4e00\u7c7b\u578b\u7684 job.\u6bcf\u4e2a tube \u7531\u4e00\u4e2a\u5c31\u7eea (`ready`) \u961f\u5217\u4e0e\u5ef6\u8fdf (`delayed`) \u961f\u5217\u7ec4\u6210.\u6bcf\u4e2a job \u6240\u6709\u7684\u72b6\u6001\u8fc1\u79fb\u5728\u4e00\u4e2a tube \u4e2d\u5b8c\u6210.\u901a\u8fc7\u53d1\u9001 `watch` \u6307\u4ee4, \u6d88\u8d39\u8005 consumers \u53ef\u4ee5\u76d1\u63a7\u611f\u5174\u8da3\u7684 tube.\u901a\u8fc7\u53d1\u9001 `ignore` \u6307\u4ee4, \u6d88\u8d39\u8005 consumers \u53ef\u4ee5\u53d6\u6d88\u76d1\u63a7 tube.\u901a\u8fc7 `list-tubes-watched`\u547d\u4ee4\u8fd4\u56de\u6240\u6709\u76d1\u63a7\u7684 tubes\uff0c\u5f53\u5ba2\u6237\u7aef\u9884\u8ba2 (`reserved`) \u4e00\u4e2a job\uff0c\u6b64 job \u53ef\u80fd\u6765\u81ea\u4efb\u4f55\u4e00\u4e2a\u5b83\u76d1\u63a7\u7684 tube.\n \n-tube\u6309\u9700\u6c42\u521b\u5efa\uff0c\u65e0\u8bba\u4ed6\u4eec\u5728\u4ec0\u4e48\u65f6\u5019\u88ab\u5f15\u7528\u5230\u3002\u5982\u679c\u4e00\u4e2atube\u53d8\u4e3a\u7a7a\uff08\u5373no ready jobs\uff0cno delayed jobs\uff0cno buried jobs\uff09\u548c\u6ca1\u6709\u4efb\u4f55\u5ba2\u6237\u7aef\u5f15\u7528\uff0c\u5b83\u5c06\u4f1a\u88ab\u81ea\u52a8\u5220\u9664\u3002\n+\u5f53\u4e00\u4e2a\u5ba2\u6237\u7aef\u8fde\u63a5\u4e0a\u670d\u52a1\u5668\u65f6\uff0c\u5ba2\u6237\u7aef\u76d1\u63a7\u7684 tube \u9ed8\u8ba4\u4e3a `defaut`\uff0c\u5982\u679c\u5ba2\u6237\u7aef\u63d0\u4ea4 job \u65f6\uff0c\u6ca1\u6709\u4f7f\u7528 `use` \u547d\u4ee4\uff0c\u90a3\u4e48\u8fd9\u4e9b job \u5c31\u5b58\u4e8e\u540d\u4e3a`default`\u7684 tube \u4e2d.\n+\n+tube \u6309\u9700\u6c42\u521b\u5efa\uff0c\u65e0\u8bba\u4ed6\u4eec\u5728\u4ec0\u4e48\u65f6\u5019\u88ab\u5f15\u7528\u5230.\u5982\u679c\u4e00\u4e2a tube \u53d8\u4e3a\u7a7a\uff08\u5373 no ready jobs\uff0cno delayed jobs\uff0cno buried jobs\uff09\u548c\u6ca1\u6709\u4efb\u4f55\u5ba2\u6237\u7aef\u5f15\u7528(being watched)\uff0c\u5b83\u5c06\u4f1a\u88ab**\u81ea\u52a8\u5220\u9664**.\n \n ### \u6307\u4ee4\u8bf4\u660e\uff08Commands\uff09\n+\n #### \u751f\u4ea7\u8005\u6307\u4ee4\u8bf4\u660e\uff08Producer Commands\uff09\n+\n #### `put`\n \n-\u63d2\u5165\u4e00\u4e2ajob\u5230\u961f\u5217\n+\u63d2\u5165\u4e00\u4e2a job \u5230\u961f\u5217\n \n-```\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n put <pri> <delay> <ttr> <bytes>\\r\\n\n <data>\\r\\n\n ```\n \n-* `<pri>` \u6574\u578b\u503c\uff0c\u4e3a\u4f18\u5148\u7ea7\uff0c\u53ef\u4ee5\u4e3a0-2^32\uff084,294,967,295\uff09\uff0c\u503c\u8d8a\u5c0f\u4f18\u5148\u7ea7\u8d8a\u9ad8\uff0c\u9ed8\u8ba4\u4e3a1024\u3002\n-* `<delay>` \u6574\u578b\u503c\uff0c\u5ef6\u8fdfready\u7684\u79d2\u6570\uff0c\u5728\u8fd9\u6bb5\u65f6\u95f4job\u4e3adelayed\u72b6\u6001\u3002\n-* `<ttr>` -- time to run --\u6574\u578b\u503c\uff0c\u5141\u8bb8worker\u6267\u884c\u7684\u6700\u5927\u79d2\u6570\uff0c\u5982\u679cworker\u5728\u8fd9\u6bb5\u65f6\u95f4\u4e0d\u80fddelete\uff0crelease\uff0cbury job\uff0c\u90a3\u4e48job\u8d85\u65f6\uff0c\u670d\u52a1\u5668\u5c06release\u6b64job\uff0c\u6b64job\u7684\u72b6\u6001\u8fc1\u79fb\u4e3aready\u3002\u6700\u5c0f\u4e3a1\u79d2\uff0c\u5982\u679c\u5ba2\u6237\u7aef\u6307\u5b9a\u4e3a0\u5c06\u4f1a\u88ab\u91cd\u7f6e\u4e3a1\u3002\n-* `<bytes>` \u6574\u578b\u503c\uff0cjob body\u7684\u957f\u5ea6\uff0c\u4e0d\u5305\u542b\\r\\n\uff0c\u8fd9\u4e2a\u503c\u5fc5\u987b\u5c0f\u4e8emax-job-size\uff0c\u9ed8\u8ba4\u4e3a2^16\u3002\n+* `<pri>` \u6574\u578b\u503c, \u4e3a\u4f18\u5148\u7ea7, \u53ef\u4ee5\u4e3a0-2^32 (4,294,967,295) \u503c\u8d8a\u5c0f\u4f18\u5148\u7ea7\u8d8a\u9ad8, \u9ed8\u8ba4\u4e3a1024.\n+* `<delay>` \u6574\u578b\u503c\uff0c\u5ef6\u8fdf`ready`\u7684\u79d2\u6570\uff0c\u5728\u8fd9\u6bb5\u65f6\u95f4 job \u4e3a `delayed` \u72b6\u6001.\n+* `<ttr>` -- time to run --\u6574\u578b\u503c\uff0c\u5141\u8bb8 worker \u6267\u884c\u7684\u6700\u5927\u79d2\u6570\uff0c\u5982\u679c worker \u5728\u8fd9\u6bb5\u65f6\u95f4\u4e0d\u80fd delete\uff0crelease\uff0cbury job\uff0c\u90a3\u4e48\u5f53 job \u8d85\u65f6\uff0c\u670d\u52a1\u5668\u5c06**\u81ea\u52a8** release \u6b64job\uff0c\u6b64 job \u7684\u72b6\u6001\u8fc1\u79fb\u4e3a`ready`. \u6700\u5c0f\u4e3a 1 \u79d2\uff0c\u5982\u679c\u5ba2\u6237\u7aef\u6307\u5b9a\u4e3a 0 \u5c06\u4f1a\u88ab\u91cd\u7f6e\u4e3a 1.\n+* `<bytes>` \u6574\u578b\u503c\uff0cjob body\u7684\u957f\u5ea6\uff0c\u4e0d\u5305\u542b`\\r\\n`\uff0c\u8fd9\u4e2a\u503c\u5fc5\u987b\u5c0f\u4e8e `max-job-size`\uff0c\u9ed8\u8ba4\u4e3a 2^16.\n * `<data>`   job body\n \n+**\u54cd\u5e94**\n \n-\u54cd\u5e94\n-```\n+```text\n INSERTED <id>\\r\\n\n ```\n-\u8868\u793a\u63d2\u5165job\u6210\u529f\uff0cid\u4e3a\u65b0job\u7684\u4efb\u52a1\u6807\u8bc6\uff0c\u6574\u578b\u503c\n-```\n+\n+\u8868\u793a\u63d2\u5165 job \u6210\u529f\uff0cid \u4e3a\u65b0 job \u7684\u4efb\u52a1\u6807\u8bc6\uff0c\u6574\u578b\u503c (uint64)\n+\n+```text\n BURIED <id>\\r\\n\n ```\n-\u5982\u670d\u52a1\u5668\u4e3a\u4e86\u589e\u52a0\u961f\u5217\u7684\u4f18\u5148\u7ea7\u800c\uff0c\u5185\u5b58\u4e0d\u8db3\u65f6\u8fd4\u56de\uff0cid\u4e3a\u65b0job\u7684\u4efb\u52a1\u6807\u8bc6\uff0c\u6574\u578b\u503c\n-```\n+\n+\u5982\u670d\u52a1\u5668\u4e3a\u4e86\u589e\u52a0\u961f\u5217\u7684\u4f18\u5148\u7ea7\u800c\uff0c\u5185\u5b58\u4e0d\u8db3\u65f6\u8fd4\u56de\uff0cid \u4e3a\u65b0 job \u7684\u4efb\u52a1\u6807\u8bc6\uff0c\u6574\u578b\u503c (uint64)\n+\n+```text\n EXPECTED_CRLF\\r\\n\n ```\n-job body\u5fc5\u987b\u4ee5\\r\\n\u7ed3\u5c3e\n-```\n+\n+job body \u5fc5\u987b\u4ee5 `\\r\\n` \u7ed3\u5c3e\n+\n+```text\n JOB_TOO_BIG\\r\\n\n ```\n-job body\u7684\u957f\u5ea6\u8d85\u8fc7max-job-size\n-```\n+\n+job body \u7684\u957f\u5ea6\u8d85\u8fc7 `max-job-size`\n+\n+```text\n DRAINING\\r\\n\n ```\n-\u8868\u793a\u670d\u52a1\u5668\u8d44\u6e90\u8017\u5c3d\uff0c\u8868\u793a\u670d\u52a1\u5668\u5df2\u7ecf\u8fdb\u5165\u4e86\u201cdrain mode\u201d\uff0c\u670d\u52a1\u5668\u518d\u4e5f\u4e0d\u80fd\u63a5\u53d7\u8fde\u63a5\uff0c\u5ba2\u6237\u7aef\u5e94\u8be5\u4f7f\u7528\u53e6\u4e00\u4e2a\u670d\u52a1\u5668\u6216\u8005\u65ad\u5f00\u7a0d\u540e\u91cd\u8bd5\n \n+\u8868\u793a\u670d\u52a1\u5668\u8d44\u6e90\u8017\u5c3d\uff0c\u8868\u793a\u670d\u52a1\u5668\u5df2\u7ecf\u8fdb\u5165\u4e86`drain mode`\uff0c\u670d\u52a1\u5668\u518d\u4e5f\u4e0d\u80fd\u63a5\u53d7\u8fde\u63a5\uff0c\u5ba2\u6237\u7aef\u5e94\u8be5\u4f7f\u7528\u5176\u4ed6\u670d\u52a1\u5668\u6216\u8005\u65ad\u5f00\u7a0d\u540e\u91cd\u8bd5\n \n #### `use`\n-\u8bf4\u660e\n-producer\u751f\u4ea7\u8005\u4f7f\u7528\uff0c\u968f\u540e\u4f7f\u7528put\u547d\u4ee4\uff0c\u5c06job\u653e\u7f6e\u4e8e\u5bf9\u5e94\u7684tube\n-\u683c\u5f0f\n-```\n+\n+producer \u751f\u4ea7\u8005\u4f7f\u7528\uff0c\u4e4b\u540e\u4f7f\u7528\u7684 put \u6307\u4ee4\uff0c\u90fd\u5c06\u4f1a\u628a job \u653e\u7f6e\u4e8e use \u7684 tube \u4e2d\uff0c\u5982\u679c\u6ca1\u6709\u6307\u5b9a use \u7684 tube\uff0c \u4efb\u52a1 job \u5c06\u4f1a\u8fdb\u5165\u9ed8\u8ba4\u540d\u79f0\u4e3a `default` \u7684 tube \n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n use <tube>\\r\\n\n-tube tube\u7684\u540d\u79f0\uff0c\u6700\u5927\u4e3a200\u5b57\u8282\uff0c\u4e0d\u5b58\u5728\u65f6\u5c06\u81ea\u52a8\u521b\u5efa\n+tube tube \u7684\u540d\u79f0\uff0c\u6700\u5927\u4e3a 200 \u5b57\u8282\uff0c\u4e0d\u5b58\u5728\u65f6\u5c06\u81ea\u52a8\u521b\u5efa\n ```\n-\u54cd\u5e94\n-```\n-USING <tube>\\r\\n tube\u4e3a\u6b63\u5728\u4f7f\u7528\u7684tube\u540d\u79f0\n+\n+**\u54cd\u5e94**\n+\n+```text\n+USING <tube>\\r\\n tube \u4e3a\u6b63\u5728\u4f7f\u7528\u7684tube\u540d\u79f0\n ```\n-\u6d88\u8d39\u8005\u6307\u4ee4\u8bf4\u660e\uff08Worker Commands\uff09\n+\n+#### \u6d88\u8d39\u8005\u6307\u4ee4\u8bf4\u660e\uff08Worker Commands\uff09\n \n #### `reserve`\n-\u8bf4\u660e\n-\u53d6\u51fa\uff08\u9884\u8ba2\uff09job\uff0c\u5f85\u5904\u7406\u3002\u5b83\u5c06\u8fd4\u56de\u4e00\u4e2a\u65b0\u9884\u8ba2\u7684job\uff0c\u5982\u679c\u6ca1\u6709job\uff0cbeanstalkd\u5c06\u76f4\u5230\u6709job\u65f6\u624d\u53d1\u9001\u54cd\u5e94\u3002\u4e00\u65e6job\u72b6\u6001\u8fc1\u79fb\u4e3areserved,\u53d6\u51fajob\u7684client\u88ab\u9650\u5236\u5728\u6307\u5b9a\u7684\u65f6\u95f4\uff08\u5982\u679c\u8bbe\u7f6e\u4e86ttr\uff09\u5b8c\u6210\uff0c\u5426\u5219\u8d85\u65f6\uff0cjob\u72b6\u6001\u91cd\u88c5\u8fc1\u79fb\u4e3aready\u3002\n-\u683c\u5f0f\n-```\n+\n+\u9884\u8ba2(reserved) job \u7b49\u5f85\u5904\u7406. beanstalkd \u5c06\u8fd4\u56de\u4e00\u4e2a\u65b0\u9884\u8ba2\u7684 job\uff0c\u5982\u679c\u6ca1\u6709 job\uff0cbeanstalkd \u5c06\u4e00\u76f4\u7b49\u5f85\u5230\u6709 job \u65f6\u624d\u53d1\u9001\u54cd\u5e94. \u4e00\u65e6 job \u72b6\u6001\u8fc1\u79fb\u4e3a `reserved`, \u53d6\u51fa job \u7684 client \u88ab\u9650\u5236\u5728\u6307\u5b9a\u7684\u65f6\u95f4\uff08\u5982\u679c\u8bbe\u7f6e\u4e86ttr\uff09\u5b8c\u6210\uff0c\u5426\u5219\u5c06\u8d85\u65f6\uff0cjob \u72b6\u6001\u91cd\u88c5\u8fc1\u79fb\u4e3aready.\n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n reserve\\r\\n\n ```\n+\n \u53ef\u9009\u7684\u4e00\u4e2a\u76f8\u4f3c\u7684\u547d\u4ee4\n-`reserve-with-timeout <seconds>\\r\\n` \u8bbe\u7f6e\u53d6job\u7684\u8d85\u65f6\u65f6\u95f4\uff0ctimeout\u8bbe\u7f6e\u4e3a0\u65f6\uff0c\u670d\u52a1\u5668\u7acb\u5373\u54cd\u5e94\u6216\u8005TIMED_OUT\uff0c\u79ef\u6781\u7684\u8bbe\u7f6e\u8d85\u65f6\uff0c\u5c06\u4f1a\u9650\u5236\u5ba2\u6237\u7aef\u963b\u585e\u5728\u53d6job\u7684\u8bf7\u6c42\u7684\u65f6\u95f4\u3002\n+`reserve-with-timeout \\r\\n` \u8bbe\u7f6e\u53d6 job \u7684\u8d85\u65f6\u65f6\u95f4\uff0ctimeout \u8bbe\u7f6e\u4e3a 0 \u65f6\uff0c\u670d\u52a1\u5668\u7acb\u5373\u54cd\u5e94\u6216\u8005 TIMED_OUT\uff0c\u79ef\u6781\u7684\u8bbe\u7f6e\u8d85\u65f6\uff0c\u5c06\u4f1a\u9650\u5236\u5ba2\u6237\u7aef\u963b\u585e\u5728\u53d6 job \u7684\u8bf7\u6c42\u7684\u65f6\u95f4.\n+\n ##### \u5931\u8d25\u54cd\u5e94\n-```\n+\n+```text\n DEADLINE_SOON\\r\\n\n ```\n \n-\u5728\u4e00\u4e2a\u9884\u5b9a\u7684\u4efb\u52a1\u7684\u8fd0\u884c\u65f6\u95f4\u5185,\u6700\u540e\u4e00\u79d2\u4f1a\u88ab\u670d\u52a1\u5668\u4fdd\u6301\u4e3a\u4e00\u4e2a\u5b89\u5168\u8fb9\u9645\uff0c\u5728\u6b64\u671f\u95f4\uff0c\u5ba2\u6237\u7aef\u5c06\u65e0\u6cd5\u7b49\u5019\u53e6\u5916\u4e00\u4e2a\u4efb\u52a1\u3002\n-\u5982\u679c\u5ba2\u6237\u7aef\u5728\u5b89\u5168\u9694\u79bb\u671f\u95f4\u53d1\u51fa\u4e00\u4e2a\u9884\u7559\u547d\u4ee4\uff0c\u6216\u8005\u5b89\u5168\u9694\u79bb\u671f\u5230\u4e86,\u5ba2\u6237\u7aef\u5728\u7b49\u5019\u4e00\u4e2a\u9884\u5b9a\u547d\u4ee4\u3002\n-```\n+* \u5728\u4e00\u4e2a\u9884\u5b9a\u7684\u4efb\u52a1 job \u7684\u8fd0\u884c\u65f6\u95f4\u5185, **\u6700\u540e\u4e00\u79d2**\u4f1a\u88ab\u670d\u52a1\u5668\u4fdd\u6301\u4e3a\u4e00\u4e2a**\u5b89\u5168\u8fb9\u9645**\uff0c\u5728\u8fd9\u4e2a**\u65f6\u95f4\u95f4\u9694** (1s) \u4e2d\uff0cclient \u5c06\u65e0\u6cd5\u83b7\u53d6\u5176\u4ed6\u4efb\u52a1. \u5982\u679c\u5ba2\u6237\u7aef\u5728\u5b89\u5168\u9694\u79bb\u671f\u95f4\u53d1\u51fa\u4e00\u4e2a\u9884\u7559 (reserve) \u6307\u4ee4\uff0c\u6216\u8005\u5ba2\u6237\u7aef\u5728\u7b49\u5019\u4e00\u4e2a\u9884\u5b9a (reserve) \u6307\u4ee4\u8fd4\u56de\u7ed3\u679c\u65f6\uff0cclient \u5b89\u5168\u9694\u79bb\u671f\u5230\u8fbe\u65f6\uff0c\u5c06\u4f1a\u6536\u5230 `DEADLINE_SOON` \u56de\u590d\n+* `DEADLINE_SOON` \u7684\u8fd4\u56de\u7ed3\u679c\u63d0\u793a client \u8fd9\u662f\u4e00\u4e2a delete \u6216\u8005 touch \u5b83\u6240\u9884\u8ba2(reserved) \u7684\u4efb\u52a1 job \u7684\u65f6\u673a\uff0c\u4e4b\u540e beanstalkd \u670d\u52a1\u7aef\u5c06\u4f1a\u81ea\u52a8\u91ca\u653e `ttr` \u5230\u671f\u7684 job\n+\n+```text\n TIMED_OUT\\r\\n \u8d85\u65f6\n ```\n+\n ##### \u6210\u529f\u54cd\u5e94\n-```\n+\n+```text\n RESERVED <id> <bytes>\\r\\n\n <data>\\r\\n\n ```\n-\u6210\u529f\u53d6\u51fajob\uff0cid\u4e3ajob id,\u6574\u578b\u503c\uff0cjob body\u7684\u957f\u5ea6\uff0c\u4e0d\u5305\u542b\\r\\n\uff0cdata\u4e3ajob body\n+\n+\u6210\u529f\u53d6\u51fa job:\n+\n+* `<id>` \u4e3a job id,\u6574\u578b\u503c\n+* `<bytes>` \u4e3a job body \u7684\u957f\u5ea6\uff0c\u4e0d\u5305\u542b`\\r\\n`\uff0c\n+* `<data>` \u4e3ajob body\n \n #### `delete`\n-\u8bf4\u660e\n+\n \u4ece\u961f\u5217\u4e2d\u5220\u9664\u4e00\u4e2ajob\n-\u683c\u5f0f\n-```\n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n delete <id>\\r\\n\n ```\n-id\u4e3ajob id\n-\u54cd\u5e94\n-DELETED\\r\\n \u5220\u9664\u6210\u529f\n-NOT_FOUND\\r\\n job\u4e0d\u5b58\u5728\u65f6\uff0c\u6216\u8005job\u7684\u72b6\u6001\u4e0d\u4e3aready\u548cburied\uff08\u8fd9\u79cd\u60c5\u51b5\u662f\u5728job\u6267\u884c\u8d85\u65f6\u4e4b\u524d\uff0cclient\u53d1\u9001\u4e86delete\u6307\u4ee4\uff09\n-#### `release`\n-\u8bf4\u660e\n-release\u6307\u4ee4\u5c06\u4e00\u4e2areserved\u7684job\u653e\u56deready queue\u3002\u5b83\u901a\u5e38\u5728job\u6267\u884c\u5931\u8d25\u65f6\u4f7f\u7528\u3002\n-\u683c\u5f0f\n+\n+* `<id>` \u4e3a job id\n+\n+**\u54cd\u5e94**\n+\n+```text\n+DELETED\\r\\n\n ```\n+\n+* \u5220\u9664\u6210\u529f\n+\n+```text\n+NOT_FOUND\\r\\n\n+```\n+\n+* job \u4e0d\u5b58\u5728\u65f6\uff0c\u6216\u8005 job \u5e76\u4e0d\u4e3a\u5f53\u524d\u7684 client \u6240 reserved;\n+* job \u7684\u72b6\u6001\u4e0d\u4e3a `ready`\u548c `buried`\uff08\u8fd9\u79cd\u60c5\u51b5\u662f\u5728 job \u88ab\u5176\u4ed6 client \u6240\u9884\u8ba2(reserved) \u4e14\u8fd8\u672a\u6267\u884c\u8d85\u65f6\uff0c\u6b64\u65f6\u5f53\u524d client \u53d1\u9001\u4e86 delete \u6307\u4ee4\u5c31\u4f1a\u6536\u5230 `NOT_FOUND` \u56de\u590d\uff09\n+\n+#### `release`\n+\n+release \u6307\u4ee4\u5c06\u4e00\u4e2a`reserved`\u7684 job \u6062\u590d\u4e3a`ready`. \u5b83\u901a\u5e38\u5728 job \u6267\u884c\u5931\u8d25\u65f6\u4f7f\u7528.\n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n release <id> <pri> <delay>\\r\\n\n ```\n-id \u4e3ajob id\uff0cpri\u4e3ajob\u7684\u4f18\u5148\u7ea7\uff0cdelay\u4e3a\u5ef6\u8fdfready\u7684\u79d2\u6570\n-\u54cd\u5e94\n+\n+* `<id>` \u4e3ajob id\n+* `<pri>` \u4e3a job \u7684\u4f18\u5148\u7ea7\n+* `<delay>` \u4e3a\u5ef6\u8fdf`ready`\u7684\u79d2\u6570\n+\n+\n+**\u54cd\u5e94**\n+\n+```text\n RELEASED\\r\\n \u8868\u660e\u6210\u529f\n BURIED\\r\\n \u5982\u670d\u52a1\u5668\u4e3a\u4e86\u589e\u52a0\u961f\u5217\u7684\u4f18\u5148\u7ea7\u800c\uff0c\u5185\u5b58\u4e0d\u8db3\u65f6\u8fd4\u56de\n-NOT_FOUND\\r\\n \u5982\u679cjob\u4e0d\u5b58\u5728\u6216\u8005client\u6ca1\u6709\u9884\u8ba2\u6b64job\n-\n-#### `bury`\n-\u8bf4\u660e\n-\u5c06\u4e00\u4e2ajob\u7684\u72b6\u6001\u8fc1\u79fb\u4e3aburied\uff0c\u901a\u8fc7kick\u547d\u4ee4\u5524\u9192\n-\u683c\u5f0f\n-```\n bury <id> <pri>\\r\\n\n ```\n-id\u4e3ajob id\uff0cpri\u4e3a\u4f18\u5148\u7ea7\n-\u54cd\u5e94\n+\n+* `<id>` \u4e3a job id\n+* `<pri>` \u4e3a\u4f18\u5148\u7ea7\n+\n+**\u54cd\u5e94**\n+\n+```text\n BURIED\\r\\n \u8868\u660e\u6210\u529f\n-NOT_FOUND\\r\\n \u5982\u679cjob\u4e0d\u5b58\u5728\u6216\u8005client\u6ca1\u6709\u9884\u8ba2\u6b64job\n-#### `touch`\n-\u8bf4\u660e\n-\u5141\u8bb8worker\u8bf7\u6c42\u66f4\u591a\u7684\u65f6\u95f4\u6267\u884cjob\uff0c\u8fd9\u4e2a\u5f88\u6709\u7528\u5f53job\u9700\u8981\u5f88\u957f\u7684\u65f6\u95f4\u6765\u6267\u884c\uff0cworker\u53ef\u7528\u5468\u671f\u7684\u544a\u8bc9\u670d\u52a1\u5668\u5b83\u4ecd\u7136\u5728\u6267\u884cjob\uff08\u53ef\u4ee5\u88abDEADLINE_SOON\u89e6\u53d1\uff09\n-\u683c\u5f0f\n+NOT_FOUND\\r\\n \u5982\u679c job \u4e0d\u5b58\u5728\u6216\u8005 client \u6ca1\u6709\u9884\u8ba2\u6b64 job\n ```\n+\n+#### `touch`\n+\n+\u5141\u8bb8 worker \u8bf7\u6c42\u66f4\u591a\u7684\u65f6\u95f4\u6267\u884c job\uff1b\u5f53 job \u9700\u8981\u66f4\u957f\u7684\u65f6\u95f4\u6765\u6267\u884c\uff0c\u8fd9\u4e2a\u6307\u4ee4\u5c31\u5c06\u4f1a\u8d77\u4f5c\u7528\uff0cworker \u53ef\u7528\u5468\u671f\u6027\u7684\u544a\u8bc9\u670d\u52a1\u5668\u5b83\u4ecd\u7136\u5728\u6267\u884cjob\uff08\u53ef\u4ee5\u88ab `DEADLINE_SOON` \u89e6\u53d1\uff09\n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n touch <id>\\r\\n\n ```\n-id\u4e3ajob id\n-\u54cd\u5e94\n+\n+* `<id>` \u4e3a job id\n+\n+**\u54cd\u5e94**\n+\n+```text\n TOUCHED\\r\\n \u8868\u660e\u6210\u529f\n-NOT_FOUND\\r\\n \u5982\u679cjob\u4e0d\u5b58\u5728\u6216\u8005client\u6ca1\u6709\u9884\u8ba2\u6b64job\n+NOT_FOUND\\r\\n \u5982\u679c job \u4e0d\u5b58\u5728\u6216\u8005 client \u6ca1\u6709\u9884\u8ba2\u6b64 job\n+```\n \n #### `watch`\n-\u8bf4\u660e\n-\u6dfb\u52a0\u76d1\u63a7\u7684tube\u5230watch list\u5217\u8868\uff0creserve\u6307\u4ee4\u5c06\u4f1a\u4ece\u76d1\u63a7\u7684tube\u5217\u8868\u83b7\u53d6job\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u8fde\u63a5\uff0c\u76d1\u63a7\u7684\u5217\u8868\u9ed8\u8ba4\u4e3adefault\n-\u683c\u5f0f\n-```\n+\n+\u6dfb\u52a0\u76d1\u63a7\u7684 tube \u5230 watch list \u5217\u8868\uff0creserve \u6307\u4ee4\u5c06\u4f1a\u4ece\u76d1\u63a7\u7684 tube \u5217\u8868\u83b7\u53d6 job\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u8fde\u63a5\uff0c\u76d1\u63a7\u7684\u5217\u8868\u9ed8\u8ba4\u4e3a `default`\n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n watch <tube>\\r\\n\n ```\n-tube \u4e3a\u76d1\u63a7\u7684tube\u540d\u79f0\uff0c\u540d\u79f0\u6700\u5927\u4e3a200\u5b57\u8282\uff0c\u5982\u679ctube\u4e0d\u5b58\u5728\u4f1a\u81ea\u52a8\u521b\u5efa\n-\u54cd\u5e94\n-```\n+\n+* `<tube>` \u4e3a\u76d1\u63a7\u7684 tube \u540d\u79f0\uff0c\u540d\u79f0\u6700\u5927\u4e3a 200 \u5b57\u8282\uff0c\u5982\u679c tube \u4e0d\u5b58\u5728\u4f1a**\u81ea\u52a8\u521b\u5efa**\n+\n+**\u54cd\u5e94**\n+\n+```text\n WATCHING <count>\\r\\n \u8868\u660e\u6210\u529f\n ```\n-count \u6574\u578b\u503c\uff0c\u5df2\u76d1\u63a7\u7684tube\u6570\u91cf\n \n-#### `ignore`\n-\u8bf4\u660e\n-\u4ece\u5df2\u76d1\u63a7\u7684watch list\u5217\u8868\u4e2d\u79fb\u51fa\u7279\u5b9a\u7684tube\n-\u683c\u5f0f\n-```\n+* `<count>` \u6574\u578b\u503c\uff0c\u5df2\u76d1\u63a7\u7684 tube \u6570\u91cf\n+\n+####`ignore`\n+\n+\u4ece\u5df2\u76d1\u63a7\u7684 watch list \u5217\u8868\u4e2d\u79fb\u51fa\u7279\u5b9a\u7684 tube \n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n ignore <tube>\\r\\n\n ```\n-tube \u4e3a\u79fb\u51fa\u7684tube\u540d\u79f0\uff0c\u540d\u79f0\u6700\u591a\u4e3a200\u5b57\u8282\uff0c\u5982\u679ctube\u4e0d\u5b58\u5728\u4f1a\u81ea\u52a8\u521b\u5efa\n-\u54cd\u5e94\n-```\n+\n+* `<tube>` \u4e3a\u79fb\u51fa\u7684 tube \u540d\u79f0\uff0c\u540d\u79f0\u6700\u591a\u4e3a 200 \u5b57\u8282\uff0c\u5982\u679c tube \u4e0d\u5b58\u5728\u4f1a\u81ea\u52a8\u521b\u5efa\n+\n+**\u54cd\u5e94**\n+\n+```text\n WATCHING <count>\\r\\n \u8868\u660e\u6210\u529f\n ```\n-count \u6574\u578b\u503c\uff0c\u5df2\u76d1\u63a7\u7684tube\u6570\u91cf\n-NOT_IGNORED\\r\\n \u5982\u679cclient\u4f01\u56fe\u5ffd\u7565\u5176\u4ec5\u6709\u7684tube\u65f6\u7684\u54cd\u5e94\n-\u5176\u4ed6\u6307\u4ee4\u8bf4\u660e\uff08Other Command\uff09\n \n-#### `peek`\n-\u8bf4\u660e\n-\u8ba9client\u5728\u7cfb\u7edf\u4e2d\u68c0\u67e5job\uff0c\u6709\u56db\u79cd\u5f62\u5f0f\u7684\u547d\u4ee4\uff0c\u9664\u7b2c\u4e00\u79cd\u5f62\u5f0f\u5916\uff0c\u5176\u5b83\u5747\u9488\u5bf9\u5f53\u524d\u6b63\u5728\u4f7f\u7528\u7684tube\u3002\n-\u683c\u5f0f\n-```\n-peek <id>\\r\\n  \u8fd4\u56deid\u5bf9\u5e94\u7684job\n-peek-ready\\r\\n \u8fd4\u56de\u4e0b\u4e00\u4e2aready job\n-peek-delayed\\r\\n \u8fd4\u56de\u4e0b\u4e00\u4e2a\u5ef6\u8fdf\u5269\u4f59\u65f6\u95f4\u6700\u77ed\u7684job\n-peek-buried\\r\\n \u8fd4\u56de\u4e0b\u4e00\u4e2a\u5728buried\u5217\u8868\u4e2d\u7684job\n+* `<count>` \u6574\u578b\u503c\uff0c\u5df2\u76d1\u63a7\u7684tube\u6570\u91cf\n+\n+```text\n+NOT_IGNORED\\r\\n\n ```\n-\u54cd\u5e94\n-NOT_FOUND\\r\\n \u5982\u679cjob\u4e0d\u5b58\u5728\uff0c\u6216\u8005\u6ca1\u6709\u5bf9\u5e94\u72b6\u6001\u7684job\n+\n+* \u5982\u679c client \u5c1d\u8bd5\u5ffd\u7565\u5176\u4ec5\u6709\u7684tube\u65f6\u7684\u54cd\u5e94\n+\n+#### \u5176\u4ed6\u6307\u4ee4\u8bf4\u660e\uff08Other Command\uff09\n+\n+#### `peek`\n+\n+\u8ba9 client \u5728\u7cfb\u7edf\u4e2d\u68c0\u67e5 job\uff0c\u6709\u56db\u79cd\u5f62\u5f0f\u7684\u547d\u4ee4\uff0c\u5176\u4e2d\u7b2c\u4e00\u79cd\u5f62\u5f0f\u7684\u6307\u4ee4\u662f\u9488\u5bf9\u5f53\u524d\u4f7f\u7528 (use) \u7684 tube\n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n+peek <id>\\r\\n  \u8fd4\u56de id \u5bf9\u5e94\u7684 job\n+peek-ready\\r\\n \u8fd4\u56de\u4e0b\u4e00\u4e2a ready job\n+peek-delayed\\r\\n \u8fd4\u56de\u4e0b\u4e00\u4e2a\u5ef6\u8fdf\u5269\u4f59\u65f6\u95f4\u6700\u77ed\u7684 job\n+peek-buried\\r\\n \u8fd4\u56de\u4e0b\u4e00\u4e2a\u5728 buried \u5217\u8868\u4e2d\u7684 job\n ```\n+\n+**\u54cd\u5e94**\n+\n+```text\n+NOT_FOUND\\r\\n\n+``` \n+\n+* \u5982\u679c job \u4e0d\u5b58\u5728\uff0c\u6216\u8005\u6ca1\u6709\u5bf9\u5e94\u72b6\u6001\u7684 job\n+\n+```text\n FOUND <id> <bytes>\\r\\n <data>\\r\\n\n ```\n-id \u4e3a\u5bf9\u5e94\u7684job id\n-bytes job body\u7684\u5b57\u8282\u6570\n-data \u4e3ajob body\n+\n+* `<id>` \u4e3a\u5bf9\u5e94\u7684 job id\n+* `<bytes>` job body \u7684\u5b57\u8282\u6570\n+* `<data>` \u4e3a job body\n \n #### `kick`\n-\u8bf4\u660e\n-\u6b64\u6307\u4ee4\u5e94\u7528\u5728\u5f53\u524d\u4f7f\u7528\u7684tube\u4e2d\uff0c\u5b83\u5c06job\u7684\u72b6\u6001\u8fc1\u79fb\u4e3aready\u6216\u8005delayed\n-\u683c\u5f0f\n-```\n+\n+\u6b64\u6307\u4ee4\u5e94\u7528\u5728\u5f53\u524d\u4f7f\u7528 (use) \u7684 tube \u4e2d\uff0c\u5b83\u5c06 job \u7684\u72b6\u6001\u8fc1\u79fb\u4e3a`ready`\u6216\u8005`delayed`\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n kick <bound>\\r\\n\n ```\n-bound \u6574\u578b\u503c\uff0c\u5524\u9192\u7684job\u4e0a\u9650\n \n-\u54cd\u5e94\n+* `<bound>` \u6574\u578b\u503c\uff0c\u5524\u9192\u7684 job \u4e0a\u9650\n+\n+**\u54cd\u5e94**\n+\n ```\n KICKED <count>\\r\\n\n ```\n-count \u4e3a\u771f\u5b9e\u5524\u9192\u7684job\u6570\u91cf\n-kick-job\n-\u8bf4\u660e\n-kick\u6307\u4ee4\u7684\u4e00\u4e2a\u53d8\u4f53\uff0c\u53ef\u4ee5\u4f7f\u5355\u4e2ajob\u88ab\u5524\u9192\uff0c\u4f7f\u4e00\u4e2a\u72b6\u6001\u4e3aburied\u6216\u8005delayed\u7684job\u8fc1\u79fb\u4e3aready\uff0c\u6240\u6709\u7684\u72b6\u6001\u8fc1\u79fb\u90fd\u5728\u76f8\u540c\u7684tube\u4e2d\u5b8c\u6210\n-\u683c\u5f0f\n-```\n+* `<count>` \u4e3a\u771f\u5b9e\u5524\u9192\u7684job\u6570\u91cf\n+\n+#### kick-job\n+\n+kick \u6307\u4ee4\u7684\u4e00\u4e2a\u53d8\u4f53\uff0c\u53ef\u4ee5\u4f7f\u5355\u4e2a job \u88ab\u5524\u9192\uff0c\u4f7f\u4e00\u4e2a\u72b6\u6001\u4e3a`buried`\u6216\u8005`delayed`\u7684 job\u8fc1\u79fb\u4e3a`ready`\uff0c\u6240\u6709\u7684\u72b6\u6001\u8fc1\u79fb\u90fd\u5728\u76f8\u540c\u7684 tube \u4e2d\u5b8c\u6210\n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n kick-job <id>\\r\\n\n ```\n-id \u4e3ajob id\n-\u54cd\u5e94\n-NOT_FOUND\\r\\n \u5982\u679cjob\u4e0d\u5b58\u5728\uff0c\u6216\u8005job\u662f\u4e0d\u53ef\u5524\u9192\u7684\u72b6\u6001\n-KICKED\\r\\n \u8868\u660e\u6210\u529f\n+* `<id>` \u4e3ajob id\n+\n+**\u54cd\u5e94**\n+`NOT_FOUND\\r\\n` \u5982\u679c job \u4e0d\u5b58\u5728\uff0c\u6216\u8005 job \u662f\u4e0d\u53ef\u5524\u9192\u7684\u72b6\u6001\n+`KICKED\\r\\n` \u8868\u660e\u6210\u529f\n \n #### `stats-job`\n-\u8bf4\u660e\n-\u7edf\u8ba1job\u7684\u76f8\u5173\u4fe1\u606f\n-\u683c\u5f0f\n-```\n+\n+\u7edf\u8ba1 job \u7684\u76f8\u5173\u4fe1\u606f\n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n stats-job <id>\\r\\n\n ```\n-id \u4e3ajob id\n-\u54cd\u5e94\n-```\n+\n+* `<id>` \u4e3a job id\n+\n+**\u54cd\u5e94**\n+\n+```text\n NOT_FOUND\\r\\n \u5982\u679cjob\u4e0d\u5b58\u5728\n \n OK <bytes>\\r\\n<data>\\r\\n\n ```\n-bytes \u4e3a\u63a5\u4e0b\u6765\u7684data\u533a\u5757\u7684\u957f\u5ea6\n-data \u4e3aYAML file\u7684\u7edf\u8ba1\u4fe1\u606f\n-\u5176\u4e2dYAML file\u5305\u62ec\u7684key\u6709\uff1a\n-- `id` \u8868\u793ajob id\n-- `tube` \u8868\u793atube\u7684\u540d\u79f0\n-- `state` \u8868\u793ajob\u7684\u5f53\u524d\u72b6\u6001\n-- `pri` \u8868\u793ajob\u7684\u4f18\u5148\u7ea7\n-- `age` \u8868\u793ajob\u521b\u5efa\u7684\u65f6\u95f4\u5355\u4f4d\u79d2\n-- `delay` \u662f\u5ef6\u8fdfjob\u653e\u5165ready\u961f\u5217\u7684\u6574\u6570\u79d2\u6570\n-- `ttr` \u6307\u5141\u8bb8worker\u6267\u884cjob\u7684\u6574\u6570\u79d2\u6570\n-- `time-left` \u8868\u793ajob\u7684\u72b6\u6001\u8fc1\u79fb\u4e3aready\u7684\u65f6\u95f4\uff0c\u4ec5\u5728job\u72b6\u6001\u4e3areserved\u6216\u8005delayed\u65f6\u6709\u610f\u4e49\uff0c\u5f53job\u72b6\u6001\u4e3areserved\u65f6\u8868\u793a\u5269\u4f59\u7684\u8d85\u65f6\u65f6\u95f4\u3002\n-- `file` \u8868\u793a\u5305\u542b\u6b64job\u7684binlog\u5e8f\u53f7\uff0c\u5982\u679c\u6ca1\u6709\u5f00\u542f\u5b83\u5c06\u4e3a0\n-- `reserves` \u8868\u793ajob\u88abreserved\u7684\u6b21\u6570\n-- `timeouts` \u8868\u793ajob\u51fa\u73b0\u8d85\u65f6\u7684\u6b21\u6570\n-- `releases` \u8868\u793ajob\u88abreleased\u7684\u6b21\u6570\n-- `buries` \u8868\u793ajob\u88abburied\u7684\u6b21\u6570\n-- `kicks` \u8868\u793ajob\u88abkiced\u7684\u6b21\u6570\n+\n+* `<bytes>` \u4e3a\u63a5\u4e0b\u6765\u7684 data \u533a\u5757\u7684\u957f\u5ea6\n+* `<data>` \u4e3a YAML file \u7684\u7edf\u8ba1\u4fe1\u606f\n+\n+\u5176\u4e2d YAML file \u5305\u62ec\u7684 key \u6709:\n+\n+* `id` \u8868\u793a job id\n+* `tube` \u8868\u793a tube \u7684\u540d\u79f0\n+* `state` \u8868\u793a job \u7684\u5f53\u524d\u72b6\u6001\n+* `pri` \u8868\u793a job \u7684\u4f18\u5148\u7ea7\n+* `age` \u8868\u793a job \u521b\u5efa\u7684\u65f6\u95f4\u5355\u4f4d\u79d2\n+* `time-left` \u8868\u793a job \u7684\u72b6\u6001\u8fc1\u79fb\u4e3a ready \u7684\u65f6\u95f4\uff0c\u4ec5\u5728 job \u72b6\u6001\u4e3a`reserved`\u6216\u8005`delayed`\u65f6\u6709\u610f\u4e49\uff0c\u5f53 job \u72b6\u6001\u4e3a`reserved`\u65f6\u8868\u793a\u5269\u4f59\u7684\u8d85\u65f6\u65f6\u95f4.\n+* `file` \u8868\u793a\u5305\u542b\u6b64 job \u7684`binlog`\u5e8f\u53f7\uff0c\u5982\u679c\u6ca1\u6709\u5f00\u542f\u5b83\u5c06\u4e3a 0\n+* `reserves` \u8868\u793a job \u88ab`reserved`\u7684\u6b21\u6570\n+* `timeouts` \u8868\u793a job \u5904\u7406\u7684\u8d85\u65f6\u65f6\u95f4\n+* `releases` \u8868\u793a job \u88ab`released`\u7684\u6b21\u6570\n+* `buries` \u8868\u793a job \u88ab`buried`\u7684\u6b21\u6570\n+* `kicks` \u8868\u793a job \u88ab`kiced`\u7684\u6b21\u6570\n \n #### `stats-tube`\n-**\u8bf4\u660e**\n-\u7edf\u8ba1tube\u7684\u76f8\u5173\u4fe1\u606f\n-**\u683c\u5f0f**\n-```\n+\n+\u7edf\u8ba1 tube \u7684\u76f8\u5173\u4fe1\u606f\n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n stats-tube <tube>\\r\\n\n ```\n-tube \u4e3a\u5bf9\u5e94\u7684tube\u7684\u540d\u79f0\uff0c\u6700\u591a\u4e3a200\u5b57\u8282\n+\n+* `<tube>` \u4e3a\u5bf9\u5e94\u7684 tube \u7684\u540d\u79f0\uff0c\u6700\u591a\u4e3a 200 \u5b57\u8282\n+\n **\u54cd\u5e94**\n+\n+```text\n+NOT_FOUND\\r\\n\n ```\n-NOT_FOUND\\r\\n \u5982\u679ctube\u4e0d\u5b58\u5728\n-OK <bytes>\\r\\n<data>\\r\\n\n+* \u5982\u679ctube\u4e0d\u5b58\u5728\n+\n+```text\n+OK <bytes>\\r\\n\n+<data>\\r\\n\n ```\n-bytes \u4e3a\u63a5\u4e0b\u6765\u7684data\u533a\u5757\u7684\u957f\u5ea6\n-data \u4e3aYAML file\u7684\u7edf\u8ba1\u4fe1\u606f\n-\u5176\u4e2dYAML file\u5305\u62ec\u7684key\u6709\uff1a\n-- `name` \u8868\u793atube\u7684\u540d\u79f0\n-- `current-jobs-urgent` \u6b64tube\u4e2d\u4f18\u5148\u7ea7\u5c0f\u4e8e1024\u72b6\u6001\u4e3aready\u7684job\u6570\u91cf\n-- `current-jobs-ready` \u6b64tube\u4e2d\u72b6\u6001\u4e3aready\u7684job\u6570\u91cf\n-- `current-jobs-reserved` \u6b64tube\u4e2d\u72b6\u6001\u4e3areserved\u7684job\u6570\u91cf\n-- `current-jobs-delayed` \u6b64tube\u4e2d\u72b6\u6001\u4e3adelayed\u7684job\u6570\u91cf\n-- `current-jobs-buried` \u6b64tube\u4e2d\u72b6\u6001\u4e3aburied\u7684job\u6570\u91cf\n-- `total-jobs` \u6b64tube\u4e2d\u521b\u5efa\u7684\u6240\u6709job\u6570\u91cf\n-- `current-using` \u4f7f\u7528\u6b64tube\u6253\u5f00\u7684\u8fde\u63a5\u6570\n-- `current-wating` \u4f7f\u7528\u6b64tube\u6253\u5f00\u8fde\u63a5\u5e76\u4e14\u7b49\u5f85\u54cd\u5e94\u7684\u8fde\u63a5\u6570\n-- `current-watching` \u6253\u5f00\u7684\u8fde\u63a5\u76d1\u63a7\u6b64tube\u7684\u6570\u91cf\n-- `pause` \u6b64tube\u6682\u505c\u7684\u79d2\u6570\n-- `cmd-delete` \u6b64tube\u4e2d\u603b\u5171\u6267\u884c\u7684delete\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-pause-tube` \u6b64tube\u4e2d\u603b\u5171\u6267\u884cpause-tube\u6307\u4ee4\u7684\u6b21\u6570\n-- `pause-time-left` \u6b64tube\u6682\u505c\u5269\u4f59\u7684\u79d2\u6570\n+\n+* `<bytes>` \u4e3a\u63a5\u4e0b\u6765\u7684 data \u533a\u5757\u7684\u957f\u5ea6\n+* `<data>` \u4e3a YAML file\u7684\u7edf\u8ba1\u4fe1\u606f\n+\n+\u5176\u4e2d YAML file \u5305\u62ec\u7684 key \u6709\uff1a\n+\n+* `name` \u8868\u793atube\u7684\u540d\u79f0\n+* `current-jobs-urgent` \u6b64 tube \u4e2d\u4f18\u5148\u7ea7\u5c0f\u4e8e 1024 \u72b6\u6001\u4e3a`ready`\u7684 job \u6570\u91cf\n+* `current-jobs-ready` \u6b64 tube \u4e2d\u72b6\u6001\u4e3a`ready`\u7684 job \u6570\u91cf\n+* `current-jobs-reserved` \u6b64 tube \u4e2d\u72b6\u6001\u4e3a`reserved`\u7684 job \u6570\u91cf\n+* `current-jobs-delayed` \u6b64 tube \u4e2d\u72b6\u6001\u4e3a`delayed`\u7684 job \u6570\u91cf\n+* `current-jobs-bureid` \u6b64 tube \u4e2d\u72b6\u6001\u4e3a`buried`\u7684job\u6570\u91cf\n+* `total-jobs` \u6b64 tube \u4e2d\u521b\u5efa\u7684\u6240\u6709job\u6570\u91cf\n+* `current-using` \u4f7f\u7528\u6b64 tube \u6253\u5f00\u7684\u8fde\u63a5\u6570\n+* `current-wating` \u4f7f\u7528\u6b64 tube \u6253\u5f00\u8fde\u63a5\u5e76\u4e14\u7b49\u5f85\u54cd\u5e94\u7684\u8fde\u63a5\u6570\n+* `current-watching` \u6253\u5f00\u7684\u8fde\u63a5\u76d1\u63a7\u6b64 tube \u7684\u6570\u91cf\n+* `pause` \u6b64 tube \u6682\u505c\u7684\u79d2\u6570\n+* `cmd-delete` \u6b64 tube \u4e2d\u603b\u5171\u6267\u884c\u7684`delete`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-pause-tube` \u6b64 tube \u4e2d\u603b\u5171\u6267\u884c`pause-tube`\u6307\u4ee4\u7684\u6b21\u6570\n+* `pause-time-left` \u6b64 tube \u6682\u505c\u5269\u4f59\u7684\u79d2\u6570\n \n #### `stats`\n-**\u8bf4\u660e**\n+\n \u8fd4\u56de\u6574\u4e2a\u6d88\u606f\u961f\u5217\u7cfb\u7edf\u7684\u6574\u4f53\u4fe1\u606f\n-**\u683c\u5f0f**\n-```\n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n stats\\r\\n\n ```\n+\n **\u54cd\u5e94**\n+\n+```text\n+OK <bytes>\\r\\n\n+<data>\\r\\n\n ```\n-OK <bytes>\\r\\n<data>\\r\\n\n-```\n-bytes \u4e3a\u63a5\u4e0b\u6765\u7684data\u533a\u5757\u7684\u957f\u5ea6\n-data \u4e3aYAML file\u7684\u7edf\u8ba1\u4fe1\u606f\n-\u5176\u4e2dYAML file\u5305\u62ec\u7684key\u6709\uff08\u6240\u6709\u7684\u4fe1\u606f\u90fd\u7d2f\u79ef\u7684\uff0c\u81ea\u4ecebeanstalkd\u8fdb\u7a0b\u542f\u52a8\u4ee5\u6765\uff0c\u8fd9\u4e9b\u4fe1\u606f\u4e0d\u50a8\u5b58\u5728binlog\u4e2d\uff09\uff1a\n-- `current-jobs-urgent` \u4f18\u5148\u7ea7\u5c0f\u4e8e1024\u72b6\u6001\u4e3aready\u7684job\u6570\u91cf\n-- `current-jobs-ready` \u72b6\u6001\u4e3aready\u7684job\u6570\u91cf\n-- `current-jobs-reserved` \u72b6\u6001\u4e3areserved\u7684job\u6570\u91cf\n-- `current-jobs-delayed` \u72b6\u6001\u4e3adelayed\u7684job\u6570\u91cf\n-- `current-jobs-buried` \u72b6\u6001\u4e3aburied\u7684job\u6570\u91cf\n-- `cmd-put` \u603b\u5171\u6267\u884cput\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-peek` \u603b\u5171\u6267\u884cpeek\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-peek-ready` \u603b\u5171\u6267\u884cpeek-ready\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-peek-delayed` \u603b\u5171\u6267\u884cpeek-delayed\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-peek-buried` \u603b\u5171\u6267\u884cpeek-buried\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-reserve` \u603b\u5171\u6267\u884creserve\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-use` \u603b\u5171\u6267\u884cuse\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-watch` \u603b\u5171\u6267\u884cwatch\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-ignore` \u603b\u5171\u6267\u884cignore\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-release` \u603b\u5171\u6267\u884crelease\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-bury` \u603b\u5171\u6267\u884cbury\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-kick` \u603b\u5171\u6267\u884ckick\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-stats` \u603b\u5171\u6267\u884cstats\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-stats-job` \u603b\u5171\u6267\u884cstats-job\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-stats-tube` \u603b\u5171\u6267\u884cstats-tube\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-list-tubes` \u603b\u5171\u6267\u884clist-tubes\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-list-tube-used` \u603b\u5171\u6267\u884clist-tube-used\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-list-butes-watched` \u603b\u5171\u6267\u884clist-tubes-watched\u6307\u4ee4\u7684\u6b21\u6570\n-- `cmd-pause-tube` \u603b\u5171\u6267\u884cpause-tube\u6307\u4ee4\u7684\u6b21\u6570\n-- `job-timeouts` \u6240\u6709\u8d85\u65f6\u7684job\u7684\u603b\u5171\u6570\u91cf\n-- `total-jobs` \u521b\u5efa\u7684\u6240\u6709job\u6570\u91cf\n-- `max-job-size` job\u7684\u6570\u636e\u90e8\u5206\u6700\u5927\u957f\u5ea6\n-- `current-tubes` \u5f53\u524d\u5b58\u5728\u7684tube\u6570\u91cf\n-- `current-connections` \u5f53\u524d\u6253\u5f00\u7684\u8fde\u63a5\u6570\n-- `current-producers` \u5f53\u524d\u6240\u6709\u7684\u6253\u5f00\u7684\u8fde\u63a5\u4e2d\u81f3\u5c11\u6267\u884c\u4e00\u6b21put\u6307\u4ee4\u7684\u8fde\u63a5\u6570\u91cf\n-- `current-workers` \u5f53\u524d\u6240\u6709\u7684\u6253\u5f00\u7684\u8fde\u63a5\u4e2d\u81f3\u5c11\u6267\u884c\u4e00\u6b21reserve\u6307\u4ee4\u7684\u8fde\u63a5\u6570\u91cf\n-- `current-waiting` \u5f53\u524d\u6240\u6709\u7684\u6253\u5f00\u7684\u8fde\u63a5\u4e2d\u6267\u884creserve\u6307\u4ee4\u4f46\u662f\u672a\u54cd\u5e94\u7684\u8fde\u63a5\u6570\u91cf\n-- `total-connections` \u603b\u5171\u5904\u7406\u7684\u8fde\u63a5\u6570\n-- `pid` \u670d\u52a1\u5668\u8fdb\u7a0b\u7684id\n-- `version` \u670d\u52a1\u5668\u7248\u672c\u53f7\n-- `rusage-utime` \u8fdb\u7a0b\u603b\u5171\u5360\u7528\u7684\u7528\u6237CPU\u65f6\u95f4\n-- `rusage-stime` \u8fdb\u7a0b\u603b\u5171\u5360\u7528\u7684\u7cfb\u7edfCPU\u65f6\u95f4\n-- `uptime` \u670d\u52a1\u5668\u8fdb\u7a0b\u8fd0\u884c\u7684\u79d2\u6570\n-- `binlog-oldest-index` \u5f00\u59cb\u50a8\u5b58jobs\u7684binlog\u7d22\u5f15\u53f7\n-- `binlog-current-index` \u5f53\u524d\u50a8\u5b58jobs\u7684binlog\u7d22\u5f15\u53f7\n-- `binlog-max-size binlog`\u7684\u6700\u5927\u5bb9\u91cf\n-- `binlog-records-written` binlog\u7d2f\u79ef\u5199\u5165\u7684\u8bb0\u5f55\u6570\n-- `binlog-records-migrated` is the cumulative number of records written as part of compaction.\n-- `id` \u4e00\u4e2a\u968f\u673a\u5b57\u7b26\u4e32\uff0c\u5728beanstalkd\u8fdb\u7a0b\u542f\u52a8\u65f6\u4ea7\u751f\n-- `hostname` \u4e3b\u673a\u540d\n+* `<bytes>` \u4e3a\u63a5\u4e0b\u6765\u7684 data \u533a\u5757\u7684\u957f\u5ea6\n+* `<data>` \u4e3a YAML file \u7684\u7edf\u8ba1\u4fe1\u606f\n+\n+\u4ece beanstalkd \u8fdb\u7a0b\u542f\u52a8\u4ee5\u6765\uff0c\u6240\u6709\u7684\u4fe1\u606f\u90fd\u7d2f\u79ef\u7684\uff0c\u8fd9\u4e9b\u4fe1\u606f\u4e0d\u50a8\u5b58\u5728 binlog \u4e2d\n+\u5176\u4e2d YAML file \u5305\u62ec\u7684key\u6709\uff1a\n+\n+* `current-jobs-urgent` \u4f18\u5148\u7ea7\u5c0f\u4e8e 1024 \u72b6\u6001\u4e3a`ready`\u7684 job \u6570\u91cf\n+* `current-jobs-ready` \u72b6\u6001\u4e3a`ready`\u7684 job \u6570\u91cf\n+* `current-jobs-reserved` \u72b6\u6001\u4e3a`reserved`\u7684 job \u6570\u91cf\n+* `current-jobs-delayed` \u72b6\u6001\u4e3a`delayed`\u7684 job \u6570\u91cf\n+* `current-jobs-bureid` \u72b6\u6001\u4e3a`buried`\u7684 job \u6570\u91cf\n+* `cmd-put` \u603b\u5171\u6267\u884c`put`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-peek` \u603b\u5171\u6267\u884c`peek`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-peek-ready` \u603b\u5171\u6267\u884c`peek-ready`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-peek-delayed` \u603b\u5171\u6267\u884c`peek-delayed`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-peek-buried` \u603b\u5171\u6267\u884c`peek-buried`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-reserve` \u603b\u5171\u6267\u884c`reserve`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-use` \u603b\u5171\u6267\u884c`use`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-watch` \u603b\u5171\u6267\u884c`watch`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-ignore` \u603b\u5171\u6267\u884c`ignore`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-release` \u603b\u5171\u6267\u884c`release`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-bury` \u603b\u5171\u6267\u884c`bury`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-kick` \u603b\u5171\u6267\u884c`kick`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-stats` \u603b\u5171\u6267\u884c`stats`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-stats-job` \u603b\u5171\u6267\u884c`stats-job`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-stats-tube` \u603b\u5171\u6267\u884c`stats-tube`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-list-tubes` \u603b\u5171\u6267\u884c`list-tubes`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-list-tube-used` \u603b\u5171\u6267\u884c`list-tube-used`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-list-tubes-watched` \u603b\u5171\u6267\u884c`list-tubes-watched`\u6307\u4ee4\u7684\u6b21\u6570\n+* `cmd-pause-tube` \u603b\u5171\u6267\u884c`pause-tube`\u6307\u4ee4\u7684\u6b21\u6570\n+* `job-timeouts` \u6240\u6709\u8d85\u65f6\u7684 job \u7684\u603b\u5171\u6570\u91cf\n+* `total-jobs` \u521b\u5efa\u7684\u6240\u6709 job \u6570\u91cf\n+* `max-job-size` job \u7684\u6570\u636e\u90e8\u5206\u6700\u5927\u957f\u5ea6\n+* `current-tubes` \u5f53\u524d\u5b58\u5728\u7684 tube \u6570\u91cf\n+* `current-connections` \u5f53\u524d\u6253\u5f00\u7684\u8fde\u63a5\u6570\n+* `current-producers` \u5f53\u524d\u6240\u6709\u7684\u6253\u5f00\u7684\u8fde\u63a5\u4e2d\u81f3\u5c11\u6267\u884c\u4e00\u6b21 put \u6307\u4ee4\u7684\u8fde\u63a5\u6570\u91cf\n+* `current-workers` \u5f53\u524d\u6240\u6709\u7684\u6253\u5f00\u7684\u8fde\u63a5\u4e2d\u81f3\u5c11\u6267\u884c\u4e00\u6b21 reserve \u6307\u4ee4\u7684\u8fde\u63a5\u6570\u91cf\n+* `current-waiting` \u5f53\u524d\u6240\u6709\u7684\u6253\u5f00\u7684\u8fde\u63a5\u4e2d\u6267\u884c reserve \u6307\u4ee4\u4f46\u662f\u672a\u54cd\u5e94\u7684\u8fde\u63a5\u6570\u91cf\n+* `total-connections` \u603b\u5171\u5904\u7406\u7684\u8fde\u63a5\u6570\n+* `pid` \u670d\u52a1\u5668\u8fdb\u7a0b\u7684 id\n+* `version` \u670d\u52a1\u5668\u7248\u672c\u53f7\n+* `rusage-utime` \u8fdb\u7a0b\u603b\u5171\u5360\u7528\u7684\u7528\u6237 CPU \u65f6\u95f4\n+* `rusage-stime` \u8fdb\u7a0b\u603b\u5171\u5360\u7528\u7684\u7cfb\u7edf CPU \u65f6\u95f4\n+* `uptime` \u670d\u52a1\u5668\u8fdb\u7a0b\u8fd0\u884c\u7684\u79d2\u6570\n+* `binlog-oldest-index` \u5f00\u59cb\u50a8\u5b58 jobs \u7684 binlog \u7d22\u5f15\u53f7\n+* `binlog-current-index` \u5f53\u524d\u50a8\u5b58 jobs \u7684 binlog \u7d22\u5f15\u53f7\n+* `binlog-max-size` binlog \u7684\u6700\u5927\u5bb9\u91cf\n+* `binlog-records-written` binlog \u7d2f\u79ef\u5199\u5165\u7684\u8bb0\u5f55\u6570\n+* `binlog-records-migrated` is the cumulative number of records written as part of compaction.\n+* `id` \u4e00\u4e2a\u968f\u673a\u5b57\u7b26\u4e32\uff0c\u5728 beanstalkd \u8fdb\u7a0b\u542f\u52a8\u65f6\u4ea7\u751f\n+* `hostname` \u4e3b\u673a\u540d\n \n #### `list-tubes`\n-\u8bf4\u660e\n-\u5217\u8868\u6240\u6709\u5b58\u5728\u7684tube\n-\u683c\u5f0f\n-```\n+\n+\u5217\u51fa\u5f53\u524d beanstalkd \u6240\u6709\u5b58\u5728\u7684 tubes\n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n list-tubes\\r\\n\n ```\n \n-\u54cd\u5e94\n-```\n-OK <bytes>\\r\\n\n+**\u54cd\u5e94**\n \n+```text\n+OK <bytes>\\r\\n\n <data>\\r\\n\n ```\n-bytes \u4e3a\u63a5\u4e0b\u6765\u7684data\u533a\u5757\u7684\u957f\u5ea6\n-data \u4e3aYAML file\uff0c\u5305\u542b\u6240\u6709\u7684tube\u540d\u79f0\n+\n+* `<bytes>` \u4e3a\u63a5\u4e0b\u6765\u7684 data \u533a\u5757\u7684\u957f\u5ea6\n+* `<data>` \u4e3a YAML file\uff0c\u5305\u542b\u6240\u6709\u7684 tube \u540d\u79f0\n \n #### `list-tube-used`\n-\u8bf4\u660e\n-\u5217\u8868\u5f53\u524dclient\u6b63\u5728use\u7684tube\n-\u683c\u5f0f\n-```\n+\n+\u5217\u51fa\u5f53\u524d client \u6b63\u5728 use \u7684 tube\n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n list-tube-used\\r\\n\n ```\n-\u54cd\u5e94\n-```\n+\n+**\u54cd\u5e94**\n+\n+```text\n USING <tube>\\r\\n\n ```\n-tube \u4e3atube\u540d\u79f0\n+\n+* `<tube>` \u4e3a tube \u540d\u79f0\n \n #### `list-tubes-watched`\n-\u8bf4\u660e\n-\u5217\u8868\u5f53\u524dclient watch\u7684tube\n-\u683c\u5f0f\n-```\n+\n+\u5217\u51fa\u5f53\u524d client \u6240 watch \u7684 tubes\n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n list-tubes-watched\\r\\n\n ```\n-\u54cd\u5e94\n-```\n-OK <bytes>\\r\\n\n \n+**\u54cd\u5e94**\n+\n+```text\n+OK <bytes>\\r\\n\n <data>\\r\\n\n ```\n-bytes \u4e3a\u63a5\u4e0b\u6765\u7684data\u533a\u5757\u7684\u957f\u5ea6\n-data \u4e3aYAML file\uff0c\u5305\u542b\u6240\u6709\u7684tube\u540d\u79f0\n+\n+* `<bytes>` \u4e3a\u63a5\u4e0b\u6765\u7684 data \u533a\u5757\u7684\u957f\u5ea6\n+* `<data>` \u4e3a YAML file\uff0c\u5305\u542b\u6240\u6709\u7684 tube \u540d\u79f0\n \n #### `quit`\n-\u8bf4\u660e\n-\u5173\u95ed\u8fde\u63a5\n-\u683c\u5f0f\n-```\n+\n+client \u5411 beanstalkd \u53d1\u9001 `quit` \u62a5\u6587\uff0c\u5e76\u5173\u95ed\u8fde\u63a5\uff0cbeanstalkd \u6536\u5230\u8be5\u62a5\u6587\u540e\u4e3b\u52a8\u5173\u95ed\u8fde\u63a5\n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n quit\\r\\n\n ```\n \n+\u65e0\u54cd\u5e94\n+\n #### `pause-tube`\n-##### \u8bf4\u660e\n-\u6b64\u6307\u4ee4\u9488\u5bf9\u7279\u5b9a\u7684tube\u5185\u6240\u6709\u65b0\u7684job\u5ef6\u8fdf\u7ed9\u5b9a\u7684\u79d2\u6570\n-##### \u683c\u5f0f\n-```\n+\n+\u6b64\u6307\u4ee4\u9488\u5bf9\u7279\u5b9a\u7684 tube \u5185\u6240\u6709\u65b0\u7684 job \u5ef6\u8fdf\u6307\u5b9a\u7684\u79d2\u6570\n+\n+**\u6307\u4ee4\u683c\u5f0f**\n+\n+```text\n pause-tube <tube-name> <delay>\\r\\n\n ```\n-##### \u54cd\u5e94\n-```\n+\n+* `<delay>` \u5ef6\u8fdf\u7684\u65f6\u95f4\n+\n+**\u54cd\u5e94**\n+\n+```text\n PAUSED\\r\\n \u8868\u793a\u6210\u529f\n-NOT_FOUND\\r\\n tube\u4e0d\u5b58\u5728\n+NOT_FOUND\\r\\n tube \u4e0d\u5b58\u5728\n ```\n \n \n->Translated by PHPBoy :http://www.phpboy.net/ and fzb.me\n+> Translated by PHPBoy :http://www.phpboy.net/ and fzb.me\n+Revised by Pseudocodes: https://github.com/pseudocodes\n", "test_patch": "", "problem_statement": "Chinese doc revised for human reading\n1. Chinese doc revised for human reading\r\n2. improving markdown doc format\r\n3. add some  detailed explanation\r\n4. fix some typo", "version": "1.11", "language": "C", "created_at": "2019-08-02T05:38:25Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-478", "repo": "beanstalkd/beanstalkd", "pull_number": 478, "base_commit": "a0b2ada50dd2de47eec83fd7cd2af09cc9d00595", "patch": "diff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -52,7 +52,8 @@ make_conn(int fd, char start_state, tube use, tube watch)\n     c->sock.fd = fd;\n     c->state = start_state;\n     c->pending_timeout = -1;\n-    c->tickpos = -1;\n+    c->tickpos = 0; // Does not mean anything if in_conns is set to 0.\n+    c->in_conns = 0;\n     j = &c->reserved_jobs;\n     j->prev = j->next = j;\n \n@@ -110,6 +111,7 @@ has_reserved_job(Conn *c)\n }\n \n \n+// Returns positive nanoseconds when c should tick, 0 otherwise.\n static int64\n conntickat(Conn *c)\n {\n@@ -136,6 +138,8 @@ conntickat(Conn *c)\n }\n \n \n+// TODO: remove this function by inlining its content into 3 callees places.\n+// Reason: conn.c does not use rw anywhere in this file.\n void\n connwant(Conn *c, int rw)\n {\n@@ -144,21 +148,25 @@ connwant(Conn *c, int rw)\n }\n \n \n+// Remove c from the c->srv heap and reschedule it using the value\n+// returned by conntickat if there is an outstanding timeout in the c.\n void\n connsched(Conn *c)\n {\n-    if (c->tickpos > -1) {\n+    if (c->in_conns) {\n         heapremove(&c->srv->conns, c->tickpos);\n+        c->in_conns = 0;\n     }\n     c->tickat = conntickat(c);\n     if (c->tickat) {\n         heapinsert(&c->srv->conns, c);\n+        c->in_conns = 1;\n     }\n }\n \n \n-/* return the reserved job with the earliest deadline,\n- * or NULL if there's no reserved job */\n+// Return the reserved job with the earliest deadline,\n+// or NULL if there's no reserved job\n job\n connsoonestjob(Conn *c)\n {\n@@ -167,16 +175,17 @@ connsoonestjob(Conn *c)\n \n     if (soonest == NULL) {\n         for (j = c->reserved_jobs.next; j != &c->reserved_jobs; j = j->next) {\n-            if (j->r.deadline_at <= (soonest ? : j)->r.deadline_at) soonest = j;\n+            if (j->r.deadline_at <= (soonest ? : j)->r.deadline_at)\n+                soonest = j;\n         }\n     }\n     c->soonest_job = soonest;\n     return soonest;\n }\n \n \n-/* return true if c has a reserved job with less than one second until its\n- * deadline */\n+// Return true if c has a reserved job with less than one second until its\n+// deadline.\n int\n conndeadlinesoon(Conn *c)\n {\n@@ -192,7 +201,8 @@ conn_ready(Conn *c)\n     size_t i;\n \n     for (i = 0; i < c->watch.used; i++) {\n-        if (((tube) c->watch.items[i])->ready.len) return 1;\n+        if (((tube) c->watch.items[i])->ready.len)\n+            return 1;\n     }\n     return 0;\n }\n@@ -206,7 +216,7 @@ connless(Conn *a, Conn *b)\n \n \n void\n-connrec(Conn *c, int i)\n+connrec(Conn *c, size_t i)\n {\n     c->tickpos = i;\n }\n@@ -241,8 +251,9 @@ connclose(Conn *c)\n     c->use->using_ct--;\n     TUBE_ASSIGN(c->use, NULL);\n \n-    if (c->tickpos > -1) {\n+    if (c->in_conns) {\n         heapremove(&c->srv->conns, c->tickpos);\n+        c->in_conns = 0;\n     }\n \n     free(c);\n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -275,9 +275,10 @@ struct Conn {\n     char   state;\n     char   type;\n     Conn   *next;\n-    tube   use;\n-    int64  tickat;      // time at which to do more work\n-    int    tickpos;     // position in srv->conns\n+    tube   use;         // tube currently in use\n+    int64  tickat;      // time at which to do more work; determines pos in heap\n+    size_t tickpos;     // position in srv->conns, stale when in_conns=0\n+    byte   in_conns;    // 1 if the conn is in srv->conns heap, 0 otherwise\n     job    soonest_job; // memoization of the soonest job\n     int    rw;          // currently want: 'r', 'w', or 'h'\n     int    pending_timeout;\n@@ -306,7 +307,7 @@ struct Conn {\n     struct job reserved_jobs; // linked list header\n };\n int  connless(Conn *a, Conn *b);\n-void connrec(Conn *c, int i);\n+void connrec(Conn *c, size_t i);\n void connwant(Conn *c, int rw);\n void connsched(Conn *c);\n void connclose(Conn *c);\n@@ -387,6 +388,8 @@ struct Server {\n \n     Wal    wal;\n     Socket sock;\n+\n+    // Connections that must produce deadline or timeout, ordered by the time.\n     Heap   conns;\n };\n void srvserve(Server *srv);\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -1864,6 +1864,7 @@ prothandle(Conn *c, int ev)\n     h_conn(c->sock.fd, ev, c);\n }\n \n+// prottick returns nanoseconds till the next work.\n int64\n prottick(Server *s)\n {\n@@ -1899,6 +1900,8 @@ prottick(Server *s)\n         }\n     }\n \n+    // Process connections with pending timeouts. Release jobs with expired ttr.\n+    // Capture the period from the soonest connection.\n     while (s->conns.len) {\n         Conn *c = s->conns.data[0];\n         d = c->tickat - now;\n@@ -1908,6 +1911,7 @@ prottick(Server *s)\n         }\n \n         heapremove(&s->conns, 0);\n+        c->in_conns = 0;\n         conn_timeout(c);\n     }\n \n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -30,27 +30,33 @@ typedef int(*Less)(void*, void*);\n typedef void(*Record)(void*, size_t);\n typedef int(FAlloc)(int, int);\n \n+\n+// NUM_PRIMES is used in the jobs hashing.\n #if _LP64\n #define NUM_PRIMES 48\n #else\n #define NUM_PRIMES 19\n #endif\n \n+// The name of a tube cannot be longer than MAX_TUBE_NAME_LEN-1\n #define MAX_TUBE_NAME_LEN 201\n \n-/* A command can be at most LINE_BUF_SIZE chars, including \"\\r\\n\". This value\n- * MUST be enough to hold the longest possible command (\"pause-tube a{200} 4294967295\\r\\n\")\n- * or reply line (\"USING a{200}\\r\\n\"). */\n+// A command can be at most LINE_BUF_SIZE chars, including \"\\r\\n\". This value\n+// MUST be enough to hold the longest possible command (\"pause-tube a{200} 4294967295\\r\\n\")\n+// or reply line (\"USING a{200}\\r\\n\").\n #define LINE_BUF_SIZE 224\n \n-/* CONN_TYPE_* are bit masks */\n+// CONN_TYPE_* are bit masks used to track the count of connection types.\n #define CONN_TYPE_PRODUCER 1\n #define CONN_TYPE_WORKER   2\n #define CONN_TYPE_WAITING  4\n \n #define min(a,b) ((a)<(b)?(a):(b))\n \n+// Jobs with priority less than URGENT_THRESHOLD are counted as urgent.\n #define URGENT_THRESHOLD 1024\n+\n+// The default maximum job size.\n #define JOB_DATA_SIZE_LIMIT_DEFAULT ((1 << 16) - 1)\n \n // The maximum value that job_data_size_limit can be set to via \"-z\".\n@@ -61,15 +67,21 @@ typedef int(FAlloc)(int, int);\n // Maximum value (uint32) allowed in pri, delay and ttr parameters\n #define MAX_UINT32 4294967295\n \n+// Use this macro to designate unused parameters in functions.\n #define UNUSED_PARAMETER(x) (void)(x)\n \n+// version is defined in vers.c, see vers.sh for details.\n extern const char version[];\n+\n+// verbose holds the count of -V parameters; it's a verbosity level.\n extern int verbose;\n+\n extern struct Server srv;\n \n // Replaced by tests to simulate failures.\n extern FAlloc *falloc;\n \n+// stats structure holds counters for operations, both globally and per tube.\n struct stats {\n     uint urgent_ct;\n     uint waiting_ct;\n@@ -144,22 +156,23 @@ struct Jobrec {\n };\n \n struct job {\n-    Jobrec r; // persistent fields; these get written to the wal\n+     // persistent fields; these get written to the wal\n+    Jobrec r;\n \n-    /* bookeeping fields; these are in-memory only */\n+    // bookeeping fields; these are in-memory only\n     char pad[6];\n     tube tube;\n-    job prev, next; /* linked list of jobs */\n-    job ht_next; /* Next job in a hash table list */\n-    size_t heap_index; /* where is this job in its current heap */\n+    job prev, next;             // linked list of jobs\n+    job ht_next;                // Next job in a hash table list\n+    size_t heap_index;          // where is this job in its current heap\n     File *file;\n     job  fnext;\n     job  fprev;\n     void *reserver;\n     int walresv;\n     int walused;\n \n-    char body[]; // written separately to the wal\n+    char body[];                // written separately to the wal\n };\n \n struct tube {\n@@ -284,7 +297,7 @@ struct Conn {\n     int    pending_timeout;\n     char   halfclosed;\n \n-    char   cmd[LINE_BUF_SIZE]; // this string is NOT NUL-terminated\n+    char   cmd[LINE_BUF_SIZE];  // this string is NOT NUL-terminated\n     size_t cmd_len;\n     int    cmd_read;\n \n@@ -298,7 +311,7 @@ struct Conn {\n     // in_job_read's meaning is inverted -- then it counts the bytes that\n     // remain to be thrown away.\n     int32 in_job_read;\n-    job   in_job; // a job to be read from the client\n+    job   in_job;               // a job to be read from the client\n \n     job out_job;\n     int out_job_sent;\n", "test_patch": "", "problem_statement": "fix how connections are handled in the srv->conns heap\nPreviously in #453 I have changed the type of position in the heap to size_t.\r\nI have removed the call x->rec(x, -1) for the item being removed from the heap.\r\n\r\nThat patch has broken the meaning of conn->tickpos var, that used to\r\ncontain -1 when conn was not in the srv->conns heap. -1 was assigned\r\nonly when conn was created. Later when it was just removed from conns,\r\nit was not ever assigned -1 again.\r\n\r\nThis change fixes how connections are handled in the srv->conns heap.\r\nNew var Conn->in_conns is used to track if conn exists in the heap.\r\nConn->tickpos is size_it and the connrec function has a prototype\r\nmatching the heap's Record prototype.\r\n\r\nFixes #472", "version": "1.11", "language": "C", "created_at": "2019-07-18T13:47:54Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-480", "repo": "beanstalkd/beanstalkd", "pull_number": 480, "base_commit": "41538a317b4b726f62cfd8a6e806b7e7f29525f0", "patch": "diff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -209,16 +209,18 @@ conn_ready(Conn *c)\n \n \n int\n-connless(Conn *a, Conn *b)\n+conn_less(void *ca, void *cb)\n {\n+    Conn *a = (Conn *)ca;\n+    Conn *b = (Conn *)cb;\n     return a->tickat < b->tickat;\n }\n \n \n void\n-connrec(Conn *c, size_t i)\n+conn_setpos(void *c, size_t i)\n {\n-    c->tickpos = i;\n+    ((Conn *)c)->tickpos = i;\n }\n \n \n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -26,8 +26,6 @@ typedef struct Wal    Wal;\n \n typedef void(*ms_event_fn)(ms a, void *item, size_t i);\n typedef void(*Handle)(void*, int rw);\n-typedef int(*Less)(void*, void*);\n-typedef void(*Record)(void*, size_t);\n typedef int(FAlloc)(int, int);\n \n \n@@ -93,12 +91,20 @@ struct stats {\n };\n \n \n+// less_fn is used by the binary heap to determine the order of elements.\n+typedef int(*less_fn)(void*, void*);\n+\n+// setpos_fn is used by the binary heap to record the new positions of elements\n+// whenever they get moved or inserted.\n+typedef void(*setpos_fn)(void*, size_t);\n+\n struct Heap {\n-    size_t  cap;\n-    size_t  len;\n-    void    **data;\n-    Less    less;\n-    Record  rec;\n+    size_t  cap;                // capacity of the heap\n+    size_t  len;                // amount of elements in the heap\n+    void    **data;             // actual elements\n+\n+    less_fn   less;\n+    setpos_fn setpos;\n };\n int   heapinsert(Heap *h, void *x);\n void* heapremove(Heap *h, size_t k);\n@@ -227,9 +233,9 @@ void job_free(job j);\n job job_find(uint64 job_id);\n \n /* the void* parameters are really job pointers */\n-void job_setheappos(void*, size_t);\n-int job_pri_less(void*, void*);\n-int job_delay_less(void*, void*);\n+void job_setpos(void *j, size_t i);\n+int job_pri_less(void *ja, void *jb);\n+int job_delay_less(void *ja, void *jb);\n \n job job_copy(job j);\n \n@@ -319,8 +325,8 @@ struct Conn {\n     struct ms  watch;\n     struct job reserved_jobs; // linked list header\n };\n-int  connless(Conn *a, Conn *b);\n-void connrec(Conn *c, size_t i);\n+int  conn_less(void *ax, void *bx);\n+void conn_setpos(void *cx, size_t i);\n void connwant(Conn *c, int rw);\n void connsched(Conn *c);\n void connclose(Conn *c);\n\ndiff --git a/heap.c b/heap.c\n--- a/heap.c\n+++ b/heap.c\n@@ -8,7 +8,7 @@ static void\n set(Heap *h, size_t k, void *x)\n {\n     h->data[k] = x;\n-    h->rec(x, k);\n+    h->setpos(x, k);\n }\n \n \n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -158,24 +158,26 @@ job_free(job j)\n }\n \n void\n-job_setheappos(void *j, size_t pos)\n+job_setpos(void *j, size_t pos)\n {\n     ((job)j)->heap_index = pos;\n }\n \n int\n-job_pri_less(void *ax, void *bx)\n+job_pri_less(void *ja, void *jb)\n {\n-    job a = ax, b = bx;\n+    job a = (job)ja;\n+    job b = (job)jb;\n     if (a->r.pri < b->r.pri) return 1;\n     if (a->r.pri > b->r.pri) return 0;\n     return a->r.id < b->r.id;\n }\n \n int\n-job_delay_less(void *ax, void *bx)\n+job_delay_less(void *ja, void *jb)\n {\n-    job a = ax, b = bx;\n+    job a = ja;\n+    job b = jb;\n     if (a->r.deadline_at < b->r.deadline_at) return 1;\n     if (a->r.deadline_at > b->r.deadline_at) return 0;\n     return a->r.id < b->r.id;\n\ndiff --git a/serv.c b/serv.c\n--- a/serv.c\n+++ b/serv.c\n@@ -25,8 +25,8 @@ srvserve(Server *s)\n \n     s->sock.x = s;\n     s->sock.f = (Handle)srvaccept;\n-    s->conns.less = (Less)connless;\n-    s->conns.rec = (Record)connrec;\n+    s->conns.less = conn_less;\n+    s->conns.setpos = conn_setpos;\n \n     r = listen(s->sock.fd, 1024);\n     if (r == -1) {\n\ndiff --git a/testheap.c b/testheap.c\n--- a/testheap.c\n+++ b/testheap.c\n@@ -12,7 +12,7 @@ cttest_heap_insert_one()\n {\n     Heap h = {\n         .less = job_pri_less,\n-        .rec = job_setheappos,\n+        .setpos = job_setpos,\n     };\n \n     job j = make_job(1, 0, 1, 0, 0);\n@@ -28,7 +28,7 @@ cttest_heap_insert_and_remove_one()\n {\n     Heap h = {\n         .less = job_pri_less,\n-        .rec = job_setheappos,\n+        .setpos = job_setpos,\n     };\n \n     job j1 = make_job(1, 0, 1, 0, 0);\n@@ -47,7 +47,7 @@ cttest_heap_priority()\n {\n     Heap h = {\n         .less = job_pri_less,\n-        .rec = job_setheappos,\n+        .setpos = job_setpos,\n     };\n     job j, j1, j2, j3;\n \n@@ -91,7 +91,7 @@ cttest_heap_fifo_property()\n {\n     Heap h = {\n         .less = job_pri_less,\n-        .rec = job_setheappos,\n+        .setpos = job_setpos,\n     };\n     job j, j3a, j3b, j3c;\n \n@@ -138,7 +138,7 @@ cttest_heap_many_jobs()\n {\n     Heap h = {\n         .less = job_pri_less,\n-        .rec = job_setheappos,\n+        .setpos = job_setpos,\n     };\n     const int n = 20;\n     job j;\n@@ -164,7 +164,7 @@ cttest_heap_remove_k()\n {\n     Heap h = {\n         .less = job_pri_less,\n-        .rec = job_setheappos,\n+        .setpos = job_setpos,\n     };\n     const int n = 20;\n \n@@ -203,7 +203,7 @@ ctbench_heap_insert(int n)\n     }\n     Heap h = {\n         .less = job_pri_less,\n-        .rec = job_setheappos,\n+        .setpos = job_setpos,\n     };\n     ctresettimer();\n     for (i = 0; i < n; i++) {\n@@ -216,7 +216,7 @@ ctbench_heap_remove(int n)\n {\n     Heap h = {\n         .less = job_pri_less,\n-        .rec = job_setheappos,\n+        .setpos = job_setpos,\n     };\n \n     int i;\n\ndiff --git a/tube.c b/tube.c\n--- a/tube.c\n+++ b/tube.c\n@@ -19,8 +19,8 @@ make_tube(const char *name)\n \n     t->ready.less = job_pri_less;\n     t->delay.less = job_delay_less;\n-    t->ready.rec = job_setheappos;\n-    t->delay.rec = job_setheappos;\n+    t->ready.setpos = job_setpos;\n+    t->delay.setpos = job_setpos;\n \n     struct job j = {.tube = NULL};\n     t->buried = j;\n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -36,6 +36,16 @@ typedef int(FAlloc)(int, int);\n #define NUM_PRIMES 19\n #endif\n \n+/* Some compilers (e.g. gcc on SmartOS) define NULL as 0.\n+ * This is allowed by the C standard, but is unhelpful when\n+ * using NULL in most pointer contexts with errors turned on. */\n+#if (defined(sun) || defined(__sun)) && (defined(__SVR4) || defined(__svr4__))\n+#ifdef NULL\n+#undef NULL\n+#endif\n+#define NULL ((void*)0)\n+#endif\n+\n // The name of a tube cannot be longer than MAX_TUBE_NAME_LEN-1\n #define MAX_TUBE_NAME_LEN 201\n \n", "test_patch": "", "problem_statement": "fix prototypes of the Less and Record typedefs\nThis change improves readability of the code.\r\nIt brings consistency into functions of the binary heap.\r\nTypedef Less was renamed to less_fn, Record to setpos_fn.\r\nconnless and connrec were changed to match to the corresponding typdefs.\r\n\r\nThe rec member of heap was renamed to \"setpos\".\r\n\r\nThe job was updated in the same way.\r\n\r\nFixes #472", "version": "1.11", "language": "C", "created_at": "2019-07-19T13:25:22Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-202", "repo": "beanstalkd/beanstalkd", "pull_number": 202, "base_commit": "7e48959af993090e3134a5a0b6d34d96b5f6a3ca", "patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -9,6 +9,10 @@ LDLIBS?=\n OS?=$(shell uname | tr 'A-Z' 'a-z')\n INSTALL?=install\n \n+ifeq ($(OS),sunos)\n+LDFLAGS += -lxnet -lsocket -lnsl\n+endif\n+\n VERS=$(shell ./vers.sh)\n TARG=beanstalkd\n MOFILE=main.o\n\ndiff --git a/sunos.c b/sunos.c\n--- a/sunos.c\n+++ b/sunos.c\n@@ -0,0 +1,111 @@\n+#include <stdint.h>\n+#include <fcntl.h>\n+#include <stdlib.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include <poll.h>\n+#include <port.h>\n+#include \"dat.h\"\n+\n+static int portfd;\n+static char buf0[512]; /* buffer of zeros */\n+\n+/* Allocate disk space.\n+ * Expects fd's offset to be 0; may also reset fd's offset to 0.\n+ * Returns 0 on success, and a positive errno otherwise. */\n+int\n+rawfalloc(int fd, int len)\n+{\n+    int i, w;\n+\n+    for (i = 0; i < len; i += w) {\n+        w = write(fd, buf0, sizeof buf0);\n+        if (w == -1) return errno;\n+    }\n+\n+    lseek(fd, 0, 0); /* do not care if this fails */\n+\n+    return 0;\n+}\n+\n+\n+int\n+sockinit(void)\n+{\n+    portfd = port_create();\n+    if (portfd == -1) {\n+        twarn(\"port_create\");\n+        return -1;\n+    }\n+    return 0;\n+}\n+\n+\n+int\n+sockwant(Socket *s, int rw)\n+{\n+    int events = 0;\n+\n+    if (rw) {\n+        switch (rw) {\n+        case 'r':\n+            events |= POLLIN;\n+            break;\n+        case 'w':\n+            events |= POLLOUT;\n+            break;\n+        }\n+    }\n+\n+    events |= POLLPRI;\n+\n+    if (!s->added && !rw) {\n+        return 0;\n+    } else if (!s->added && rw) {\n+        s->added = 1;\n+        return port_associate(portfd, PORT_SOURCE_FD, s->fd, events, (void *)s);\n+    } else if (!rw) {\n+        return port_dissociate(portfd, PORT_SOURCE_FD, s->fd);\n+    } else {\n+        port_dissociate(portfd, PORT_SOURCE_FD, s->fd);\n+        return port_associate(portfd, PORT_SOURCE_FD, s->fd, events, (void *)s);\n+    }\n+}\n+\n+\n+int\n+socknext(Socket **s, int64 timeout)\n+{\n+    int r;\n+    uint_t n = 1;\n+    struct port_event pe;\n+    struct timespec ts;\n+\n+    ts.tv_sec = timeout / 1000000000;\n+    ts.tv_nsec = timeout % 1000000000;\n+    r = port_getn(portfd, &pe, 1, &n, &ts);\n+    if (r == -1 && errno != ETIME && errno != EINTR) {\n+        twarn(\"port_getn\");\n+        return -1;\n+    }\n+\n+    if (r == 0) {\n+        *s = pe.portev_user;\n+        if (pe.portev_events & POLLHUP) {\n+            return 'h';\n+        } else if (pe.portev_events & POLLIN) {\n+            if (sockwant(*s, 'r') == -1) {\n+                return -1;\n+            }\n+            return 'r';\n+        } else if (pe.portev_events & POLLOUT) {\n+            if (sockwant(*s, 'w') == -1) {\n+                return -1;\n+            }\n+            return 'w';\n+        }\n+    }\n+\n+    return 0;\n+}\n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -38,6 +38,16 @@ typedef int(FAlloc)(int, int);\n #define NUM_PRIMES 19\n #endif\n \n+/* Some compilers (e.g. gcc on SmartOS) define NULL as 0.\n+ * This is allowed by the C standard, but is unhelpful when\n+ * using NULL in most pointer contexts with errors turned on. */\n+#if (defined(sun) || defined(__sun)) && (defined(__SVR4) || defined(__svr4__))\n+#ifdef NULL\n+#undef NULL\n+#endif\n+#define NULL ((void*)0)\n+#endif\n+\n // The name of a tube cannot be longer than MAX_TUBE_NAME_LEN-1\n #define MAX_TUBE_NAME_LEN 201\n \n\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -10,7 +10,7 @@ OS?=$(shell uname | tr 'A-Z' 'a-z')\n INSTALL?=install\n \n ifeq ($(OS),sunos)\n-LDFLAGS += -lxnet -lsocket -lnsl\n+override LDFLAGS += -lxnet -lsocket -lnsl\n endif\n \n VERS=$(shell ./vers.sh)\n", "test_patch": "", "problem_statement": "add sunos.c for solaris/illumos support\nI added preliminary solaris/illumos support with event ports in `sunos.c` as mentioned in #112.  The other changes outside `sunos.c` were related to portability issues between BSD/Linux and SunOS.\n\nThis branch was tested with `make bench` on the following platforms:\n- SmartOS joyent_20130629T040542Z with GCC 4.7.2\n- CentOS+OpenVZ 2.6.32-042stab076.7 with GCC 4.7.1\n- OS X 10.8.4 with clang 4.2\n\nHere's the related documentation for event ports:\n- [port_create(3c)](http://illumos.org/man/3c/port_create)\n- [port_associate(3c)](http://illumos.org/man/3c/port_associate)\n- [port_getn(3c)](http://illumos.org/man/3c/port_getn)\n- [poll(2)](http://illumos.org/man/2/poll)", "version": "1.11", "language": "C", "created_at": "2013-08-12T23:34:32Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-499", "repo": "beanstalkd/beanstalkd", "pull_number": 499, "base_commit": "462a9d9f0b3f9d11aa6991c2d66634abf52e2b04", "patch": "diff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -34,7 +34,7 @@ on_ignore(Ms *a, tube t, size_t i)\n Conn *\n make_conn(int fd, char start_state, tube use, tube watch)\n {\n-    job j;\n+    Job *j;\n     Conn *c;\n \n     c = new(Conn);\n@@ -167,11 +167,11 @@ connsched(Conn *c)\n \n // Return the reserved job with the earliest deadline,\n // or NULL if there's no reserved job\n-job\n+Job *\n connsoonestjob(Conn *c)\n {\n-    job j = NULL;\n-    job soonest = c->soonest_job;\n+    Job *j = NULL;\n+    Job *soonest = c->soonest_job;\n \n     if (soonest == NULL) {\n         for (j = c->reserved_jobs.next; j != &c->reserved_jobs; j = j->next) {\n@@ -190,7 +190,7 @@ int\n conndeadlinesoon(Conn *c)\n {\n     int64 t = nanoseconds();\n-    job j = connsoonestjob(c);\n+    Job *j = connsoonestjob(c);\n \n     return j && t >= j->r.deadline_at - SAFETY_MARGIN;\n }\n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -9,11 +9,8 @@ typedef uint32_t      uint32;\n typedef int64_t       int64;\n typedef uint64_t      uint64;\n \n-/* TODO: typedefs of job and tube should not hide the pointer.\n-   Make them similar to other typedefs (Conn, Heap).\n-   See issue #458. */\n typedef struct Ms     Ms;\n-typedef struct job    *job;\n+typedef struct Job    Job;\n typedef struct tube   *tube;\n typedef struct Conn   Conn;\n typedef struct Heap   Heap;\n@@ -199,19 +196,19 @@ struct Jobrec {\n     byte   state;\n };\n \n-struct job {\n+struct Job {\n      // persistent fields; these get written to the wal\n     Jobrec r;\n \n     // bookeeping fields; these are in-memory only\n     char pad[6];\n     tube tube;\n-    job prev, next;             // linked list of jobs\n-    job ht_next;                // Next job in a hash table list\n+    Job *prev, *next;           // linked list of jobs\n+    Job *ht_next;               // Next job in a hash table list\n     size_t heap_index;          // where is this job in its current heap\n     File *file;\n-    job  fnext;\n-    job  fprev;\n+    Job  *fnext;\n+    Job  *fprev;\n     void *reserver;\n     int walresv;\n     int walused;\n@@ -224,13 +221,13 @@ struct tube {\n     char name[MAX_TUBE_NAME_LEN];\n     Heap ready;\n     Heap delay;\n-    struct Ms waiting; /* set of conns */\n+    Ms waiting; /* set of conns */\n     struct stats stat;\n     uint using_ct;\n     uint watching_ct;\n     int64 pause;\n     int64 deadline_at;\n-    struct job buried;\n+    Job buried;\n };\n \n \n@@ -253,26 +250,26 @@ int   rawfalloc(int fd, int len);\n \n #define make_job(pri,delay,ttr,body_size,tube) make_job_with_id(pri,delay,ttr,body_size,tube,0)\n \n-job allocate_job(int body_size);\n-job make_job_with_id(uint pri, int64 delay, int64 ttr,\n+Job *allocate_job(int body_size);\n+Job *make_job_with_id(uint pri, int64 delay, int64 ttr,\n              int body_size, tube tube, uint64 id);\n-void job_free(job j);\n+void job_free(Job *j);\n \n /* Lookup a job by job ID */\n-job job_find(uint64 job_id);\n+Job *job_find(uint64 job_id);\n \n /* the void* parameters are really job pointers */\n void job_setpos(void *j, size_t i);\n int job_pri_less(void *ja, void *jb);\n int job_delay_less(void *ja, void *jb);\n \n-job job_copy(job j);\n+Job *job_copy(Job *j);\n \n-const char * job_state(job j);\n+const char * job_state(Job *j);\n \n-int job_list_any_p(job head);\n-job job_remove(job j);\n-void job_insert(job head, job j);\n+int job_list_any_p(Job *head);\n+Job *job_remove(Job *j);\n+void job_insert(Job *head, Job *j);\n \n /* for unit tests */\n size_t get_all_jobs_used(void);\n@@ -311,7 +308,7 @@ void enqueue_reserved_jobs(Conn *c);\n void enter_drain_mode(int sig);\n void h_accept(const int fd, const short which, Server* srv);\n void prot_remove_tube(tube t);\n-int  prot_replay(Server *s, job list);\n+int  prot_replay(Server *s, Job *list);\n \n \n int make_server_socket(char *host_addr, char *port);\n@@ -327,12 +324,12 @@ struct Conn {\n     int64  tickat;      // time at which to do more work; determines pos in heap\n     size_t tickpos;     // position in srv->conns, stale when in_conns=0\n     byte   in_conns;    // 1 if the conn is in srv->conns heap, 0 otherwise\n-    job    soonest_job; // memoization of the soonest job\n+    Job    *soonest_job;// memoization of the soonest job\n     int    rw;          // currently want: 'r', 'w', or 'h'\n     int    pending_timeout;\n     char   halfclosed;\n \n-    char   cmd[LINE_BUF_SIZE];  // this string is NOT NUL-terminated\n+    char   cmd[LINE_BUF_SIZE];     // this string is NOT NUL-terminated\n     size_t cmd_len;\n     int    cmd_read;\n \n@@ -346,13 +343,13 @@ struct Conn {\n     // in_job_read's meaning is inverted -- then it counts the bytes that\n     // remain to be thrown away.\n     int32 in_job_read;\n-    job   in_job;               // a job to be read from the client\n+    Job   *in_job;                 // a job to be read from the client\n \n-    job out_job;\n+    Job *out_job;\n     int out_job_sent;\n \n-    struct Ms  watch;\n-    struct job reserved_jobs; // linked list header\n+    Ms  watch;\n+    Job reserved_jobs;             // linked list header\n };\n int  conn_less(void *ax, void *bx);\n void conn_setpos(void *cx, size_t i);\n@@ -361,7 +358,7 @@ void connsched(Conn *c);\n void connclose(Conn *c);\n void connsetproducer(Conn *c);\n void connsetworker(Conn *c);\n-job  connsoonestjob(Conn *c);\n+Job *connsoonestjob(Conn *c);\n int  conndeadlinesoon(Conn *c);\n int conn_ready(Conn *c);\n #define conn_waiting(c) ((c)->type & CONN_TYPE_WAITING)\n@@ -393,10 +390,10 @@ struct Wal {\n     int    nocomp; // disable binlog compaction?\n };\n int  waldirlock(Wal*);\n-void walinit(Wal*, job list);\n-int  walwrite(Wal*, job);\n+void walinit(Wal*, Job *list);\n+int  walwrite(Wal*, Job*);\n void walmaint(Wal*);\n-int  walresvput(Wal*, job);\n+int  walresvput(Wal*, Job*);\n int  walresvupdate(Wal*);\n void walgc(Wal*);\n \n@@ -412,19 +409,19 @@ struct File {\n     char *path;\n     Wal  *w;\n \n-    struct job jlist; // jobs written in this file\n+    Job jlist;    // jobs written in this file\n };\n int  fileinit(File*, Wal*, int);\n Wal* fileadd(File*, Wal*);\n void fileincref(File*);\n void filedecref(File*);\n-void fileaddjob(File*, job);\n-void filermjob(File*, job);\n-int  fileread(File*, job list);\n+void fileaddjob(File*, Job*);\n+void filermjob(File*, Job*);\n+int  fileread(File*, Job *list);\n void filewopen(File*);\n void filewclose(File*);\n-int  filewrjobshort(File*, job);\n-int  filewrjobfull(File*, job);\n+int  filewrjobshort(File*, Job*);\n+int  filewrjobfull(File*, Job*);\n \n \n #define Portdef \"11300\"\n\ndiff --git a/file.c b/file.c\n--- a/file.c\n+++ b/file.c\n@@ -12,8 +12,8 @@\n #include <errno.h>\n #include <string.h>\n \n-static int  readrec(File*, job, int*);\n-static int  readrec5(File*, job, int*);\n+static int  readrec(File*, Job *, int*);\n+static int  readrec5(File*, Job *, int*);\n static int  readfull(File*, void*, int, int*, char*);\n static void warnpos(File*, int, char*, ...)\n __attribute__((format(printf, 3, 4)));\n@@ -70,9 +70,9 @@ filedecref(File *f)\n \n \n void\n-fileaddjob(File *f, job j)\n+fileaddjob(File *f, Job *j)\n {\n-    job h;\n+    Job *h;\n \n     h = &f->jlist;\n     if (!h->fprev) h->fprev = h;\n@@ -86,7 +86,7 @@ fileaddjob(File *f, job j)\n \n \n void\n-filermjob(File *f, job j)\n+filermjob(File *f, Job *j)\n {\n     if (!f) return;\n     if (f != j->file) return;\n@@ -104,7 +104,7 @@ filermjob(File *f, job j)\n // Fileread reads jobs from f->path into list.\n // It returns 0 on success, or 1 if any errors occurred.\n int\n-fileread(File *f, job list)\n+fileread(File *f, Job *list)\n {\n     int err = 0, v;\n \n@@ -133,12 +133,12 @@ fileread(File *f, job list)\n // If an error occurs, it sets *err to 1.\n // Readrec returns the number of records read, either 1 or 0.\n static int\n-readrec(File *f, job l, int *err)\n+readrec(File *f, Job *l, int *err)\n {\n     int r, sz = 0;\n     int namelen;\n     Jobrec jr;\n-    job j;\n+    Job *j;\n     tube t;\n     char tubename[MAX_TUBE_NAME_LEN];\n \n@@ -263,12 +263,12 @@ readrec(File *f, job l, int *err)\n // Readrec5 is like readrec, but it reads a record in \"version 5\"\n // of the log format.\n static int\n-readrec5(File *f, job l, int *err)\n+readrec5(File *f, Job *l, int *err)\n {\n     int r, sz = 0;\n     size_t namelen;\n     Jobrec5 jr;\n-    job j;\n+    Job *j;\n     tube t;\n     char tubename[MAX_TUBE_NAME_LEN];\n \n@@ -475,7 +475,7 @@ filewopen(File *f)\n \n \n static int\n-filewrite(File *f, job j, void *buf, int len)\n+filewrite(File *f, Job *j, void *buf, int len)\n {\n     int r;\n \n@@ -495,7 +495,7 @@ filewrite(File *f, job j, void *buf, int len)\n \n \n int\n-filewrjobshort(File *f, job j)\n+filewrjobshort(File *f, Job *j)\n {\n     int r, nl;\n \n@@ -513,7 +513,7 @@ filewrjobshort(File *f, job j)\n \n \n int\n-filewrjobfull(File *f, job j)\n+filewrjobfull(File *f, Job *j)\n {\n     int nl;\n \n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -7,8 +7,8 @@ static uint64 next_id = 1;\n \n static int cur_prime = 0;\n \n-static job all_jobs_init[12289] = {0};\n-static job *all_jobs = all_jobs_init;\n+static Job *all_jobs_init[12289] = {0};\n+static Job **all_jobs = all_jobs_init;\n static size_t all_jobs_cap = 12289; /* == primes[0] */\n static size_t all_jobs_used = 0;\n \n@@ -23,7 +23,7 @@ _get_job_hash_index(uint64 job_id)\n }\n \n static void\n-store_job(job j)\n+store_job(Job *j)\n {\n     int index = 0;\n \n@@ -40,7 +40,7 @@ store_job(job j)\n static void\n rehash(int is_upscaling)\n {\n-    job *old = all_jobs;\n+    Job **old = all_jobs;\n     size_t old_cap = all_jobs_cap, old_used = all_jobs_used, i;\n     int old_prime = cur_prime;\n     int d = is_upscaling ? 1 : -1;\n@@ -52,7 +52,7 @@ rehash(int is_upscaling)\n     cur_prime += d;\n \n     all_jobs_cap = primes[cur_prime];\n-    all_jobs = calloc(all_jobs_cap, sizeof(job));\n+    all_jobs = calloc(all_jobs_cap, sizeof(Job *));\n     if (!all_jobs) {\n         twarnx(\"Failed to allocate %zu new hash buckets\", all_jobs_cap);\n         hash_table_was_oom = 1;\n@@ -67,7 +67,7 @@ rehash(int is_upscaling)\n \n     for (i = 0; i < old_cap; i++) {\n         while (old[i]) {\n-            job j = old[i];\n+            Job *j = old[i];\n             old[i] = j->ht_next;\n             j->ht_next = NULL;\n             store_job(j);\n@@ -78,40 +78,40 @@ rehash(int is_upscaling)\n     }\n }\n \n-job\n+Job *\n job_find(uint64 job_id)\n {\n-    job jh = NULL;\n+    Job *jh = NULL;\n     int index = _get_job_hash_index(job_id);\n \n     for (jh = all_jobs[index]; jh && jh->r.id != job_id; jh = jh->ht_next);\n \n     return jh;\n }\n \n-job\n+Job *\n allocate_job(int body_size)\n {\n-    job j;\n+    Job *j;\n \n-    j = malloc(sizeof(struct job) + body_size);\n-    if (!j) return twarnx(\"OOM\"), (job) 0;\n+    j = malloc(sizeof(Job) + body_size);\n+    if (!j) return twarnx(\"OOM\"), (Job *) 0;\n \n-    memset(j, 0, sizeof(struct job));\n+    memset(j, 0, sizeof(Job));\n     j->r.created_at = nanoseconds();\n     j->r.body_size = body_size;\n     j->next = j->prev = j; /* not in a linked list */\n     return j;\n }\n \n-job\n+Job *\n make_job_with_id(uint32 pri, int64 delay, int64 ttr,\n                  int body_size, tube tube, uint64 id)\n {\n-    job j;\n+    Job *j;\n \n     j = allocate_job(body_size);\n-    if (!j) return twarnx(\"OOM\"), (job) 0;\n+    if (!j) return twarnx(\"OOM\"), (Job *) 0;\n \n     if (id) {\n         j->r.id = id;\n@@ -131,9 +131,9 @@ make_job_with_id(uint32 pri, int64 delay, int64 ttr,\n }\n \n static void\n-job_hash_free(job j)\n+job_hash_free(Job *j)\n {\n-    job *slot;\n+    Job **slot;\n \n     slot = &all_jobs[_get_job_hash_index(j->r.id)];\n     while (*slot && *slot != j) slot = &(*slot)->ht_next;\n@@ -147,7 +147,7 @@ job_hash_free(job j)\n }\n \n void\n-job_free(job j)\n+job_free(Job *j)\n {\n     if (j) {\n         TUBE_ASSIGN(j->tube, NULL);\n@@ -160,14 +160,14 @@ job_free(job j)\n void\n job_setpos(void *j, size_t pos)\n {\n-    ((job)j)->heap_index = pos;\n+    ((Job *)j)->heap_index = pos;\n }\n \n int\n job_pri_less(void *ja, void *jb)\n {\n-    job a = (job)ja;\n-    job b = (job)jb;\n+    Job *a = (Job *)ja;\n+    Job *b = (Job *)jb;\n     if (a->r.pri < b->r.pri) return 1;\n     if (a->r.pri > b->r.pri) return 0;\n     return a->r.id < b->r.id;\n@@ -176,24 +176,24 @@ job_pri_less(void *ja, void *jb)\n int\n job_delay_less(void *ja, void *jb)\n {\n-    job a = ja;\n-    job b = jb;\n+    Job *a = ja;\n+    Job *b = jb;\n     if (a->r.deadline_at < b->r.deadline_at) return 1;\n     if (a->r.deadline_at > b->r.deadline_at) return 0;\n     return a->r.id < b->r.id;\n }\n \n-job\n-job_copy(job j)\n+Job *\n+job_copy(Job *j)\n {\n-    job n;\n+    Job *n;\n \n     if (!j) return NULL;\n \n-    n = malloc(sizeof(struct job) + j->r.body_size);\n-    if (!n) return twarnx(\"OOM\"), (job) 0;\n+    n = malloc(sizeof(Job) + j->r.body_size);\n+    if (!n) return twarnx(\"OOM\"), (Job *) 0;\n \n-    memcpy(n, j, sizeof(struct job) + j->r.body_size);\n+    memcpy(n, j, sizeof(Job) + j->r.body_size);\n     n->next = n->prev = n; /* not in a linked list */\n \n     n->file = NULL; /* copies do not have refcnt on the wal */\n@@ -208,7 +208,7 @@ job_copy(job j)\n }\n \n const char *\n-job_state(job j)\n+job_state(Job *j)\n {\n     if (j->r.state == Ready) return \"ready\";\n     if (j->r.state == Reserved) return \"reserved\";\n@@ -218,13 +218,13 @@ job_state(job j)\n }\n \n int\n-job_list_any_p(job head)\n+job_list_any_p(Job *head)\n {\n     return head->next != head || head->prev != head;\n }\n \n-job\n-job_remove(job j)\n+Job *\n+job_remove(Job *j)\n {\n     if (!j) return NULL;\n     if (!job_list_any_p(j)) return NULL; /* not in a doubly-linked list */\n@@ -238,7 +238,7 @@ job_remove(job j)\n }\n \n void\n-job_insert(job head, job j)\n+job_insert(Job *head, Job *j)\n {\n     if (job_list_any_p(j)) return; /* already in a linked list */\n \n\ndiff --git a/main.c b/main.c\n--- a/main.c\n+++ b/main.c\n@@ -99,7 +99,7 @@ main(int argc, char **argv)\n             exit(10);\n         }\n \n-        struct job list = {.prev=NULL, .next=NULL};\n+        Job list = {.prev=NULL, .next=NULL};\n         list.prev = list.next = &list;\n         walinit(&srv.wal, &list);\n         r = prot_replay(&srv, &list);\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -276,7 +276,7 @@ static const char * op_names[] = {\n     CMD_KICKJOB,\n };\n \n-static job remove_buried_job(job j);\n+static Job *remove_buried_job(Job *j);\n \n static int\n buried_job_p(tube t)\n@@ -347,7 +347,7 @@ reply_line(Conn *c, int state, const char *fmt, ...)\n }\n \n static void\n-reply_job(Conn *c, job j, const char *word)\n+reply_job(Conn *c, Job *j, const char *word)\n {\n     /* tell this connection which job to send */\n     c->out_job = j;\n@@ -376,7 +376,7 @@ remove_waiting_conn(Conn *c)\n }\n \n static void\n-reserve_job(Conn *c, job j)\n+reserve_job(Conn *c, Job *j)\n {\n     j->r.deadline_at = nanoseconds() + j->r.ttr;\n     global_stat.reserved_ct++; /* stats */\n@@ -392,12 +392,13 @@ reserve_job(Conn *c, job j)\n     return reply_job(c, j, MSG_RESERVED);\n }\n \n-static job\n+static Job *\n next_eligible_job(int64 now)\n {\n     tube t;\n     size_t i;\n-    job j = NULL, candidate;\n+    Job *j = NULL;\n+    Job *candidate;\n \n     for (i = 0; i < tubes.len; i++) {\n         t = tubes.items[i];\n@@ -419,7 +420,7 @@ next_eligible_job(int64 now)\n static void\n process_queue()\n {\n-    job j;\n+    Job *j;\n     int64 now = nanoseconds();\n \n     while ((j = next_eligible_job(now))) {\n@@ -433,12 +434,13 @@ process_queue()\n     }\n }\n \n-static job\n+static Job *\n delay_q_peek()\n {\n     size_t i;\n     tube t;\n-    job j = NULL, nj;\n+    Job *j = NULL;\n+    Job *nj;\n \n     for (i = 0; i < tubes.len; i++) {\n         t = tubes.items[i];\n@@ -454,7 +456,7 @@ delay_q_peek()\n \n /* Inserts job j in the tube, returns 1 on success, otherwise 0 */\n static int\n-enqueue_job(Server *s, job j, int64 delay, char update_store)\n+enqueue_job(Server *s, Job *j, int64 delay, char update_store)\n {\n     int r;\n \n@@ -487,7 +489,7 @@ enqueue_job(Server *s, job j, int64 delay, char update_store)\n }\n \n static int\n-bury_job(Server *s, job j, char update_store)\n+bury_job(Server *s, Job *j, char update_store)\n {\n     if (update_store) {\n         int z = walresvupdate(&s->wal);\n@@ -516,7 +518,7 @@ void\n enqueue_reserved_jobs(Conn *c)\n {\n     int r;\n-    job j;\n+    Job *j;\n \n     while (job_list_any_p(&c->reserved_jobs)) {\n         j = job_remove(c->reserved_jobs.next);\n@@ -528,10 +530,10 @@ enqueue_reserved_jobs(Conn *c)\n     }\n }\n \n-static job\n+static Job *\n delay_q_take()\n {\n-    job j = delay_q_peek();\n+    Job *j = delay_q_peek();\n     if (!j) {\n         return 0;\n     }\n@@ -540,7 +542,7 @@ delay_q_take()\n }\n \n static int\n-kick_buried_job(Server *s, job j)\n+kick_buried_job(Server *s, Job *j)\n {\n     int r;\n     int z;\n@@ -575,7 +577,7 @@ get_delayed_job_ct()\n }\n \n static int\n-kick_delayed_job(Server *s, job j)\n+kick_delayed_job(Server *s, Job *j)\n {\n     int r;\n     int z;\n@@ -616,7 +618,7 @@ kick_delayed_jobs(Server *s, tube t, uint n)\n {\n     uint i;\n     for (i = 0; (i < n) && (t->delay.len > 0); ++i) {\n-        kick_delayed_job(s, (job)t->delay.data[0]);\n+        kick_delayed_job(s, (Job *)t->delay.data[0]);\n     }\n     return i;\n }\n@@ -628,8 +630,8 @@ kick_jobs(Server *s, tube t, uint n)\n     return kick_delayed_jobs(s, t, n);\n }\n \n-static job\n-remove_buried_job(job j)\n+static Job *\n+remove_buried_job(Job *j)\n {\n     if (!j || j->r.state != Buried) return NULL;\n     j = job_remove(j);\n@@ -640,17 +642,17 @@ remove_buried_job(job j)\n     return j;\n }\n \n-static job\n-remove_delayed_job(job j)\n+static Job *\n+remove_delayed_job(Job *j)\n {\n     if (!j || j->r.state != Delayed) return NULL;\n     heapremove(&j->tube->delay, j->heap_index);\n \n     return j;\n }\n \n-static job\n-remove_ready_job(job j)\n+static Job *\n+remove_ready_job(Job *j)\n {\n     if (!j || j->r.state != Ready) return NULL;\n     heapremove(&j->tube->ready, j->heap_index);\n@@ -677,14 +679,14 @@ enqueue_waiting_conn(Conn *c)\n     }\n }\n \n-static job\n-find_reserved_job_in_conn(Conn *c, job j)\n+static Job *\n+find_reserved_job_in_conn(Conn *c, Job *j)\n {\n     return (j && j->reserver == c && j->r.state == Reserved) ? j : NULL;\n }\n \n-static job\n-touch_job(Conn *c, job j)\n+static Job *\n+touch_job(Conn *c, Job *j)\n {\n     j = find_reserved_job_in_conn(c, j);\n     if (j) {\n@@ -694,7 +696,7 @@ touch_job(Conn *c, job j)\n     return j;\n }\n \n-static job\n+static Job *\n peek_job(uint64 id)\n {\n     return job_find(id);\n@@ -824,7 +826,7 @@ static void\n enqueue_incoming_job(Conn *c)\n {\n     int r;\n-    job j = c->in_job;\n+    Job *j = c->in_job;\n \n     c->in_job = NULL; /* the connection no longer owns this job */\n     c->in_job_read = 0;\n@@ -1106,7 +1108,7 @@ do_list_tubes(Conn *c, Ms *l)\n }\n \n static int\n-fmt_job_stats(char *buf, size_t size, job j)\n+fmt_job_stats(char *buf, size_t size, Job *j)\n {\n     int64 t;\n     int64 time_left;\n@@ -1168,7 +1170,7 @@ fmt_stats_tube(char *buf, size_t size, tube t)\n static void\n maybe_enqueue_incoming_job(Conn *c)\n {\n-    job j = c->in_job;\n+    Job *j = c->in_job;\n \n     /* do we have a complete job? */\n     if (c->in_job_read == j->r.body_size) return enqueue_incoming_job(c);\n@@ -1178,8 +1180,8 @@ maybe_enqueue_incoming_job(Conn *c)\n }\n \n /* j can be NULL */\n-static job\n-remove_this_reserved_job(Conn *c, job j)\n+static Job *\n+remove_this_reserved_job(Conn *c, Job *j)\n {\n     j = job_remove(j);\n     if (j) {\n@@ -1191,8 +1193,8 @@ remove_this_reserved_job(Conn *c, job j)\n     return j;\n }\n \n-static job\n-remove_reserved_job(Conn *c, job j)\n+static Job *\n+remove_reserved_job(Conn *c, Job *j)\n {\n     return remove_this_reserved_job(c, find_reserved_job_in_conn(c, j));\n }\n@@ -1217,7 +1219,7 @@ dispatch_cmd(Conn *c)\n     int r, timeout = -1;\n     uint i;\n     uint count;\n-    job j = 0;\n+    Job *j = 0;\n     byte type;\n     char *size_buf, *delay_buf, *ttr_buf, *pri_buf, *end_buf, *name;\n     uint32 pri;\n@@ -1653,7 +1655,7 @@ static void\n conn_timeout(Conn *c)\n {\n     int r, should_timeout = 0;\n-    job j;\n+    Job *j;\n \n     /* Check if the client was trying to reserve a job. */\n     if (conn_waiting(c) && conndeadlinesoon(c)) should_timeout = 1;\n@@ -1712,7 +1714,7 @@ static void\n conn_data(Conn *c)\n {\n     int r, to_read;\n-    job j;\n+    Job *j;\n     struct iovec iov[2];\n \n     switch (c->state) {\n@@ -1901,7 +1903,7 @@ prothandle(Conn *c, int ev)\n int64\n prottick(Server *s)\n {\n-    job j;\n+    Job *j;\n     int64 now;\n     tube t;\n     int64 period = 0x34630B8A000LL; /* 1 hour in nanoseconds */\n@@ -2060,9 +2062,9 @@ prot_init()\n //\n // Returns 1 on success, 0 on failure.\n int\n-prot_replay(Server *s, job list)\n+prot_replay(Server *s, Job *list)\n {\n-    job j, nj;\n+    Job *j, *nj;\n     int64 t, delay;\n     int r, z;\n \n\ndiff --git a/testheap.c b/testheap.c\n--- a/testheap.c\n+++ b/testheap.c\n@@ -15,7 +15,7 @@ cttest_heap_insert_one()\n         .setpos = job_setpos,\n     };\n \n-    job j = make_job(1, 0, 1, 0, 0);\n+    Job *j = make_job(1, 0, 1, 0, 0);\n     assertf(j, \"allocate job\");\n \n     heapinsert(&h, j);\n@@ -35,13 +35,13 @@ cttest_heap_insert_and_remove_one()\n         .setpos = job_setpos,\n     };\n \n-    job j1 = make_job(1, 0, 1, 0, 0);\n+    Job *j1 = make_job(1, 0, 1, 0, 0);\n     assertf(j1, \"allocate job\");\n \n     int r = heapinsert(&h, j1);\n     assertf(r, \"insert should succeed\");\n \n-    job got = heapremove(&h, 0);\n+    Job *got = heapremove(&h, 0);\n     assertf(got == j1, \"j1 should come back out\");\n     assertf(h.len == 0, \"h should be empty.\");\n \n@@ -56,7 +56,7 @@ cttest_heap_priority()\n         .less = job_pri_less,\n         .setpos = job_setpos,\n     };\n-    job j, j1, j2, j3;\n+    Job *j, *j1, *j2, *j3;\n \n     j1 = make_job(1, 0, 1, 0, 0);\n     j2 = make_job(2, 0, 1, 0, 0);\n@@ -105,7 +105,7 @@ cttest_heap_fifo_property()\n         .less = job_pri_less,\n         .setpos = job_setpos,\n     };\n-    job j, j3a, j3b, j3c;\n+    Job *j, *j3a, *j3b, *j3c;\n \n     j3a = make_job(3, 0, 1, 0, 0);\n     j3b = make_job(3, 0, 1, 0, 0);\n@@ -158,7 +158,7 @@ cttest_heap_many_jobs()\n         .setpos = job_setpos,\n     };\n     const int n = 20;\n-    job j;\n+    Job *j;\n \n     int i;\n     for (i = 0; i < n; i++) {\n@@ -192,21 +192,21 @@ cttest_heap_remove_k()\n     int c, i;\n     for (c = 0; c < 50; c++) {\n         for (i = 0; i < n; i++) {\n-            job j = make_job(1 + rand() % 8192, 0, 1, 0, 0);\n+            Job *j = make_job(1 + rand() % 8192, 0, 1, 0, 0);\n             assertf(j, \"allocation\");\n             int r = heapinsert(&h, j);\n             assertf(r, \"heapinsert\");\n         }\n \n         /* remove one from the middle */\n-        job j0 = heapremove(&h, mid);\n+        Job *j0 = heapremove(&h, mid);\n         assertf(j0, \"j0 should not be NULL\");\n         job_free(j0);\n \n         /* now make sure the rest are still a valid heap */\n         uint last_pri = 0;\n         for (i = 1; i < n; i++) {\n-            job j = heapremove(&h, 0);\n+            Job *j = heapremove(&h, 0);\n             assertf(j->r.pri >= last_pri, \"should come out in order\");\n             last_pri = j->r.pri;\n             assertf(j, \"j should not be NULL\");\n@@ -219,7 +219,7 @@ cttest_heap_remove_k()\n void\n ctbench_heap_insert(int n)\n {\n-    job *j = calloc(n, sizeof *j);\n+    Job **j = calloc(n, sizeof *j);\n     int i;\n     for (i = 0; i < n; i++) {\n         j[i] = make_job(1, 0, 1, 0, 0);\n@@ -252,11 +252,11 @@ ctbench_heap_remove(int n)\n     };\n     int i;\n     for (i = 0; i < n; i++) {\n-        job j = make_job(1, 0, 1, 0, 0);\n+        Job *j = make_job(1, 0, 1, 0, 0);\n         assertf(j, \"allocate job\");\n         heapinsert(&h, j);\n     }\n-    job t[n];   // temp storage to deallocate jobs later\n+    Job *t[n];   // temp storage to deallocate jobs later\n \n     ctresettimer();\n     for (i = 0; i < n; i++) {\n\ndiff --git a/testjobs.c b/testjobs.c\n--- a/testjobs.c\n+++ b/testjobs.c\n@@ -11,7 +11,7 @@ static tube default_tube;\n void\n cttest_job_creation()\n {\n-    job j;\n+    Job *j;\n \n     TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n     j = make_job(1, 0, 1, 0, default_tube);\n@@ -21,7 +21,7 @@ cttest_job_creation()\n void\n cttest_job_cmp_pris()\n {\n-    job a, b;\n+    Job *a, *b;\n \n     TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n     a = make_job(1, 0, 1, 0, default_tube);\n@@ -33,7 +33,7 @@ cttest_job_cmp_pris()\n void\n cttest_job_cmp_ids()\n {\n-    job a, b;\n+    Job *a, *b;\n \n     TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n     a = make_job(1, 0, 1, 0, default_tube);\n@@ -46,7 +46,7 @@ cttest_job_cmp_ids()\n void\n cttest_job_large_pris()\n {\n-    job a, b;\n+    Job *a, *b;\n \n     TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n     a = make_job(1, 0, 1, 0, default_tube);\n@@ -63,7 +63,7 @@ cttest_job_large_pris()\n void\n cttest_job_hash_free()\n {\n-    job j;\n+    Job *j;\n     uint64 jid = 83;\n \n     TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n@@ -76,7 +76,7 @@ cttest_job_hash_free()\n void\n cttest_job_hash_free_next()\n {\n-    job a, b;\n+    Job *a, *b;\n     uint64 aid = 97, bid = 12386;\n \n     TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n@@ -93,7 +93,7 @@ cttest_job_hash_free_next()\n void\n cttest_job_all_jobs_used()\n {\n-    job j, x;\n+    Job *j, *x;\n \n     TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n     j = make_job(0, 0, 1, 0, default_tube);\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -192,7 +192,7 @@ mustforksrv(void)\n             exit(10);\n         }\n \n-        struct job list = {\n+        Job list = {\n             .prev = NULL,\n             .next = NULL,\n         };\n\ndiff --git a/tube.c b/tube.c\n--- a/tube.c\n+++ b/tube.c\n@@ -22,7 +22,7 @@ make_tube(const char *name)\n     t->ready.setpos = job_setpos;\n     t->delay.setpos = job_setpos;\n \n-    struct job j = {.tube = NULL};\n+    Job j = {.tube = NULL};\n     t->buried = j;\n     t->buried.prev = t->buried.next = &t->buried;\n     ms_init(&t->waiting, NULL, NULL);\n\ndiff --git a/walg.c b/walg.c\n--- a/walg.c\n+++ b/walg.c\n@@ -102,7 +102,7 @@ ratio(Wal *w)\n \n // Returns the number of bytes reserved or 0 on error.\n static int\n-walresvmigrate(Wal *w, job j)\n+walresvmigrate(Wal *w, Job *j)\n {\n     int z = 0;\n \n@@ -120,7 +120,7 @@ walresvmigrate(Wal *w, job j)\n static void\n moveone(Wal *w)\n {\n-    job j;\n+    Job *j;\n \n     if (w->head == w->cur || w->head->next == w->cur) {\n         // no point in moving a job\n@@ -176,7 +176,7 @@ walsync(Wal *w)\n // Unlke walresv*, walwrite should never fail because of a full disk.\n // If w is disabled, then walwrite takes no action and returns 1.\n int\n-walwrite(Wal *w, job j)\n+walwrite(Wal *w, Job *j)\n {\n     int r = 0;\n \n@@ -368,7 +368,7 @@ reserve(Wal *w, int n)\n \n // Returns the number of bytes reserved or 0 on error.\n int\n-walresvput(Wal *w, job j)\n+walresvput(Wal *w, Job *j)\n {\n     int z = 0;\n \n@@ -438,7 +438,7 @@ waldirlock(Wal *w)\n \n \n void\n-walread(Wal *w, job list, int min)\n+walread(Wal *w, Job *list, int min)\n {\n     File *f;\n     int i, fd;\n@@ -479,7 +479,7 @@ walread(Wal *w, job list, int min)\n \n \n void\n-walinit(Wal *w, job list)\n+walinit(Wal *w, Job *list)\n {\n     int min;\n \n", "test_patch": "", "problem_statement": "drop the pointer from the job typedef\nThis patch is a hell of a (Job *).\r\n\r\nUpdates #458", "version": "1.11", "language": "C", "created_at": "2019-07-26T18:55:20Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-543", "repo": "beanstalkd/beanstalkd", "pull_number": 543, "base_commit": "6b1d67ef584210533a415119c066888c3f4c24dc", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -203,7 +203,13 @@ struct Jobrec {\n     int64  ttr;\n     int32  body_size;\n     int64  created_at;\n+\n+    // deadline_at is a timestamp, in nsec, that points to:\n+    // * time when job will become ready for delayed job,\n+    // * time when TTR is about to expire for reserved job,\n+    // * undefined otherwise.\n     int64  deadline_at;\n+\n     uint32 reserve_ct;\n     uint32 timeout_ct;\n     uint32 release_ct;\n@@ -241,8 +247,14 @@ struct Tube {\n     struct stats stat;\n     uint using_ct;\n     uint watching_ct;\n+\n+    // pause is set to the duration of the current pause, otherwise 0, in nsec.\n     int64 pause;\n+\n+    // dealine_at is a timestamp when to unpause the tube, in nsec.\n+    // TODO: rename to unpause_at\n     int64 deadline_at;\n+\n     Job buried;                 // linked list header\n };\n \n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -496,21 +496,22 @@ process_queue()\n     }\n }\n \n+// soonest_delayed_job returns the delayed job\n+// with the smallest deadline_at among all tubes.\n static Job *\n-delay_q_peek()\n+soonest_delayed_job()\n {\n-    size_t i;\n-    Tube *t;\n     Job *j = NULL;\n-    Job *nj;\n+    size_t i;\n \n     for (i = 0; i < tubes.len; i++) {\n-        t = tubes.items[i];\n+        Tube *t = tubes.items[i];\n         if (t->delay.len == 0) {\n             continue;\n         }\n-        nj = t->delay.data[0];\n-        if (!j || nj->r.deadline_at < j->r.deadline_at) j = nj;\n+        Job *nj = t->delay.data[0];\n+        if (!j || nj->r.deadline_at < j->r.deadline_at)\n+            j = nj;\n     }\n     return j;\n }\n@@ -596,17 +597,6 @@ enqueue_reserved_jobs(Conn *c)\n     }\n }\n \n-static Job *\n-delay_q_take()\n-{\n-    Job *j = delay_q_peek();\n-    if (!j) {\n-        return 0;\n-    }\n-    heapremove(&j->tube->delay, j->heap_index);\n-    return j;\n-}\n-\n static int\n kick_buried_job(Server *s, Job *j)\n {\n@@ -2070,13 +2060,16 @@ prottick(Server *s)\n     int64 d;\n \n     now = nanoseconds();\n-    while ((j = delay_q_peek())) {\n+\n+    // Enqueue all jobs that are no longer delayed.\n+    // Capture the smallest period from the soonest delayed job.\n+    while ((j = soonest_delayed_job())) {\n         d = j->r.deadline_at - now;\n         if (d > 0) {\n             period = min(period, d);\n             break;\n         }\n-        j = delay_q_take();\n+        heapremove(&j->tube->delay, j->heap_index);\n         int r = enqueue_job(s, j, 0, 0);\n         if (r < 1)\n             bury_job(s, j, 0);  /* out of memory */\n@@ -2106,7 +2099,6 @@ prottick(Server *s)\n             period = min(period, d);\n             break;\n         }\n-\n         heapremove(&s->conns, 0);\n         c->in_conns = 0;\n         conn_timeout(c);\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -870,6 +870,44 @@ cttest_small_delay()\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n }\n \n+void\n+cttest_delayed_to_ready()\n+{\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n+    mustsend(fd, \"put 0 1 1 0\\r\\n\");\n+    mustsend(fd, \"\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+\n+    mustsend(fd, \"stats-tube default\\r\\n\");\n+    ckrespsub(fd, \"OK \");\n+    ckrespsub(fd, \"\\ncurrent-jobs-ready: 0\\n\");\n+\n+    mustsend(fd, \"stats-tube default\\r\\n\");\n+    ckrespsub(fd, \"OK \");\n+    ckrespsub(fd, \"\\ncurrent-jobs-delayed: 1\\n\");\n+\n+    mustsend(fd, \"stats-tube default\\r\\n\");\n+    ckrespsub(fd, \"OK \");\n+    ckrespsub(fd, \"\\ntotal-jobs: 1\\n\");\n+\n+    usleep(1010000); // 1.01 sec\n+\n+    // check that after 1 sec the delayed job is ready again\n+\n+    mustsend(fd, \"stats-tube default\\r\\n\");\n+    ckrespsub(fd, \"OK \");\n+    ckrespsub(fd, \"\\ncurrent-jobs-ready: 1\\n\");\n+\n+    mustsend(fd, \"stats-tube default\\r\\n\");\n+    ckrespsub(fd, \"OK \");\n+    ckrespsub(fd, \"\\ncurrent-jobs-delayed: 0\\n\");\n+\n+    mustsend(fd, \"stats-tube default\\r\\n\");\n+    ckrespsub(fd, \"OK \");\n+    ckrespsub(fd, \"\\ntotal-jobs: 1\\n\");\n+}\n+\n void\n cttest_statsjob_ck_format()\n {\n", "test_patch": "", "problem_statement": "rename delay_q_peek() to soonest_delayed_job()\nI have removed the delay_q_take() function because it had\r\nonly one line added compared to delay_q_peek(). That line\r\nwas put in place. As a result prottick() became easier to read.", "version": "1.11", "language": "C", "created_at": "2019-08-13T07:53:53Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-511", "repo": "beanstalkd/beanstalkd", "pull_number": 511, "base_commit": "167b0f614eeb5070da8b91ffbd0c473d61aed368", "patch": "diff --git a/doc/protocol.txt b/doc/protocol.txt\n--- a/doc/protocol.txt\n+++ b/doc/protocol.txt\n@@ -654,7 +654,7 @@ they are not stored on disk with the -b flag.\n  - \"draining\" is set to \"true\" if the server is in drain mode,\n    \"false\" otherwise.\n \n- - \"id\" is a random id string for this server process, generated when each\n+ - \"id\" is a random id string for this server process, generated every time\n    beanstalkd process starts.\n \n  - \"hostname\" the hostname of the machine as determined by uname.\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -229,11 +229,8 @@ static Tube *default_tube;\n static int drain_mode = 0;\n static int64 started_at;\n \n-enum {\n-  NumIdBytes = 8\n-};\n-\n-static char id[NumIdBytes * 2 + 1]; // hex-encoded len of NumIdBytes\n+enum { instance_id_bytes = 8 };\n+static char instance_hex[instance_id_bytes * 2 + 1]; // hex-encoded len of instance_id_bytes\n \n static struct utsname node_info;\n static uint64 op_ct[TOTAL_OPS], timeout_ct = 0;\n@@ -928,7 +925,7 @@ fmt_stats(char *buf, size_t size, void *x)\n             srv->wal.nrec,\n             srv->wal.filesize,\n             drain_mode ? \"true\" : \"false\",\n-            id,\n+            instance_hex,\n             node_info.nodename);\n }\n \n@@ -2027,14 +2024,14 @@ prot_init()\n     }\n \n     int i, r;\n-    byte rand_data[NumIdBytes];\n-    r = read(dev_random, &rand_data, NumIdBytes);\n-    if (r != NumIdBytes) {\n+    byte rand_data[instance_id_bytes];\n+    r = read(dev_random, &rand_data, instance_id_bytes);\n+    if (r != instance_id_bytes) {\n         twarn(\"read /dev/urandom\");\n         exit(50);\n     }\n-    for (i = 0; i < NumIdBytes; i++) {\n-        sprintf(id + (i * 2), \"%02x\", rand_data[i]);\n+    for (i = 0; i < instance_id_bytes; i++) {\n+        sprintf(instance_hex + (i * 2), \"%02x\", rand_data[i]);\n     }\n     close(dev_random);\n \n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -1361,11 +1361,16 @@ dispatch_cmd(Conn *c)\n             return reply_msg(c, MSG_BAD_FORMAT);\n         op_ct[type]++;\n \n-        j = job_find(id);\n-        j = remove_reserved_job(c, j) ? :\n-            remove_ready_job(j) ? :\n-            remove_buried_job(j) ? :\n-            remove_delayed_job(j);\n+        {\n+            Job *jf = job_find(id);\n+            j = remove_reserved_job(c, jf);\n+            if (!j)\n+                j = remove_ready_job(jf);\n+            if (!j)\n+                j = remove_buried_job(jf);\n+            if (!j)\n+                j = remove_delayed_job(jf);\n+        }\n \n         if (!j)\n             return reply_msg(c, MSG_NOTFOUND);\n", "test_patch": "", "problem_statement": "rename global var id into instance_hex\nThis variable name was a poor choice. And in many places id is being used as local var, shadowing the global var. So instead use this unique name.", "version": "1.11", "language": "C", "created_at": "2019-07-29T13:33:48Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-563", "repo": "beanstalkd/beanstalkd", "pull_number": 563, "base_commit": "d18aa2341538c04f4da03176792056289dc20f35", "patch": "diff --git a/doc/protocol.txt b/doc/protocol.txt\n--- a/doc/protocol.txt\n+++ b/doc/protocol.txt\n@@ -251,6 +251,23 @@ in the form of a text line followed by the job body:\n    previous line. This is a verbatim copy of the bytes that were originally\n    sent to the server in the put command for this job.\n \n+A job can be reserved by its id. Once a job is reserved for the client,\n+the client has limited time to run (TTR) the job before the job times out.\n+When the job times out, the server will put the job back into the ready queue.\n+The command looks like this:\n+\n+    reserve-job <id>\\r\\n\n+\n+- <id> is the job id to reserve\n+\n+This should immediately return one of these responses:\n+\n+- \"NOT_FOUND\\r\\n\" if the job does not exist or reserved by a client or\n+  is not either ready, buried or delayed.\n+\n+- \"RESERVED <id> <bytes>\\r\\n<data>\\r\\n\". See the description for\n+  the reserve command.\n+\n The delete command removes a job from the server entirely. It is normally used\n by the client when the job has successfully run to completion. A client can\n delete jobs that it has reserved, ready jobs, delayed jobs, and jobs that are\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -81,10 +81,11 @@ rehash(int is_upscaling)\n Job *\n job_find(uint64 job_id)\n {\n-    Job *jh = NULL;\n     int index = _get_job_hash_index(job_id);\n+    Job *jh = all_jobs[index];\n \n-    for (jh = all_jobs[index]; jh && jh->r.id != job_id; jh = jh->ht_next);\n+    while (jh && jh->r.id != job_id)\n+        jh = jh->ht_next;\n \n     return jh;\n }\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -30,6 +30,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define CMD_PEEK_BURIED \"peek-buried\"\n #define CMD_RESERVE \"reserve\"\n #define CMD_RESERVE_TIMEOUT \"reserve-with-timeout \"\n+#define CMD_RESERVE_JOB \"reserve-job \"\n #define CMD_DELETE \"delete \"\n #define CMD_RELEASE \"release \"\n #define CMD_BURY \"bury \"\n@@ -56,6 +57,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define CMD_PEEKJOB_LEN CONSTSTRLEN(CMD_PEEKJOB)\n #define CMD_RESERVE_LEN CONSTSTRLEN(CMD_RESERVE)\n #define CMD_RESERVE_TIMEOUT_LEN CONSTSTRLEN(CMD_RESERVE_TIMEOUT)\n+#define CMD_RESERVE_JOB_LEN CONSTSTRLEN(CMD_RESERVE_JOB)\n #define CMD_DELETE_LEN CONSTSTRLEN(CMD_DELETE)\n #define CMD_RELEASE_LEN CONSTSTRLEN(CMD_RELEASE)\n #define CMD_BURY_LEN CONSTSTRLEN(CMD_BURY)\n@@ -130,7 +132,8 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define OP_QUIT 22\n #define OP_PAUSE_TUBE 23\n #define OP_KICKJOB 24\n-#define TOTAL_OPS 25\n+#define OP_RESERVE_JOB 25\n+#define TOTAL_OPS 26\n \n #define STATS_FMT \"---\\n\" \\\n     \"current-jobs-urgent: %\" PRIu64 \"\\n\" \\\n@@ -271,6 +274,7 @@ static const char * op_names[] = {\n     CMD_QUIT,\n     CMD_PAUSE_TUBE,\n     CMD_KICKJOB,\n+    CMD_RESERVE_JOB,\n };\n \n static Job *remove_buried_job(Job *j);\n@@ -677,6 +681,8 @@ kick_jobs(Server *s, Tube *t, uint n)\n     return kick_delayed_jobs(s, t, n);\n }\n \n+// remove_buried_job returns non-NULL value if job j was in the buried state.\n+// It excludes the job from the buried list and updates counters.\n static Job *\n remove_buried_job(Job *j)\n {\n@@ -690,6 +696,8 @@ remove_buried_job(Job *j)\n     return j;\n }\n \n+// remove_delayed_job returns non-NULL value if job j was in the delayed state.\n+// It removes the job from the tube delayed heap.\n static Job *\n remove_delayed_job(Job *j)\n {\n@@ -700,6 +708,8 @@ remove_delayed_job(Job *j)\n     return j;\n }\n \n+// remove_ready_job returns non-NULL value if job j was in the ready state.\n+// It removes the job from the tube ready heap and updates counters.\n static Job *\n remove_ready_job(Job *j)\n {\n@@ -774,6 +784,7 @@ which_cmd(Conn *c)\n     TEST_CMD(c->cmd, CMD_PEEK_DELAYED, OP_PEEK_DELAYED);\n     TEST_CMD(c->cmd, CMD_PEEK_BURIED, OP_PEEK_BURIED);\n     TEST_CMD(c->cmd, CMD_RESERVE_TIMEOUT, OP_RESERVE_TIMEOUT);\n+    TEST_CMD(c->cmd, CMD_RESERVE_JOB, OP_RESERVE_JOB);\n     TEST_CMD(c->cmd, CMD_RESERVE, OP_RESERVE);\n     TEST_CMD(c->cmd, CMD_DELETE, OP_DELETE);\n     TEST_CMD(c->cmd, CMD_RELEASE, OP_RELEASE);\n@@ -1446,6 +1457,48 @@ dispatch_cmd(Conn *c)\n         process_queue();\n         return;\n \n+    case OP_RESERVE_JOB:\n+        if (read_u64(&id, c->cmd + CMD_RESERVE_JOB_LEN, NULL)) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n+        op_ct[type]++;\n+\n+        // This command could produce \"deadline soon\" if\n+        // the connection has a reservation about to expire.\n+        // We choose not to do it, because this command does not block\n+        // for an arbitrary amount of time as reserve and reserve-with-timeout.\n+\n+        j = job_find(id);\n+        if (!j) {\n+            reply_msg(c, MSG_NOTFOUND);\n+            return;\n+        }\n+        // Check if this job is already reserved.\n+        if (j->r.state == Reserved || j->r.state == Invalid) {\n+            reply_msg(c, MSG_NOTFOUND);\n+            return;\n+        }\n+\n+        // Job can be in ready, buried or delayed states.\n+        if (j->r.state == Ready) {\n+            j = remove_ready_job(j);\n+        } else if (j->r.state == Buried) {\n+            j = remove_buried_job(j);\n+        } else if (j->r.state == Delayed) {\n+            j = remove_delayed_job(j);\n+        } else {\n+            reply_serr(c, MSG_INTERNAL_ERROR);\n+            return;\n+        }\n+\n+        connsetworker(c);\n+        global_stat.reserved_ct++;\n+\n+        conn_reserve_job(c, j);\n+        reply_job(c, j, MSG_RESERVED);\n+        return;\n+\n     case OP_DELETE:\n         if (read_u64(&id, c->cmd + CMD_DELETE_LEN, NULL)) {\n             reply_msg(c, MSG_BAD_FORMAT);\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -1121,36 +1121,209 @@ void\n cttest_reserve_ttr_deadline_soon()\n {\n     int port = SERVER();\n-    int prod = mustdiallocal(port);\n+    int fd = mustdiallocal(port);\n \n-    mustsend(prod, \"put 0 0 1 1\\r\\n\");\n-    mustsend(prod, \"a\\r\\n\");\n-    ckresp(prod, \"INSERTED 1\\r\\n\");\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"a\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n \n-    mustsend(prod, \"reserve-with-timeout 1\\r\\n\");\n-    ckresp(prod, \"RESERVED 1 1\\r\\n\");\n-    ckresp(prod, \"a\\r\\n\");\n+    mustsend(fd, \"reserve-with-timeout 1\\r\\n\");\n+    ckresp(fd, \"RESERVED 1 1\\r\\n\");\n+    ckresp(fd, \"a\\r\\n\");\n \n-    // After 0.3s the job should be still reserved.\n-    usleep(300000);\n-    mustsend(prod, \"stats-job 1\\r\\n\");\n-    ckrespsub(prod, \"OK \");\n-    ckrespsub(prod, \"\\nstate: reserved\\n\");\n+    // After 0.2s the job should be still reserved.\n+    usleep(200000);\n+    mustsend(fd, \"stats-job 1\\r\\n\");\n+    ckrespsub(fd, \"OK \");\n+    ckrespsub(fd, \"\\nstate: reserved\\n\");\n \n-    mustsend(prod, \"reserve-with-timeout 1\\r\\n\");\n-    ckresp(prod, \"DEADLINE_SOON\\r\\n\");\n+    mustsend(fd, \"reserve-with-timeout 1\\r\\n\");\n+    ckresp(fd, \"DEADLINE_SOON\\r\\n\");\n \n     // Job should be reserved; last \"reserve\" took less than 1s.\n-    mustsend(prod, \"stats-job 1\\r\\n\");\n-    ckrespsub(prod, \"OK \");\n-    ckrespsub(prod, \"\\nstate: reserved\\n\");\n+    mustsend(fd, \"stats-job 1\\r\\n\");\n+    ckrespsub(fd, \"OK \");\n+    ckrespsub(fd, \"\\nstate: reserved\\n\");\n \n     // We don't want to process the job, so release it and check that it's ready.\n-    mustsend(prod, \"release 1 0 0\\r\\n\");\n-    ckresp(prod, \"RELEASED\\r\\n\");\n-    mustsend(prod, \"stats-job 1\\r\\n\");\n-    ckrespsub(prod, \"OK \");\n-    ckrespsub(prod, \"\\nstate: ready\\n\");\n+    mustsend(fd, \"release 1 0 0\\r\\n\");\n+    ckresp(fd, \"RELEASED\\r\\n\");\n+    mustsend(fd, \"stats-job 1\\r\\n\");\n+    ckrespsub(fd, \"OK \");\n+    ckrespsub(fd, \"\\nstate: ready\\n\");\n+}\n+\n+void\n+cttest_reserve_job_ttr_deadline_soon()\n+{\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n+\n+    mustsend(fd, \"put 0 5 1 1\\r\\n\");\n+    mustsend(fd, \"a\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+\n+    mustsend(fd, \"stats-job 1\\r\\n\");\n+    ckrespsub(fd, \"OK \");\n+    ckrespsub(fd, \"\\nstate: delayed\\n\");\n+\n+    mustsend(fd, \"reserve-job 1\\r\\n\");\n+    ckresp(fd, \"RESERVED 1 1\\r\\n\");\n+    ckresp(fd, \"a\\r\\n\");\n+\n+    // After 0.1s the job should be still reserved.\n+    usleep(100000);\n+    mustsend(fd, \"stats-job 1\\r\\n\");\n+    ckrespsub(fd, \"OK \");\n+    ckrespsub(fd, \"\\nstate: reserved\\n\");\n+\n+    // Reservation made with reserve-job should behave the same way as other\n+    // reserve commands, e.g. produce \"deadline soon\" message, and get released\n+    // when ttr ends.\n+    mustsend(fd, \"reserve-with-timeout 1\\r\\n\");\n+    ckresp(fd, \"DEADLINE_SOON\\r\\n\");\n+\n+    // Job should be reserved; last \"reserve\" took less than 1s.\n+    mustsend(fd, \"stats-job 1\\r\\n\");\n+    ckrespsub(fd, \"OK \");\n+    ckrespsub(fd, \"\\nstate: reserved\\n\");\n+\n+    // We are not able to process the job in time. Check that it gets released.\n+    // The job was in delayed state. It becomes ready when it gets auto-released.\n+    usleep(1000000); // 1.0s\n+    // put a dummy job\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"B\\r\\n\");\n+    ckresp(fd, \"INSERTED 2\\r\\n\");\n+    // check that ID=1 gets released\n+    mustsend(fd, \"stats-job 1\\r\\n\");\n+    ckrespsub(fd, \"OK \");\n+    ckrespsub(fd, \"\\nstate: ready\\n\");\n+}\n+\n+void\n+cttest_reserve_job_already_reserved()\n+{\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n+\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"A\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+\n+    mustsend(fd, \"reserve-job 1\\r\\n\");\n+    ckresp(fd, \"RESERVED 1 1\\r\\n\");\n+    ckresp(fd, \"A\\r\\n\");\n+\n+    // Job should not be reserved twice.\n+    mustsend(fd, \"reserve-job 1\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+}\n+\n+void\n+cttest_reserve_job_ready()\n+{\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n+\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"A\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"B\\r\\n\");\n+    ckresp(fd, \"INSERTED 2\\r\\n\");\n+\n+    mustsend(fd, \"reserve-job 2\\r\\n\");\n+    ckresp(fd, \"RESERVED 2 1\\r\\n\");\n+    ckresp(fd, \"B\\r\\n\");\n+\n+    // Non-existing job.\n+    mustsend(fd, \"reserve-job 3\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+\n+    // id=1 was not reserved.\n+    mustsend(fd, \"release 1 1 0\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+\n+    mustsend(fd, \"release 2 1 0\\r\\n\");\n+    ckresp(fd, \"RELEASED\\r\\n\");\n+}\n+\n+void\n+cttest_reserve_job_delayed()\n+{\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n+\n+    mustsend(fd, \"put 0 100 1 1\\r\\n\");\n+    mustsend(fd, \"A\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+    mustsend(fd, \"put 0 100 1 1\\r\\n\");\n+    mustsend(fd, \"B\\r\\n\");\n+    ckresp(fd, \"INSERTED 2\\r\\n\");\n+    mustsend(fd, \"put 0 100 1 1\\r\\n\");\n+    mustsend(fd, \"C\\r\\n\");\n+    ckresp(fd, \"INSERTED 3\\r\\n\");\n+\n+    mustsend(fd, \"reserve-job 2\\r\\n\");\n+    ckresp(fd, \"RESERVED 2 1\\r\\n\");\n+    ckresp(fd, \"B\\r\\n\");\n+\n+    mustsend(fd, \"release 2 1 0\\r\\n\");\n+    ckresp(fd, \"RELEASED\\r\\n\");\n+\n+    // verify that job was released in ready state.\n+    mustsend(fd, \"stats-job 2\\r\\n\");\n+    ckrespsub(fd, \"OK \");\n+    ckrespsub(fd, \"\\nstate: ready\\n\");\n+}\n+\n+void\n+cttest_reserve_job_buried()\n+{\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n+\n+    // put, reserve and bury\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"A\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+    mustsend(fd, \"reserve-job 1\\r\\n\");\n+    ckresp(fd, \"RESERVED 1 1\\r\\n\");\n+    ckresp(fd, \"A\\r\\n\");\n+    mustsend(fd, \"bury 1 1\\r\\n\");\n+    ckresp(fd, \"BURIED\\r\\n\");\n+\n+    // put, reserve and bury\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"B\\r\\n\");\n+    ckresp(fd, \"INSERTED 2\\r\\n\");\n+    mustsend(fd, \"reserve-job 2\\r\\n\");\n+    ckresp(fd, \"RESERVED 2 1\\r\\n\");\n+    ckresp(fd, \"B\\r\\n\");\n+    mustsend(fd, \"bury 2 1\\r\\n\");\n+    ckresp(fd, \"BURIED\\r\\n\");\n+\n+    // reserve by ids\n+    mustsend(fd, \"reserve-job 2\\r\\n\");\n+    ckresp(fd, \"RESERVED 2 1\\r\\n\");\n+    ckresp(fd, \"B\\r\\n\");\n+    mustsend(fd, \"reserve-job 1\\r\\n\");\n+    ckresp(fd, \"RESERVED 1 1\\r\\n\");\n+    ckresp(fd, \"A\\r\\n\");\n+\n+    // release back and check if jobs are ready.\n+    mustsend(fd, \"release 1 1 0\\r\\n\");\n+    ckresp(fd, \"RELEASED\\r\\n\");\n+    mustsend(fd, \"release 2 1 0\\r\\n\");\n+    ckresp(fd, \"RELEASED\\r\\n\");\n+    mustsend(fd, \"stats-job 1\\r\\n\");\n+    ckrespsub(fd, \"OK \");\n+    ckrespsub(fd, \"\\nstate: ready\\n\");\n+    mustsend(fd, \"stats-job 2\\r\\n\");\n+    ckrespsub(fd, \"OK \");\n+    ckrespsub(fd, \"\\nstate: ready\\n\");\n+\n }\n \n void\n", "test_patch": "", "problem_statement": "add the \"reserve-job\" command\nA job can be reserved by an ID in the Ready, Buried or Delayed states.\r\nReservation made with this command does not differ from reservations\r\nmade by \"reserve\" or \"reserve-with-timeout\" commands. The new command\r\ndoes not produce \"deadline soon\" when there are other jobs about to expire.\r\n\r\nFixes #310\r\nFixes #222\r\nFixes #240", "version": "1.11", "language": "C", "created_at": "2019-09-07T14:08:11Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-541", "repo": "beanstalkd/beanstalkd", "pull_number": 541, "base_commit": "91a5ea1244f7182cb5752a3e453fb67bd23c4252", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -478,5 +478,6 @@ struct Server {\n     // Connections that must produce deadline or timeout, ordered by the time.\n     Heap   conns;\n };\n+void srv_acquire_wal(Server *s);\n void srvserve(Server *s);\n void srvaccept(Server *s, int ev);\n\ndiff --git a/main.c b/main.c\n--- a/main.c\n+++ b/main.c\n@@ -108,25 +108,7 @@ main(int argc, char **argv)\n         su(srv.user);\n     set_sig_handlers();\n \n-    if (srv.wal.use) {\n-        // We want to make sure that only one beanstalkd tries\n-        // to use the wal directory at a time. So acquire a lock\n-        // now and never release it.\n-        if (!waldirlock(&srv.wal)) {\n-            twarnx(\"failed to lock wal dir %s\", srv.wal.dir);\n-            exit(10);\n-        }\n-\n-        Job list = {.prev=NULL, .next=NULL};\n-        list.prev = list.next = &list;\n-        walinit(&srv.wal, &list);\n-        r = prot_replay(&srv, &list);\n-        if (!r) {\n-            twarnx(\"failed to replay log\");\n-            exit(1);\n-        }\n-    }\n-\n+    srv_acquire_wal(&srv);\n     srvserve(&srv);\n     exit(0);\n }\n\ndiff --git a/serv.c b/serv.c\n--- a/serv.c\n+++ b/serv.c\n@@ -10,6 +10,29 @@ struct Server srv = {\n     },\n };\n \n+// srv_acquire_wal tries to lock the wal dir specified by s->wal and\n+// replay entries from it to initialize the s state with jobs.\n+// On errors it exits from the program.\n+void srv_acquire_wal(Server *s) {\n+    if (s->wal.use) {\n+        // We want to make sure that only one beanstalkd tries\n+        // to use the wal directory at a time. So acquire a lock\n+        // now and never release it.\n+        if (!waldirlock(&s->wal)) {\n+            twarnx(\"failed to lock wal dir %s\", s->wal.dir);\n+            exit(10);\n+        }\n+\n+        Job list = {.prev=NULL, .next=NULL};\n+        list.prev = list.next = &list;\n+        walinit(&s->wal, &list);\n+        int ok = prot_replay(s, &list);\n+        if (!ok) {\n+            twarnx(\"failed to replay log\");\n+            exit(1);\n+        }\n+    }\n+}\n \n void\n srvserve(Server *s)\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -183,27 +183,7 @@ mustforksrv(void)\n     set_sig_handler();\n     prot_init();\n \n-    if (srv.wal.use) {\n-        // We want to make sure that only one beanstalkd tries\n-        // to use the wal directory at a time. So acquire a lock\n-        // now and never release it.\n-        if (!waldirlock(&srv.wal)) {\n-            twarnx(\"failed to lock wal dir %s\", srv.wal.dir);\n-            exit(10);\n-        }\n-\n-        Job list = {\n-            .prev = NULL,\n-            .next = NULL,\n-        };\n-        list.prev = list.next = &list;\n-        walinit(&srv.wal, &list);\n-        int ok = prot_replay(&srv, &list);\n-        if (!ok) {\n-            twarnx(\"failed to replay log\");\n-            exit(11);\n-        }\n-    }\n+    srv_acquire_wal(&srv);\n \n     srvserve(&srv); /* does not return */\n     exit(1); /* satisfy the compiler */\n", "test_patch": "", "problem_statement": "factor out the code acquiring the wal dir\nThis removed duplication of code between the testing and server sites.\r\nAlso it enables adding specialized function for forking the server in\r\ntests, namely testing of AF_UNIX in #150.", "version": "1.11", "language": "C", "created_at": "2019-08-11T07:50:46Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-550", "repo": "beanstalkd/beanstalkd", "pull_number": 550, "base_commit": "e07b1d8ec70187377b81a005558a396a5afeb57e", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -47,7 +47,7 @@ typedef int(FAlloc)(int, int);\n // A command can be at most LINE_BUF_SIZE chars, including \"\\r\\n\". This value\n // MUST be enough to hold the longest possible command (\"pause-tube a{200} 4294967295\\r\\n\")\n // or reply line (\"USING a{200}\\r\\n\").\n-#define LINE_BUF_SIZE 224\n+#define LINE_BUF_SIZE (11 + MAX_TUBE_NAME_LEN + 12)\n \n #define min(a,b) ((a)<(b)?(a):(b))\n \n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -1633,7 +1633,7 @@ dispatch_cmd(Conn *c)\n \n     case OP_STATS_TUBE:\n         name = c->cmd + CMD_STATS_TUBE_LEN;\n-        if (!name_is_ok(name, 200)) {\n+        if (!name_is_ok(name, MAX_TUBE_NAME_LEN - 1)) {\n             reply_msg(c, MSG_BAD_FORMAT);\n             return;\n         }\n@@ -1680,7 +1680,7 @@ dispatch_cmd(Conn *c)\n \n     case OP_USE:\n         name = c->cmd + CMD_USE_LEN;\n-        if (!name_is_ok(name, 200)) {\n+        if (!name_is_ok(name, MAX_TUBE_NAME_LEN - 1)) {\n             reply_msg(c, MSG_BAD_FORMAT);\n             return;\n         }\n@@ -1702,7 +1702,7 @@ dispatch_cmd(Conn *c)\n \n     case OP_WATCH:\n         name = c->cmd + CMD_WATCH_LEN;\n-        if (!name_is_ok(name, 200)) {\n+        if (!name_is_ok(name, MAX_TUBE_NAME_LEN - 1)) {\n             reply_msg(c, MSG_BAD_FORMAT);\n             return;\n         }\n@@ -1727,7 +1727,7 @@ dispatch_cmd(Conn *c)\n \n     case OP_IGNORE:\n         name = c->cmd + CMD_IGNORE_LEN;\n-        if (!name_is_ok(name, 200)) {\n+        if (!name_is_ok(name, MAX_TUBE_NAME_LEN - 1)) {\n             reply_msg(c, MSG_BAD_FORMAT);\n             return;\n         }\n@@ -1765,7 +1765,7 @@ dispatch_cmd(Conn *c)\n         op_ct[type]++;\n \n         *delay_buf = '\\0';\n-        if (!name_is_ok(name, 200)) {\n+        if (!name_is_ok(name, MAX_TUBE_NAME_LEN - 1)) {\n             reply_msg(c, MSG_BAD_FORMAT);\n             return;\n         }\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -1312,6 +1312,34 @@ cttest_list_tube()\n     ckresp(fd0, \"NOT_IGNORED\\r\\n\");\n }\n \n+#define STRING_LEN_200  \\\n+    \"0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\" \\\n+    \"0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\"\n+\n+void\n+cttest_use_tube_long()\n+{\n+    int port = SERVER();\n+    int fd0 = mustdiallocal(port);\n+    // 200 chars is okay\n+    mustsend(fd0, \"use \" STRING_LEN_200 \"\\r\\n\");\n+    ckresp(fd0, \"USING \" STRING_LEN_200 \"\\r\\n\");\n+    // 201 chars is too much\n+    mustsend(fd0, \"use \" STRING_LEN_200 \"Z\\r\\n\");\n+    ckresp(fd0, \"BAD_FORMAT\\r\\n\");\n+}\n+\n+void\n+cttest_longest_command()\n+{\n+    int port = SERVER();\n+    int fd0 = mustdiallocal(port);\n+    mustsend(fd0, \"use \" STRING_LEN_200 \"\\r\\n\");\n+    ckresp(fd0, \"USING \" STRING_LEN_200 \"\\r\\n\");\n+    mustsend(fd0, \"pause-tube \" STRING_LEN_200 \" 4294967295\\r\\n\");\n+    ckresp(fd0, \"PAUSED\\r\\n\");\n+}\n+\n void\n cttest_binlog_empty_exit()\n {\n\ndiff --git a/tube.c b/tube.c\n--- a/tube.c\n+++ b/tube.c\n@@ -8,15 +8,15 @@ struct Ms tubes;\n Tube *\n make_tube(const char *name)\n {\n-    Tube *t;\n-\n-    t = new(Tube);\n-    if (!t) return NULL;\n+    Tube *t = new(Tube);\n+    if (!t)\n+        return NULL;\n \n-    t->name[MAX_TUBE_NAME_LEN - 1] = '\\0';\n-    strncpy(t->name, name, MAX_TUBE_NAME_LEN - 1);\n-    if (t->name[MAX_TUBE_NAME_LEN - 1] != '\\0')\n+    strncpy(t->name, name, MAX_TUBE_NAME_LEN);\n+    if (t->name[MAX_TUBE_NAME_LEN - 1] != '\\0') {\n+        t->name[MAX_TUBE_NAME_LEN - 1] = '\\0';\n         twarnx(\"truncating tube name\");\n+    }\n \n     t->ready.less = job_pri_less;\n     t->delay.less = job_delay_less;\n", "test_patch": "", "problem_statement": "fix the way tube is truncated\nTube truncation is checked correctly in this patch.\r\nThis should not ever happen because code calling it checks\r\nif the tube name is shorter than 201 chars.\r\n\r\nAlso some tests and fixes for the magic number 200.\r\n\r\nFixes #224", "version": "1.11", "language": "C", "created_at": "2019-08-16T15:44:08Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-522", "repo": "beanstalkd/beanstalkd", "pull_number": 522, "base_commit": "e9a9e7b94196ce51a193a5bbcc3f7ae690ac3674", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -274,7 +274,7 @@ void job_free(Job *j);\n Job *job_find(uint64 job_id);\n \n /* the void* parameters are really job pointers */\n-void job_setpos(void *j, size_t i);\n+void job_setpos(void *j, size_t pos);\n int job_pri_less(void *ja, void *jb);\n int job_delay_less(void *ja, void *jb);\n \n@@ -321,12 +321,12 @@ Conn *remove_waiting_conn(Conn *c);\n void enqueue_reserved_jobs(Conn *c);\n \n void enter_drain_mode(int sig);\n-void h_accept(const int fd, const short which, Server* srv);\n+void h_accept(const int fd, const short which, Server *s);\n void prot_remove_tube(Tube *t);\n int  prot_replay(Server *s, Job *list);\n \n \n-int make_server_socket(char *host_addr, char *port);\n+int make_server_socket(char *host, char *port);\n \n \n struct Conn {\n@@ -366,8 +366,8 @@ struct Conn {\n     Ms  watch;\n     Job reserved_jobs;             // linked list header\n };\n-int  conn_less(void *ax, void *bx);\n-void conn_setpos(void *cx, size_t i);\n+int  conn_less(void *ca, void *cb);\n+void conn_setpos(void *c, size_t i);\n void connwant(Conn *c, int rw);\n void connsched(Conn *c);\n void connclose(Conn *c);\n@@ -452,5 +452,5 @@ struct Server {\n     // Connections that must produce deadline or timeout, ordered by the time.\n     Heap   conns;\n };\n-void srvserve(Server *srv);\n+void srvserve(Server *s);\n void srvaccept(Server *s, int ev);\n\ndiff --git a/file.c b/file.c\n--- a/file.c\n+++ b/file.c\n@@ -338,7 +338,6 @@ readrec5(File *f, Job *l, int *err)\n             j = make_job_with_id(jr.pri, jr.delay, jr.ttr, jr.body_size,\n                                  t, jr.id);\n             j->next = j->prev = j;\n-            j->r.created_at = jr.created_at;\n         }\n         j->r.id = jr.id;\n         j->r.pri = jr.pri;\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -509,13 +509,11 @@ bury_job(Server *s, Job *j, char update_store)\n void\n enqueue_reserved_jobs(Conn *c)\n {\n-    int r;\n-    Job *j;\n-\n     while (job_list_any_p(&c->reserved_jobs)) {\n-        j = job_remove(c->reserved_jobs.next);\n-        r = enqueue_job(c->srv, j, 0, 0);\n-        if (r < 1) bury_job(c->srv, j, 0);\n+        Job *j = job_remove(c->reserved_jobs.next);\n+        int r = enqueue_job(c->srv, j, 0, 0);\n+        if (r < 1)\n+            bury_job(c->srv, j, 0);\n         global_stat.reserved_ct--;\n         j->tube->stat.reserved_ct--;\n         c->soonest_job = NULL;\n@@ -557,12 +555,11 @@ kick_buried_job(Server *s, Job *j)\n static uint\n get_delayed_job_ct()\n {\n-    Tube *t;\n     size_t i;\n     uint count = 0;\n \n     for (i = 0; i < tubes.len; i++) {\n-        t = tubes.items[i];\n+        Tube *t = tubes.items[i];\n         count += t->delay.len;\n     }\n     return count;\n@@ -880,17 +877,17 @@ static int\n fmt_stats(char *buf, size_t size, void *x)\n {\n     int whead = 0, wcur = 0;\n-    Server *srv;\n+    Server *s = x;\n     struct rusage ru;\n \n-    srv = x;\n+    s = x;\n \n-    if (srv->wal.head) {\n-        whead = srv->wal.head->seq;\n+    if (s->wal.head) {\n+        whead = s->wal.head->seq;\n     }\n \n-    if (srv->wal.cur) {\n-        wcur = srv->wal.cur->seq;\n+    if (s->wal.cur) {\n+        wcur = s->wal.cur->seq;\n     }\n \n     getrusage(RUSAGE_SELF, &ru); /* don't care if it fails */\n@@ -938,9 +935,9 @@ fmt_stats(char *buf, size_t size, void *x)\n             uptime(),\n             whead,\n             wcur,\n-            srv->wal.nmig,\n-            srv->wal.nrec,\n-            srv->wal.filesize,\n+            s->wal.nmig,\n+            s->wal.nrec,\n+            s->wal.filesize,\n             drain_mode ? \"true\" : \"false\",\n             instance_hex,\n             node_info.nodename);\n@@ -1771,7 +1768,7 @@ dispatch_cmd(Conn *c)\n static void\n conn_timeout(Conn *c)\n {\n-    int r, should_timeout = 0;\n+    int should_timeout = 0;\n     Job *j;\n \n     /* Check if the client was trying to reserve a job. */\n@@ -1781,7 +1778,8 @@ conn_timeout(Conn *c)\n     /* Check if any reserved jobs have run out of time. We should do this\n      * whether or not the client is waiting for a new reservation. */\n     while ((j = connsoonestjob(c))) {\n-        if (j->r.deadline_at >= nanoseconds()) break;\n+        if (j->r.deadline_at >= nanoseconds())\n+            break;\n \n         /* This job is in the middle of being written out. If we return it to\n          * the ready queue, someone might free it before we finish writing it\n@@ -1793,7 +1791,7 @@ conn_timeout(Conn *c)\n \n         timeout_ct++; /* stats */\n         j->r.timeout_ct++;\n-        r = enqueue_job(c->srv, remove_this_reserved_job(c, j), 0, 0);\n+        int r = enqueue_job(c->srv, remove_this_reserved_job(c, j), 0, 0);\n         if (r < 1)\n             bury_job(c->srv, j, 0); /* out of memory, so bury it */\n         connsched(c);\n@@ -1808,9 +1806,9 @@ conn_timeout(Conn *c)\n }\n \n void\n-enter_drain_mode(int signum)\n+enter_drain_mode(int sig)\n {\n-    UNUSED_PARAMETER(signum);\n+    UNUSED_PARAMETER(sig);\n     drain_mode = 1;\n }\n \n@@ -1988,14 +1986,13 @@ conn_data(Conn *c)\n static void\n update_conns()\n {\n-    int r;\n     Conn *c;\n \n     while (dirty) {\n         c = dirty;\n         dirty = dirty->next;\n         c->next = NULL;\n-        r = sockwant(&c->sock, c->rw);\n+        int r = sockwant(&c->sock, c->rw);\n         if (r == -1) {\n             twarn(\"sockwant\");\n             connclose(c);\n@@ -2202,22 +2199,23 @@ int\n prot_replay(Server *s, Job *list)\n {\n     Job *j, *nj;\n-    int64 t, delay;\n-    int r, z;\n+    int64 t;\n+    int r;\n \n     for (j = list->next ; j != list ; j = nj) {\n         nj = j->next;\n         job_remove(j);\n-        z = walresvupdate(&s->wal);\n+        int z = walresvupdate(&s->wal);\n         if (!z) {\n             twarnx(\"failed to reserve space\");\n             return 0;\n         }\n-        delay = 0;\n+        int64 delay = 0;\n         switch (j->r.state) {\n-        case Buried:\n+        case Buried: {\n             bury_job(s, j, 0);\n             break;\n+        }\n         case Delayed:\n             t = nanoseconds();\n             if (t < j->r.deadline_at) {\n@@ -2226,7 +2224,8 @@ prot_replay(Server *s, Job *list)\n             /* Falls through */\n         default:\n             r = enqueue_job(s, j, delay, 0);\n-            if (r < 1) twarnx(\"error recovering job %\"PRIu64, j->r.id);\n+            if (r < 1)\n+                twarnx(\"error recovering job %\"PRIu64, j->r.id);\n         }\n     }\n     return 1;\n\ndiff --git a/serv.c b/serv.c\n--- a/serv.c\n+++ b/serv.c\n@@ -16,7 +16,6 @@ srvserve(Server *s)\n {\n     int r;\n     Socket *sock;\n-    int64 period;\n \n     if (sockinit() == -1) {\n         twarnx(\"sockinit\");\n@@ -42,7 +41,7 @@ srvserve(Server *s)\n \n \n     for (;;) {\n-        period = prottick(s);\n+        int64 period = prottick(s);\n \n         int rw = socknext(&sock, period);\n         if (rw == -1) {\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -19,7 +19,7 @@\n #include <sys/wait.h>\n #include <errno.h>\n \n-static int srvpid, port, fd, size;\n+static int srvpid, size;\n \n // Global timeout set for reading response in tests; 5sec.\n static int64 timeout = 5000000000LL;\n@@ -325,17 +325,17 @@ exist(char *path)\n void\n cttest_unknown_command()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"nont10knowncommand\\r\\n\");\n     ckresp(fd, \"UNKNOWN_COMMAND\\r\\n\");\n }\n \n void\n cttest_too_long_commandline()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     int i;\n     for (i = 0; i < 5; i++)\n         mustsend(fd, \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\");\n@@ -347,8 +347,8 @@ void\n cttest_put_in_drain()\n {\n     enter_drain_mode(SIGUSR1);\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 1 1\\r\\n\");\n     mustsend(fd, \"x\\r\\n\");\n     ckresp(fd, \"DRAINING\\r\\n\");\n@@ -357,8 +357,8 @@ cttest_put_in_drain()\n void\n cttest_peek_ok()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 1 1\\r\\n\");\n     mustsend(fd, \"a\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -371,8 +371,8 @@ cttest_peek_ok()\n void\n cttest_peek_not_found()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 1 1\\r\\n\");\n     mustsend(fd, \"a\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -386,8 +386,8 @@ cttest_peek_not_found()\n void\n cttest_peek_bad_format()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"peek 18446744073709551616\\r\\n\"); // UINT64_MAX+1\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n     mustsend(fd, \"peek 184467440737095516160000000000000000000000000000\\r\\n\");\n@@ -401,8 +401,8 @@ cttest_peek_bad_format()\n void\n cttest_peek_delayed()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"peek-delayed\\r\\n\");\n     ckresp(fd, \"NOT_FOUND\\r\\n\");\n \n@@ -437,8 +437,8 @@ cttest_peek_delayed()\n void\n cttest_peek_buried_kick()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 1 1\\r\\n\");\n     mustsend(fd, \"A\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -477,8 +477,8 @@ cttest_peek_buried_kick()\n void\n cttest_touch_bad_format()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"touch a111\\r\\n\");\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n     mustsend(fd, \"touch 111a\\r\\n\");\n@@ -490,8 +490,8 @@ cttest_touch_bad_format()\n void\n cttest_touch_not_found()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"touch 1\\r\\n\");\n     ckresp(fd, \"NOT_FOUND\\r\\n\");\n     mustsend(fd, \"touch 100000000000000\\r\\n\");\n@@ -501,8 +501,8 @@ cttest_touch_not_found()\n void\n cttest_bury_bad_format()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"bury 111abc 2\\r\\n\");\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n     mustsend(fd, \"bury 111\\r\\n\");\n@@ -514,8 +514,8 @@ cttest_bury_bad_format()\n void\n cttest_kickjob_bad_format()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"kick-job a111\\r\\n\");\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n     mustsend(fd, \"kick-job 111a\\r\\n\");\n@@ -527,8 +527,8 @@ cttest_kickjob_bad_format()\n void\n cttest_kickjob_buried()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 1 1\\r\\n\");\n     mustsend(fd, \"A\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -550,8 +550,8 @@ cttest_kickjob_buried()\n void\n cttest_kickjob_delayed()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     // jid=1 - no delay, jid=2 - delay\n     mustsend(fd, \"put 0 0 1 1\\r\\n\");\n     mustsend(fd, \"A\\r\\n\");\n@@ -573,8 +573,8 @@ cttest_pause()\n {\n     int64 s;\n \n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 0 1\\r\\n\");\n     mustsend(fd, \"x\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -590,17 +590,17 @@ cttest_pause()\n void\n cttest_underscore()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"use x_y\\r\\n\");\n     ckresp(fd, \"USING x_y\\r\\n\");\n }\n \n void\n cttest_2cmdpacket()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"use a\\r\\nuse b\\r\\n\");\n     ckresp(fd, \"USING a\\r\\n\");\n     ckresp(fd, \"USING b\\r\\n\");\n@@ -610,8 +610,8 @@ void\n cttest_too_big()\n {\n     job_data_size_limit = 10;\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 0 11\\r\\n\");\n     mustsend(fd, \"delete 9999\\r\\n\");\n     mustsend(fd, \"put 0 0 0 1\\r\\n\");\n@@ -624,8 +624,8 @@ void\n cttest_job_size_invalid()\n {\n     job_data_size_limit = JOB_DATA_SIZE_LIMIT_MAX;\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 0 4294967296\\r\\n\");\n     mustsend(fd, \"put 0 0 0 10b\\r\\n\");\n     mustsend(fd, \"put 0 0 0 --!@#$%^&&**()0b\\r\\n\");\n@@ -642,8 +642,8 @@ cttest_job_size_max_plus_1()\n {\n     /* verify that server reject the job larger than maximum allowed. */\n     job_data_size_limit = JOB_DATA_SIZE_LIMIT_MAX;\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 0 1073741825\\r\\n\");\n \n     const int len = 1024*1024;\n@@ -663,8 +663,8 @@ cttest_job_size_max_plus_1()\n void\n cttest_delete_ready()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 0 0\\r\\n\");\n     mustsend(fd, \"\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -675,8 +675,8 @@ cttest_delete_ready()\n void\n cttest_delete_reserved_by_other()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 1 1\\r\\n\");\n     mustsend(fd, \"a\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -693,8 +693,8 @@ cttest_delete_reserved_by_other()\n void\n cttest_delete_bad_format()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"delete 18446744073709551616\\r\\n\"); // UINT64_MAX+1\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n     mustsend(fd, \"delete 184467440737095516160000000000000000000000000000\\r\\n\");\n@@ -708,8 +708,8 @@ cttest_delete_bad_format()\n void\n cttest_multi_tube()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"use abc\\r\\n\");\n     ckresp(fd, \"USING abc\\r\\n\");\n     mustsend(fd, \"put 999999 0 0 0\\r\\n\");\n@@ -731,8 +731,8 @@ cttest_multi_tube()\n void\n cttest_negative_delay()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 512 -1 100 0\\r\\n\");\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n }\n@@ -742,8 +742,8 @@ cttest_negative_delay()\n void\n cttest_garbage_priority()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put -1kkdj9djjkd9 0 100 1\\r\\n\");\n     mustsend(fd, \"a\\r\\n\");\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n@@ -752,8 +752,8 @@ cttest_garbage_priority()\n void\n cttest_negative_priority()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put -1 0 100 1\\r\\n\");\n     mustsend(fd, \"a\\r\\n\");\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n@@ -762,8 +762,8 @@ cttest_negative_priority()\n void\n cttest_max_priority()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 4294967295 0 100 1\\r\\n\");\n     mustsend(fd, \"a\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -772,8 +772,8 @@ cttest_max_priority()\n void\n cttest_too_big_priority()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 4294967296 0 100 1\\r\\n\");\n     mustsend(fd, \"a\\r\\n\");\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n@@ -782,8 +782,8 @@ cttest_too_big_priority()\n void\n cttest_omit_time_left()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 5 1\\r\\n\");\n     mustsend(fd, \"a\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -795,8 +795,8 @@ cttest_omit_time_left()\n void\n cttest_small_delay()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 1 1 0\\r\\n\");\n     mustsend(fd, \"\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -805,8 +805,8 @@ cttest_small_delay()\n void\n cttest_statsjob_ck_format()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"stats-job 111ABC\\r\\n\");\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n     mustsend(fd, \"stats-job 111 222\\r\\n\");\n@@ -818,8 +818,8 @@ cttest_statsjob_ck_format()\n void\n cttest_stats_tube()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"use tubea\\r\\n\");\n     ckresp(fd, \"USING tubea\\r\\n\");\n     mustsend(fd, \"put 0 0 0 1\\r\\n\");\n@@ -918,8 +918,8 @@ cttest_stats_tube()\n void\n cttest_ttrlarge()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 120 1\\r\\n\");\n     mustsend(fd, \"a\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -967,8 +967,8 @@ cttest_ttrlarge()\n void\n cttest_ttr_small()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 0 1\\r\\n\");\n     mustsend(fd, \"a\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -980,8 +980,8 @@ cttest_ttr_small()\n void\n cttest_zero_delay()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 1 0\\r\\n\");\n     mustsend(fd, \"\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -994,7 +994,7 @@ cttest_reserve_with_timeout_2conns()\n \n     job_data_size_limit = 10;\n \n-    port = SERVER();\n+    int port = SERVER();\n     fd0 = mustdiallocal(port);\n     fd1 = mustdiallocal(port);\n     mustsend(fd0, \"watch foo\\r\\n\");\n@@ -1009,7 +1009,7 @@ cttest_reserve_with_timeout_2conns()\n void\n cttest_reserve_ttr_deadline_soon()\n {\n-    port = SERVER();\n+    int port = SERVER();\n     int prod = mustdiallocal(port);\n \n     mustsend(prod, \"put 0 0 1 1\\r\\n\");\n@@ -1045,8 +1045,8 @@ cttest_reserve_ttr_deadline_soon()\n void\n cttest_release_bad_format()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n \n     // bad id\n     mustsend(fd, \"release 18446744073709551616 1 1\\r\\n\"); // UINT64_MAX+1\n@@ -1070,16 +1070,16 @@ cttest_release_bad_format()\n void\n cttest_release_not_found()\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"release 1 1 1\\r\\n\");\n     ckresp(fd, \"NOT_FOUND\\r\\n\");\n }\n \n void\n cttest_close_releases_job()\n {\n-    port = SERVER();\n+    int port = SERVER();\n     int cons = mustdiallocal(port);\n     int prod = mustdiallocal(port);\n     mustsend(cons, \"reserve-with-timeout 1\\r\\n\");\n@@ -1110,7 +1110,7 @@ cttest_unpause_tube()\n {\n     int fd0, fd1;\n \n-    port = SERVER();\n+    int port = SERVER();\n     fd0 = mustdiallocal(port);\n     fd1 = mustdiallocal(port);\n \n@@ -1135,7 +1135,7 @@ cttest_unpause_tube()\n void\n cttest_list_tube()\n {\n-    port = SERVER();\n+    int port = SERVER();\n     int fd0 = mustdiallocal(port);\n \n     mustsend(fd0, \"watch w\\r\\n\");\n@@ -1182,11 +1182,11 @@ cttest_binlog_empty_exit()\n     srv.wal.use = 1;\n     job_data_size_limit = 10;\n \n-    port = SERVER();\n+    int port = SERVER();\n     kill_srvpid();\n \n     port = SERVER();\n-    fd = mustdiallocal(port);\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 0 0\\r\\n\");\n     mustsend(fd, \"\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -1199,8 +1199,8 @@ cttest_binlog_bury()\n     srv.wal.use = 1;\n     job_data_size_limit = 10;\n \n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 100 0\\r\\n\");\n     mustsend(fd, \"\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -1218,8 +1218,8 @@ cttest_binlog_basic()\n     srv.wal.use = 1;\n     job_data_size_limit = 10;\n \n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 100 0\\r\\n\");\n     mustsend(fd, \"\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -1245,8 +1245,8 @@ cttest_binlog_size_limit()\n     srv.wal.syncrate = 0;\n     srv.wal.wantsync = 1;\n \n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     char *b2 = fmtalloc(\"%s/binlog.2\", ctdir());\n     while (!exist(b2)) {\n         char *exp = fmtalloc(\"INSERTED %d\\r\\n\", ++i);\n@@ -1277,8 +1277,8 @@ cttest_binlog_allocation()\n     srv.wal.syncrate = 0;\n     srv.wal.wantsync = 1;\n \n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     for (i = 1; i <= 96; i++) {\n         char *exp = fmtalloc(\"INSERTED %d\\r\\n\", i);\n         mustsend(fd, \"put 0 0 120 22\\r\\n\");\n@@ -1302,8 +1302,8 @@ cttest_binlog_read()\n     srv.wal.syncrate = 0;\n     srv.wal.wantsync = 1;\n \n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"use test\\r\\n\");\n     ckresp(fd, \"USING test\\r\\n\");\n     mustsend(fd, \"put 0 0 120 4\\r\\n\");\n@@ -1354,8 +1354,8 @@ cttest_binlog_disk_full()\n     srv.wal.syncrate = 0;\n     srv.wal.wantsync = 1;\n \n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 100 50\\r\\n\");\n     mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -1418,8 +1418,8 @@ cttest_binlog_disk_full_delete()\n     srv.wal.syncrate = 0;\n     srv.wal.wantsync = 1;\n \n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"put 0 0 100 50\\r\\n\");\n     mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n     ckresp(fd, \"INSERTED 1\\r\\n\");\n@@ -1483,10 +1483,10 @@ cttest_binlog_v5()\n     }\n \n     progname = __func__;\n-    port = (rand() & 0xfbff) + 1024;\n+    int port = (rand() & 0xfbff) + 1024;\n     sprintf(portstr, \"%d\", port);\n     muststart(\"beanstalkd-1.4.6\", \"-b\", ctdir(), \"-p\", portstr);\n-    fd = mustdiallocal(port);\n+    int fd = mustdiallocal(port);\n     mustsend(fd, \"use test\\r\\n\");\n     ckresp(fd, \"USING test\\r\\n\");\n     mustsend(fd, \"put 1 2 3 4\\r\\n\");\n@@ -1647,8 +1647,8 @@ cttest_binlog_v5()\n static void\n bench_put_delete_size(int n, int size)\n {\n-    port = SERVER();\n-    fd = mustdiallocal(port);\n+    int port = SERVER();\n+    int fd = mustdiallocal(port);\n     char buf[50], put[50];\n     char body[size+1];\n     memset(body, 'a', size);\n\ndiff --git a/util.c b/util.c\n--- a/util.c\n+++ b/util.c\n@@ -150,10 +150,11 @@ void\n optparse(Server *s, char **argv)\n {\n     int64 ms;\n-    char *arg, c, *tmp;\n+    char *arg, *tmp;\n #   define EARGF(x) (*arg ? (tmp=arg,arg=\"\",tmp) : *argv ? *argv++ : (x))\n \n     while ((arg = *argv++) && *arg++ == '-' && *arg) {\n+        char c;\n         while ((c = *arg++)) {\n             switch (c) {\n                 case 'p':\n\ndiff --git a/walg.c b/walg.c\n--- a/walg.c\n+++ b/walg.c\n@@ -307,14 +307,12 @@ balancerest(Wal *w, File *b, int n)\n static int\n balance(Wal *w, int n)\n {\n-    int r;\n-\n     // Invariant 1\n     // (this loop will run at most once)\n     while (w->cur->resv < n) {\n         int m = w->cur->resv;\n \n-        r = needfree(w, m);\n+        int r = needfree(w, m);\n         if (r != m) {\n             twarnx(\"needfree\");\n             return 0;\n@@ -412,7 +410,7 @@ waldirlock(Wal *w)\n         twarn(\"malloc\");\n         return 0;\n     }\n-    r = snprintf(path, path_length, \"%s/lock\", w->dir);\n+    snprintf(path, path_length, \"%s/lock\", w->dir);\n \n     fd = open(path, O_WRONLY|O_CREAT, 0600);\n     free(path);\n@@ -440,12 +438,11 @@ waldirlock(Wal *w)\n void\n walread(Wal *w, Job *list, int min)\n {\n-    File *f;\n-    int i, fd;\n+    int i;\n     int err = 0;\n \n     for (i = min; i < w->next; i++) {\n-        f = new(File);\n+        File *f = new(File);\n         if (!f) {\n             twarnx(\"OOM\");\n             exit(1);\n@@ -457,7 +454,7 @@ walread(Wal *w, Job *list, int min)\n             exit(1);\n         }\n \n-        fd = open(f->path, O_RDONLY);\n+        int fd = open(f->path, O_RDONLY);\n         if (fd < 0) {\n             twarn(\"open %s\", f->path);\n             free(f->path);\n", "test_patch": "", "problem_statement": "fix style of the code\n* remove global vars where possible\r\n* reduce scope of variables\r\n* remove shadowing of variables\r\n* remove redundant assigments\r\n* fix prototypes according to the definion of functions\r\n\r\nUpdates #442", "version": "1.11", "language": "C", "created_at": "2019-08-04T13:47:48Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-481", "repo": "beanstalkd/beanstalkd", "pull_number": 481, "base_commit": "3bb4521e85a0a26f90193df97bdd9943ae1c6599", "patch": "diff --git a/testjobs.c b/testjobs.c\n--- a/testjobs.c\n+++ b/testjobs.c\n@@ -132,6 +132,7 @@ ctbench_make_job(int n)\n {\n     int i;\n     TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n+    ctresettimer();\n     for (i = 0; i < n; i++) {\n         make_job(0, 0, 1, 0, default_tube);\n     }\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -13,6 +13,7 @@\n #include <netdb.h>\n #include <netinet/in.h>\n #include <netinet/ip.h>\n+#include <netinet/tcp.h>\n #include <arpa/inet.h>\n #include <fcntl.h>\n #include <sys/wait.h>\n@@ -77,12 +78,19 @@ mustdiallocal(int port)\n         exit(1);\n     }\n \n-    int fd = socket(PF_INET, SOCK_STREAM, 0);\n+    int fd = socket(AF_INET, SOCK_STREAM, 0);\n     if (fd == -1) {\n         twarn(\"socket\");\n         exit(1);\n     }\n \n+    // Fix of the benchmarking issue on Linux. See issue #430.\n+    int flags = 1;\n+    if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flags, sizeof(int))) {\n+        twarn(\"setting TCP_NODELAY on fd %d\", fd);\n+        exit(1);\n+    }\n+\n     r = connect(fd, (struct sockaddr *)&addr, sizeof addr);\n     if (r == -1) {\n         twarn(\"connect\");\n@@ -233,6 +241,8 @@ readline(int fd)\n             exit(3);\n         }\n \n+        // TODO: try reading into a buffer to improve performance.\n+        // See related issue #430.\n         r = read(fd, &c, 1);\n         if (r == -1) {\n             perror(\"write\");\n@@ -1461,6 +1471,7 @@ bench_put_delete_size(int n, int size)\n     body[size] = 0;\n     ctsetbytes(size);\n     sprintf(put, \"put 0 0 0 %d\\r\\n\", size);\n+    ctresettimer();\n     int i;\n     for (i = 0; i < n; i++) {\n         mustsend(fd, put);\n@@ -1471,6 +1482,7 @@ bench_put_delete_size(int n, int size)\n         mustsend(fd, buf);\n         ckresp(fd, \"DELETED\\r\\n\");\n     }\n+    ctstoptimer();\n }\n \n void\n", "test_patch": "", "problem_statement": "fix benchmarks in testsrv.c\nThe slowness in benchmarks on Linux was due to long wait time\r\nin the select syscall. Setting socket's TCP_NODELAY helped.\r\n\r\nAlso see\r\nhttps://stackoverflow.com/questions/39270419/select-on-socket-slow-in-linux\r\n\r\nI added proper resettimers inside of benchmarks to skip the overhead.\r\nThis helped to improve the time spent in all of testsrv tests too.\r\n\r\nBechmarking is not ideal yet. It might be capped by the client's limitations.\r\n\r\nFixes #430", "version": "1.11", "language": "C", "created_at": "2019-07-20T08:45:28Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-523", "repo": "beanstalkd/beanstalkd", "pull_number": 523, "base_commit": "057398f40254295a825c640d40c1e935d6785843", "patch": "diff --git a/ms.c b/ms.c\n--- a/ms.c\n+++ b/ms.c\n@@ -12,7 +12,7 @@ ms_init(Ms *a, ms_event_fn oninsert, ms_event_fn onremove)\n     a->onremove = onremove;\n }\n \n-static void\n+static int\n grow(Ms *a)\n {\n     void **nitems;\n@@ -22,20 +22,19 @@ grow(Ms *a)\n \n     nitems = malloc(ncap * sizeof(void *));\n     if (!nitems)\n-        return;\n+        return 0;\n \n     memcpy(nitems, a->items, a->len * sizeof(void *));\n     free(a->items);\n     a->items = nitems;\n     a->cap = ncap;\n+    return 1;\n }\n \n int\n ms_append(Ms *a, void *item)\n {\n-    if (a->len >= a->cap)\n-        grow(a);\n-    if (a->len >= a->cap)\n+    if (a->len >= a->cap && !grow(a))\n         return 0;\n \n     a->items[a->len++] = item;\n", "test_patch": "", "problem_statement": "ms.c: simplify the code checking OOM in the grow function\nUpdates #442", "version": "1.11", "language": "C", "created_at": "2019-08-04T14:06:46Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-557", "repo": "beanstalkd/beanstalkd", "pull_number": 557, "base_commit": "cc5b507ac055c9ca0c2482584fb9441ebd729d0b", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -78,13 +78,13 @@ extern FAlloc *falloc;\n \n // stats structure holds counters for operations, both globally and per tube.\n struct stats {\n-    uint urgent_ct;\n-    uint waiting_ct;\n-    uint buried_ct;\n-    uint reserved_ct;\n-    uint pause_ct;\n-    uint64   total_delete_ct;\n-    uint64   total_jobs_ct;\n+    uint64 urgent_ct;\n+    uint64 waiting_ct;\n+    uint64 buried_ct;\n+    uint64 reserved_ct;\n+    uint64 pause_ct;\n+    uint64 total_delete_ct;\n+    uint64 total_jobs_ct;\n };\n \n \n\ndiff --git a/doc/protocol.txt b/doc/protocol.txt\n--- a/doc/protocol.txt\n+++ b/doc/protocol.txt\n@@ -657,7 +657,11 @@ they are not stored on disk with the -b flag.\n  - \"id\" is a random id string for this server process, generated every time\n    beanstalkd process starts.\n \n- - \"hostname\" the hostname of the machine as determined by uname.\n+ - \"hostname\" is the hostname of the machine as determined by uname.\n+\n+ - \"os\" is the OS version as determined by uname\n+\n+ - \"platform\" is the machine architecture as determined by uname\n \n The list-tubes command returns a list of all existing tubes. Its form is:\n \n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -132,11 +132,11 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define TOTAL_OPS 25\n \n #define STATS_FMT \"---\\n\" \\\n-    \"current-jobs-urgent: %u\\n\" \\\n-    \"current-jobs-ready: %u\\n\" \\\n-    \"current-jobs-reserved: %u\\n\" \\\n+    \"current-jobs-urgent: %\" PRIu64 \"\\n\" \\\n+    \"current-jobs-ready: %\" PRIu64 \"\\n\" \\\n+    \"current-jobs-reserved: %\" PRIu64 \"\\n\" \\\n     \"current-jobs-delayed: %u\\n\" \\\n-    \"current-jobs-buried: %u\\n\" \\\n+    \"current-jobs-buried: %\" PRIu64 \"\\n\" \\\n     \"cmd-put: %\" PRIu64 \"\\n\" \\\n     \"cmd-peek: %\" PRIu64 \"\\n\" \\\n     \"cmd-peek-ready: %\" PRIu64 \"\\n\" \\\n@@ -166,7 +166,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n     \"current-connections: %u\\n\" \\\n     \"current-producers: %u\\n\" \\\n     \"current-workers: %u\\n\" \\\n-    \"current-waiting: %u\\n\" \\\n+    \"current-waiting: %\" PRIu64 \"\\n\" \\\n     \"total-connections: %u\\n\" \\\n     \"pid: %ld\\n\" \\\n     \"version: \\\"%s\\\"\\n\" \\\n@@ -181,21 +181,23 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n     \"draining: %s\\n\" \\\n     \"id: %s\\n\" \\\n     \"hostname: %s\\n\" \\\n+    \"os: %s\\n\" \\\n+    \"platform: %s\\n\" \\\n     \"\\r\\n\"\n \n #define STATS_TUBE_FMT \"---\\n\" \\\n     \"name: %s\\n\" \\\n-    \"current-jobs-urgent: %u\\n\" \\\n+    \"current-jobs-urgent: %\" PRIu64 \"\\n\" \\\n     \"current-jobs-ready: %zu\\n\" \\\n-    \"current-jobs-reserved: %u\\n\" \\\n+    \"current-jobs-reserved: %\" PRIu64 \"\\n\" \\\n     \"current-jobs-delayed: %zu\\n\" \\\n-    \"current-jobs-buried: %u\\n\" \\\n+    \"current-jobs-buried: %\" PRIu64 \"\\n\" \\\n     \"total-jobs: %\" PRIu64 \"\\n\" \\\n     \"current-using: %u\\n\" \\\n     \"current-watching: %u\\n\" \\\n-    \"current-waiting: %u\\n\" \\\n+    \"current-waiting: %\" PRIu64 \"\\n\" \\\n     \"cmd-delete: %\" PRIu64 \"\\n\" \\\n-    \"cmd-pause-tube: %u\\n\" \\\n+    \"cmd-pause-tube: %\" PRIu64 \"\\n\" \\\n     \"pause: %\" PRIu64 \"\\n\" \\\n     \"pause-time-left: %\" PRId64 \"\\n\" \\\n     \"\\r\\n\"\n@@ -217,13 +219,13 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n     \"kicks: %u\\n\" \\\n     \"\\r\\n\"\n \n-/* this number is pretty arbitrary */\n+// The size of the throw-away (BITBUCKET) buffer. Arbitrary.\n #define BUCKET_BUF_SIZE 1024\n \n-static char bucket[BUCKET_BUF_SIZE];\n-\n-static uint ready_ct = 0;\n-static struct stats global_stat = {0, 0, 0, 0, 0, 0, 0};\n+static uint64 ready_ct = 0;\n+static uint64 timeout_ct = 0;\n+static uint64 op_ct[TOTAL_OPS] = {0};\n+static struct stats global_stat = {0};\n \n static Tube *default_tube;\n \n@@ -237,7 +239,6 @@ enum { instance_id_bytes = 8 };\n static char instance_hex[instance_id_bytes * 2 + 1]; // hex-encoded len of instance_id_bytes\n \n static struct utsname node_info;\n-static uint64 op_ct[TOTAL_OPS], timeout_ct = 0;\n \n // Single linked list with connections that require updates\n // in the event notification mechanism.\n@@ -273,12 +274,6 @@ static const char * op_names[] = {\n \n static Job *remove_buried_job(Job *j);\n \n-static int\n-buried_job_p(Tube *t)\n-{\n-    return !job_list_is_empty(&t->buried);\n-}\n-\n // epollq_add schedules connection c in the s->conns heap, adds c\n // to the epollq list to change expected operation in event notifications.\n // rw='w' means to notify when socket is writeable, 'r' - readable, 'h' - closed.\n@@ -544,7 +539,8 @@ bury_job(Server *s, Job *j, char update_store)\n {\n     if (update_store) {\n         int z = walresvupdate(&s->wal);\n-        if (!z) return 0;\n+        if (!z)\n+            return 0;\n         j->walresv += z;\n     }\n \n@@ -586,14 +582,16 @@ kick_buried_job(Server *s, Job *j)\n     int z;\n \n     z = walresvupdate(&s->wal);\n-    if (!z) return 0;\n+    if (!z)\n+        return 0;\n     j->walresv += z;\n \n     remove_buried_job(j);\n \n     j->r.kick_ct++;\n     r = enqueue_job(s, j, 0, 1);\n-    if (r == 1) return 1;\n+    if (r == 1)\n+        return 1;\n \n     /* ready queue is full, so bury it */\n     bury_job(s, j, 0);\n@@ -620,24 +618,34 @@ kick_delayed_job(Server *s, Job *j)\n     int z;\n \n     z = walresvupdate(&s->wal);\n-    if (!z) return 0;\n+    if (!z)\n+        return 0;\n     j->walresv += z;\n \n     heapremove(&j->tube->delay, j->heap_index);\n \n     j->r.kick_ct++;\n     r = enqueue_job(s, j, 0, 1);\n-    if (r == 1) return 1;\n+    if (r == 1)\n+        return 1;\n \n     /* ready queue is full, so delay it again */\n     r = enqueue_job(s, j, j->r.delay, 0);\n-    if (r == 1) return 0;\n+    if (r == 1)\n+        return 0;\n \n     /* last resort */\n     bury_job(s, j, 0);\n     return 0;\n }\n \n+static int\n+buried_job_p(Tube *t)\n+{\n+    // this function does not do much. inline?\n+    return !job_list_is_empty(&t->buried);\n+}\n+\n /* return the number of jobs successfully kicked */\n static uint\n kick_buried_jobs(Server *s, Tube *t, uint n)\n@@ -663,14 +671,16 @@ kick_delayed_jobs(Server *s, Tube *t, uint n)\n static uint\n kick_jobs(Server *s, Tube *t, uint n)\n {\n-    if (buried_job_p(t)) return kick_buried_jobs(s, t, n);\n+    if (buried_job_p(t))\n+        return kick_buried_jobs(s, t, n);\n     return kick_delayed_jobs(s, t, n);\n }\n \n static Job *\n remove_buried_job(Job *j)\n {\n-    if (!j || j->r.state != Buried) return NULL;\n+    if (!j || j->r.state != Buried)\n+        return NULL;\n     j = job_list_remove(j);\n     if (j) {\n         global_stat.buried_ct--;\n@@ -682,7 +692,8 @@ remove_buried_job(Job *j)\n static Job *\n remove_delayed_job(Job *j)\n {\n-    if (!j || j->r.state != Delayed) return NULL;\n+    if (!j || j->r.state != Delayed)\n+        return NULL;\n     heapremove(&j->tube->delay, j->heap_index);\n \n     return j;\n@@ -691,7 +702,8 @@ remove_delayed_job(Job *j)\n static Job *\n remove_ready_job(Job *j)\n {\n-    if (!j || j->r.state != Ready) return NULL;\n+    if (!j || j->r.state != Ready)\n+        return NULL;\n     heapremove(&j->tube->ready, j->heap_index);\n     ready_ct--;\n     if (j->r.pri < URGENT_THRESHOLD) {\n@@ -721,9 +733,12 @@ touch_job(Conn *c, Job *j)\n static void\n check_err(Conn *c, const char *s)\n {\n-    if (errno == EAGAIN) return;\n-    if (errno == EINTR) return;\n-    if (errno == EWOULDBLOCK) return;\n+    if (errno == EAGAIN)\n+        return;\n+    if (errno == EINTR)\n+        return;\n+    if (errno == EWOULDBLOCK)\n+        return;\n \n     twarn(\"%s\", s);\n     c->state = STATE_CLOSE;\n@@ -785,8 +800,10 @@ which_cmd(Conn *c)\n static void\n fill_extra_data(Conn *c)\n {\n-    if (!c->sock.fd) return; /* the connection was closed */\n-    if (!c->cmd_len) return; /* we don't have a complete command */\n+    if (!c->sock.fd)\n+        return; /* the connection was closed */\n+    if (!c->cmd_len)\n+        return; /* we don't have a complete command */\n \n     /* how many extra bytes did we read? */\n     int64 extra_bytes = c->cmd_read - c->cmd_len;\n@@ -915,55 +932,57 @@ fmt_stats(char *buf, size_t size, void *x)\n \n     getrusage(RUSAGE_SELF, &ru); /* don't care if it fails */\n     return snprintf(buf, size, STATS_FMT,\n-            global_stat.urgent_ct,\n-            ready_ct,\n-            global_stat.reserved_ct,\n-            get_delayed_job_ct(),\n-            global_stat.buried_ct,\n-            op_ct[OP_PUT],\n-            op_ct[OP_PEEKJOB],\n-            op_ct[OP_PEEK_READY],\n-            op_ct[OP_PEEK_DELAYED],\n-            op_ct[OP_PEEK_BURIED],\n-            op_ct[OP_RESERVE],\n-            op_ct[OP_RESERVE_TIMEOUT],\n-            op_ct[OP_DELETE],\n-            op_ct[OP_RELEASE],\n-            op_ct[OP_USE],\n-            op_ct[OP_WATCH],\n-            op_ct[OP_IGNORE],\n-            op_ct[OP_BURY],\n-            op_ct[OP_KICK],\n-            op_ct[OP_TOUCH],\n-            op_ct[OP_STATS],\n-            op_ct[OP_STATSJOB],\n-            op_ct[OP_STATS_TUBE],\n-            op_ct[OP_LIST_TUBES],\n-            op_ct[OP_LIST_TUBE_USED],\n-            op_ct[OP_LIST_TUBES_WATCHED],\n-            op_ct[OP_PAUSE_TUBE],\n-            timeout_ct,\n-            global_stat.total_jobs_ct,\n-            job_data_size_limit,\n-            tubes.len,\n-            count_cur_conns(),\n-            count_cur_producers(),\n-            count_cur_workers(),\n-            global_stat.waiting_ct,\n-            count_tot_conns(),\n-            (long) getpid(),\n-            version,\n-            (int) ru.ru_utime.tv_sec, (int) ru.ru_utime.tv_usec,\n-            (int) ru.ru_stime.tv_sec, (int) ru.ru_stime.tv_usec,\n-            uptime(),\n-            whead,\n-            wcur,\n-            s->wal.nmig,\n-            s->wal.nrec,\n-            s->wal.filesize,\n-            drain_mode ? \"true\" : \"false\",\n-            instance_hex,\n-            node_info.nodename);\n+                    global_stat.urgent_ct,\n+                    ready_ct,\n+                    global_stat.reserved_ct,\n+                    get_delayed_job_ct(),\n+                    global_stat.buried_ct,\n+                    op_ct[OP_PUT],\n+                    op_ct[OP_PEEKJOB],\n+                    op_ct[OP_PEEK_READY],\n+                    op_ct[OP_PEEK_DELAYED],\n+                    op_ct[OP_PEEK_BURIED],\n+                    op_ct[OP_RESERVE],\n+                    op_ct[OP_RESERVE_TIMEOUT],\n+                    op_ct[OP_DELETE],\n+                    op_ct[OP_RELEASE],\n+                    op_ct[OP_USE],\n+                    op_ct[OP_WATCH],\n+                    op_ct[OP_IGNORE],\n+                    op_ct[OP_BURY],\n+                    op_ct[OP_KICK],\n+                    op_ct[OP_TOUCH],\n+                    op_ct[OP_STATS],\n+                    op_ct[OP_STATSJOB],\n+                    op_ct[OP_STATS_TUBE],\n+                    op_ct[OP_LIST_TUBES],\n+                    op_ct[OP_LIST_TUBE_USED],\n+                    op_ct[OP_LIST_TUBES_WATCHED],\n+                    op_ct[OP_PAUSE_TUBE],\n+                    timeout_ct,\n+                    global_stat.total_jobs_ct,\n+                    job_data_size_limit,\n+                    tubes.len,\n+                    count_cur_conns(),\n+                    count_cur_producers(),\n+                    count_cur_workers(),\n+                    global_stat.waiting_ct,\n+                    count_tot_conns(),\n+                    (long) getpid(),\n+                    version,\n+                    (int) ru.ru_utime.tv_sec, (int) ru.ru_utime.tv_usec,\n+                    (int) ru.ru_stime.tv_sec, (int) ru.ru_stime.tv_usec,\n+                    uptime(),\n+                    whead,\n+                    wcur,\n+                    s->wal.nmig,\n+                    s->wal.nrec,\n+                    s->wal.filesize,\n+                    drain_mode ? \"true\" : \"false\",\n+                    instance_hex,\n+                    node_info.nodename,\n+                    node_info.version,\n+                    node_info.machine);\n }\n \n /* Read an integer from the given buffer and place it in num.\n@@ -1051,11 +1070,15 @@ read_tube_name(char **tubename, char *buf, char **end)\n {\n     size_t len;\n \n-    while (buf[0] == ' ') buf++;\n+    while (buf[0] == ' ')\n+        buf++;\n     len = strspn(buf, NAME_CHARS);\n-    if (len == 0) return -1;\n-    if (tubename) *tubename = buf;\n-    if (end) *end = buf + len;\n+    if (len == 0)\n+        return -1;\n+    if (tubename)\n+        *tubename = buf;\n+    if (end)\n+        *end = buf + len;\n     return 0;\n }\n \n@@ -1364,7 +1387,8 @@ dispatch_cmd(Conn *c)\n         }\n         op_ct[type]++;\n \n-        j = job_copy(buried_job_p(c->use)? j = c->use->buried.next : NULL);\n+        // TODO: simplify the next horror line.\n+        j = job_copy(buried_job_p(c->use) ? j = c->use->buried.next : NULL);\n \n         if (!j) {\n             reply_msg(c, MSG_NOTFOUND);\n@@ -1886,9 +1910,10 @@ conn_process_io(Conn *c)\n \n         /* otherwise we have an incomplete line, so just keep waiting */\n         break;\n-    case STATE_BITBUCKET:\n+    case STATE_BITBUCKET: {\n         /* Invert the meaning of in_job_read while throwing away data -- it\n          * counts the bytes that remain to be thrown away. */\n+        static char bucket[BUCKET_BUF_SIZE];\n         to_read = min(c->in_job_read, BUCKET_BUF_SIZE);\n         r = read(c->sock.fd, bucket, to_read);\n         if (r == -1) {\n@@ -1906,9 +1931,9 @@ conn_process_io(Conn *c)\n \n         if (c->in_job_read == 0) {\n             reply(c, c->reply, c->reply_len, STATE_SENDWORD);\n-            return;\n         }\n-        break;\n+        return;\n+    }\n     case STATE_WANTDATA:\n         j = c->in_job;\n \n", "test_patch": "", "problem_statement": "add the OS version and platform to the stats command\nThe motivation is to have more detailed stats command so that users can report it when they have some problems.\r\n\r\nMake counters as uint64 where possible, and rearrange the code.", "version": "1.11", "language": "C", "created_at": "2019-08-23T08:16:42Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-558", "repo": "beanstalkd/beanstalkd", "pull_number": 558, "base_commit": "bd16d36e50b6f7db99ce41f2f97e565371339e64", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -440,7 +440,6 @@ struct Wal {\n     int    wantsync;\n     int64  syncrate;\n     int64  lastsync;\n-    int    nocomp; // disable binlog compaction?\n };\n int  waldirlock(Wal*);\n void walinit(Wal*, Job *list);\n\ndiff --git a/doc/beanstalkd.1 b/doc/beanstalkd.1\n--- a/doc/beanstalkd.1\n+++ b/doc/beanstalkd.1\n@@ -22,13 +22,6 @@ When started, \\fBbeanstalkd\\fR opens a socket (or uses a file descriptor provide\n Use a binlog to keep jobs on persistent storage in directory \\fIpath\\fR\\. Upon startup, \\fBbeanstalkd\\fR will recover any binlog that is present in \\fIpath\\fR, then, during normal operation, append new jobs and changes in state to the binlog\\.\n .\n .TP\n-\\fB\\-c\\fR\n-Perform online, incremental compaction of binlog files\\. Negates \\fB\\-n\\fR\\. This is the default behavior\\.\n-.\n-.IP\n-(Do not use this option, except to negate \\fB\\-n\\fR\\. Both \\fB\\-c\\fR and \\fB\\-n\\fR will likely be removed in a future \\fBbeanstalkd\\fR release\\.)\n-.\n-.TP\n \\fB\\-f\\fR \\fIms\\fR\n Call fsync(2) at most once every \\fIms\\fR milliseconds\\. Larger values for \\fIms\\fR reduce disk activity and improve speed at the cost of safety\\. A power failure could result in the loss of up to \\fIms\\fR milliseconds of history\\.\n .\n@@ -63,13 +56,6 @@ When \\fIaddr\\fR starts with \"unix:\", the unprefixed value of it will be used as\n (Option \\fB\\-l\\fR has no effect if sd\\-daemon(5) socket activation is being used\\. See also \\fIENVIRONMENT\\fR\\.)\n .\n .TP\n-\\fB\\-n\\fR\n-Turn off binlog compaction, negating \\fB\\-c\\fR\\.\n-.\n-.IP\n-(Do not use this option\\. Both \\fB\\-c\\fR and \\fB\\-n\\fR will likely be removed in a future \\fBbeanstalkd\\fR release\\.)\n-.\n-.TP\n \\fB\\-p\\fR \\fIport\\fR\n Listen on TCP port \\fIport\\fR (default is 11300)\\.\n .\n@@ -99,6 +85,14 @@ Print the version string and exit\\.\n \\fB\\-z\\fR \\fIbytes\\fR\n The maximum size in bytes of a job\\.\n .\n+.TP\n+\\fB\\-c\\fR\n+This flag has no effect\\. It is kept for historical compatibility only\\.\n+.\n+.TP\n+\\fB\\-n\\fR\n+This flag has no effect\\. It is kept for historical compatibility only\\.\n+.\n .SH \"ENVIRONMENT\"\n .\n .TP\n@@ -115,4 +109,4 @@ Files \\fBREADME\\fR and \\fBdoc/protocol\\.txt\\fR in the \\fBbeanstalkd\\fR distribut\n \\fIhttps://beanstalkd\\.github\\.io/\\fR\n .\n .SH \"AUTHOR\"\n-\\fBBeanstalkd\\fR is written and maintained by Keith Rarick with the help of many others\\.\n+\\fBBeanstalkd\\fR is written by Keith Rarick and maintained by the community at \\fIhttps://github\\.com/beanstalkd/beanstalkd/issues\\fR\n\ndiff --git a/doc/beanstalkd.1.html b/doc/beanstalkd.1.html\n--- a/doc/beanstalkd.1.html\n+++ b/doc/beanstalkd.1.html\n@@ -99,11 +99,6 @@ <h2 id=\"OPTIONS\">OPTIONS</h2>\n Upon startup, <code>beanstalkd</code> will recover any binlog that is present\n in <var>path</var>, then, during normal operation, append new jobs and\n changes in state to the binlog.</p></dd>\n-<dt class=\"flush\"><code>-c</code></dt><dd><p>Perform online, incremental compaction of binlog files. Negates\n-<code>-n</code>. This is the default behavior.</p>\n-\n-<p>(Do not use this option, except to negate <code>-n</code>. Both <code>-c</code> and <code>-n</code>\n-will likely be removed in a future <code>beanstalkd</code> release.)</p></dd>\n <dt class=\"flush\"><code>-f</code> <var>ms</var></dt><dd><p>Call <span class=\"man-ref\">fsync<span class=\"s\">(2)</span></span> at most once every <var>ms</var> milliseconds. Larger values\n for <var>ms</var> reduce disk activity and improve speed at the cost of\n safety. A power failure could result in the loss of up to <var>ms</var>\n@@ -127,10 +122,6 @@ <h2 id=\"OPTIONS\">OPTIONS</h2>\n \n <p>(Option <code>-l</code> has no effect if <span class=\"man-ref\">sd-daemon<span class=\"s\">(5)</span></span> socket activation is\n being used. See also <a href=\"#ENVIRONMENT\" title=\"ENVIRONMENT\" data-bare-link=\"true\">ENVIRONMENT</a>.)</p></dd>\n-<dt class=\"flush\"><code>-n</code></dt><dd><p>Turn off binlog compaction, negating <code>-c</code>.</p>\n-\n-<p>(Do not use this option. Both <code>-c</code> and <code>-n</code> will likely be removed\n-in a future <code>beanstalkd</code> release.)</p></dd>\n <dt class=\"flush\"><code>-p</code> <var>port</var></dt><dd><p>Listen on TCP port <var>port</var> (default is 11300).</p>\n \n <p>(Option <code>-p</code> has no effect if <span class=\"man-ref\">sd-daemon<span class=\"s\">(5)</span></span> socket activation is\n@@ -143,6 +134,8 @@ <h2 id=\"OPTIONS\">OPTIONS</h2>\n verbose output. The output format is subject to change.</p></dd>\n <dt class=\"flush\"><code>-v</code></dt><dd><p>Print the version string and exit.</p></dd>\n <dt><code>-z</code> <var>bytes</var></dt><dd><p>The maximum size in bytes of a job.</p></dd>\n+<dt class=\"flush\"><code>-c</code></dt><dd><p>This flag has no effect. It is kept for historical compatibility only.</p></dd>\n+<dt class=\"flush\"><code>-n</code></dt><dd><p>This flag has no effect. It is kept for historical compatibility only.</p></dd>\n </dl>\n \n \n@@ -165,8 +158,8 @@ <h2 id=\"SEE-ALSO\">SEE ALSO</h2>\n \n <h2 id=\"AUTHOR\">AUTHOR</h2>\n \n-<p><code>Beanstalkd</code> is written and maintained by Keith Rarick with the help\n-of many others.</p>\n+<p><code>Beanstalkd</code> is written by Keith Rarick and maintained by the community at\n+<a href=\"https://github.com/beanstalkd/beanstalkd/issues\" data-bare-link=\"true\">https://github.com/beanstalkd/beanstalkd/issues</a></p>\n \n \n   <ol class='man-decor man-foot man foot'>\n\ndiff --git a/doc/beanstalkd.ronn b/doc/beanstalkd.ronn\n--- a/doc/beanstalkd.ronn\n+++ b/doc/beanstalkd.ronn\n@@ -28,13 +28,6 @@ and format of the `beanstalkd` protocol.\n   in <path>, then, during normal operation, append new jobs and\n   changes in state to the binlog.\n \n-* `-c`:\n-  Perform online, incremental compaction of binlog files. Negates\n-  `-n`. This is the default behavior.\n-\n-  (Do not use this option, except to negate `-n`. Both `-c` and `-n`\n-  will likely be removed in a future `beanstalkd` release.)\n-\n * `-f` <ms>:\n   Call fsync(2) at most once every <ms> milliseconds. Larger values\n   for <ms> reduce disk activity and improve speed at the cost of\n@@ -66,12 +59,6 @@ and format of the `beanstalkd` protocol.\n   (Option `-l` has no effect if sd-daemon(5) socket activation is\n   being used. See also [ENVIRONMENT][].)\n \n-* `-n`:\n-  Turn off binlog compaction, negating `-c`.\n-\n-  (Do not use this option. Both `-c` and `-n` will likely be removed\n-  in a future `beanstalkd` release.)\n-\n * `-p` <port>:\n   Listen on TCP port <port> (default is 11300).\n \n@@ -96,6 +83,12 @@ and format of the `beanstalkd` protocol.\n * `-z` <bytes>:\n   The maximum size in bytes of a job.\n \n+* `-c`:\n+  This flag has no effect. It is kept for historical compatibility only.\n+\n+* `-n`:\n+  This flag has no effect. It is kept for historical compatibility only.\n+\n ## ENVIRONMENT\n \n * `LISTEN_PID`, `LISTEN_FDS`:\n@@ -113,5 +106,5 @@ distribution.\n \n ## AUTHOR\n \n-`Beanstalkd` is written and maintained by Keith Rarick with the help\n-of many others.\n+`Beanstalkd` is written by Keith Rarick and maintained by the community at\n+<https://github.com/beanstalkd/beanstalkd/issues>\n\ndiff --git a/testutil.c b/testutil.c\n--- a/testutil.c\n+++ b/testutil.c\n@@ -29,7 +29,6 @@ cttest_opt_none()\n     assert(srv.addr == NULL);\n     assert(job_data_size_limit == JOB_DATA_SIZE_LIMIT_DEFAULT);\n     assert(srv.wal.filesize == Filesizedef);\n-    assert(srv.wal.nocomp == 0);\n     assert(srv.wal.wantsync == 0);\n     assert(srv.user == NULL);\n     assert(srv.wal.dir == NULL);\n@@ -129,31 +128,6 @@ cttest_opts()\n     assert(srv.wal.filesize == 1234);\n }\n \n-void\n-cttest_optc()\n-{\n-    char *args[] = {\n-        \"-n\",\n-        \"-c\",\n-        NULL,\n-    };\n-\n-    optparse(&srv, args);\n-    assert(srv.wal.nocomp == 0);\n-}\n-\n-void\n-cttest_optn()\n-{\n-    char *args[] = {\n-        \"-n\",\n-        NULL,\n-    };\n-\n-    optparse(&srv, args);\n-    assert(srv.wal.nocomp == 1);\n-}\n-\n void\n cttest_optf()\n {\n@@ -243,15 +217,15 @@ cttest_optVVV()\n }\n \n void\n-cttest_optVnVu()\n+cttest_optVFVu()\n {\n     char *args[] = {\n-        \"-VnVukr\",\n+        \"-VFVukr\",\n         NULL,\n     };\n \n     optparse(&srv, args);\n     assert(verbose == 2);\n-    assert(srv.wal.nocomp == 1);\n+    assert(srv.wal.wantsync == 0);\n     assert(strcmp(srv.user, \"kr\") == 0);\n }\n\ndiff --git a/util.c b/util.c\n--- a/util.c\n+++ b/util.c\n@@ -109,8 +109,6 @@ usage(int code)\n             \" -z BYTES set the maximum job size in bytes (default is %d, max allowed is %d)\\n\"\n             \" -s BYTES set the size of each write-ahead log file (default is %d)\\n\"\n             \"            (will be rounded up to a multiple of 4096 bytes)\\n\"\n-            \" -c       compact the binlog (default)\\n\"\n-            \" -n       do not compact the binlog\\n\"\n             \" -v       show version information\\n\"\n             \" -V       increase verbosity\\n\"\n             \" -h       show this help\\n\",\n@@ -176,10 +174,10 @@ optparse(Server *s, char **argv)\n                     s->wal.filesize = parse_size_t(EARGF(flagusage(\"-s\")));\n                     break;\n                 case 'c':\n-                    s->wal.nocomp = 0;\n+                    warnx(\"-c flag was removed. binlog is always compacted.\");\n                     break;\n                 case 'n':\n-                    s->wal.nocomp = 1;\n+                    warnx(\"-n flag was removed. binlog is always compacted.\");\n                     break;\n                 case 'f':\n                     ms = (int64)parse_size_t(EARGF(flagusage(\"-f\")));\n\ndiff --git a/walg.c b/walg.c\n--- a/walg.c\n+++ b/walg.c\n@@ -201,9 +201,7 @@ void\n walmaint(Wal *w)\n {\n     if (w->use) {\n-        if (!w->nocomp) {\n-            walcompact(w);\n-        }\n+        walcompact(w);\n         walsync(w);\n     }\n }\n", "test_patch": "", "problem_statement": "remove the -c and -n flags that control log compaction\nLog compaction should not be switched off.\r\n\r\nFixes #552", "version": "1.11", "language": "C", "created_at": "2019-08-27T06:14:17Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-551", "repo": "beanstalkd/beanstalkd", "pull_number": 551, "base_commit": "643af3dbb88a04b1ce68d5e707a4962d400b7f0e", "patch": "diff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -34,16 +34,17 @@ on_ignore(Ms *a, Tube *t, size_t i)\n Conn *\n make_conn(int fd, char start_state, Tube *use, Tube *watch)\n {\n-    Job *j;\n-    Conn *c;\n-\n-    c = new(Conn);\n-    if (!c) return twarn(\"OOM\"), NULL;\n+    Conn *c = new(Conn);\n+    if (!c) {\n+        twarn(\"OOM\");\n+        return NULL;\n+    }\n \n     ms_init(&c->watch, (ms_event_fn) on_watch, (ms_event_fn) on_ignore);\n     if (!ms_append(&c->watch, watch)) {\n         free(c);\n-        return twarn(\"OOM\"), NULL;\n+        twarn(\"OOM\");\n+        return NULL;\n     }\n \n     TUBE_ASSIGN(c->use, use);\n@@ -54,8 +55,9 @@ make_conn(int fd, char start_state, Tube *use, Tube *watch)\n     c->pending_timeout = -1;\n     c->tickpos = 0; // Does not mean anything if in_conns is set to 0.\n     c->in_conns = 0;\n-    j = &c->reserved_jobs;\n-    j->prev = j->next = j;\n+\n+    // The list is empty.\n+    job_list_reset(&c->reserved_jobs);\n \n     /* stats */\n     cur_conn_ct++;\n@@ -107,7 +109,7 @@ count_cur_workers()\n static int\n has_reserved_job(Conn *c)\n {\n-    return job_list_any_p(&c->reserved_jobs);\n+    return !job_list_is_empty(&c->reserved_jobs);\n }\n \n \n@@ -154,25 +156,43 @@ connsched(Conn *c)\n     }\n }\n \n+// conn_set_soonestjob updates c->soonest_job with j\n+// if j should be handled sooner than c->soonest_job.\n+static void\n+conn_set_soonestjob(Conn *c, Job *j) {\n+    if (!c->soonest_job || j->r.deadline_at < c->soonest_job->r.deadline_at) {\n+        c->soonest_job = j;\n+    }\n+}\n \n // Return the reserved job with the earliest deadline,\n-// or NULL if there's no reserved job\n+// or NULL if there's no reserved job.\n Job *\n connsoonestjob(Conn *c)\n {\n-    Job *j = NULL;\n-    Job *soonest = c->soonest_job;\n+    // use cached value and bail out.\n+    if (c->soonest_job != NULL)\n+        return c->soonest_job;\n \n-    if (soonest == NULL) {\n-        for (j = c->reserved_jobs.next; j != &c->reserved_jobs; j = j->next) {\n-            if (j->r.deadline_at <= (soonest ? soonest : j)->r.deadline_at)\n-                soonest = j;\n-        }\n+    Job *j = NULL;\n+    for (j = c->reserved_jobs.next; j != &c->reserved_jobs; j = j->next) {\n+        conn_set_soonestjob(c, j);\n     }\n-    c->soonest_job = soonest;\n-    return soonest;\n+    return c->soonest_job;\n }\n \n+void\n+conn_reserve_job(Conn *c, Job *j) {\n+    j->tube->stat.reserved_ct++;\n+    j->r.reserve_ct++;\n+\n+    j->r.deadline_at = nanoseconds() + j->r.ttr;\n+    j->r.state = Reserved;\n+    job_list_insert(&c->reserved_jobs, j);\n+    j->reserver = c;\n+    c->pending_timeout = -1;\n+    conn_set_soonestjob(c, j);\n+}\n \n // Return true if c has a reserved job with less than one second until its\n // deadline.\n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -309,9 +309,10 @@ Job *job_copy(Job *j);\n \n const char * job_state(Job *j);\n \n-int job_list_any_p(Job *head);\n-Job *job_remove(Job *j);\n-void job_insert(Job *head, Job *j);\n+void job_list_reset(Job *head);\n+int job_list_is_empty(Job *head);\n+Job *job_list_remove(Job *j);\n+void job_list_insert(Job *head, Job *j);\n \n /* for unit tests */\n size_t get_all_jobs_used(void);\n@@ -343,7 +344,7 @@ extern size_t job_data_size_limit;\n void prot_init(void);\n int64 prottick(Server *s);\n \n-Conn *remove_waiting_conn(Conn *c);\n+void remove_waiting_conn(Conn *c);\n \n void enqueue_reserved_jobs(Conn *c);\n \n@@ -412,6 +413,7 @@ void connsetworker(Conn *c);\n Job *connsoonestjob(Conn *c);\n int  conndeadlinesoon(Conn *c);\n int conn_ready(Conn *c);\n+void conn_reserve_job(Conn *c, Job *j);\n #define conn_waiting(c) ((c)->type & CONN_TYPE_WAITING)\n \n \n\ndiff --git a/file.c b/file.c\n--- a/file.c\n+++ b/file.c\n@@ -212,11 +212,11 @@ readrec(File *f, Job *l, int *err)\n             t = tube_find_or_make(tubename);\n             j = make_job_with_id(jr.pri, jr.delay, jr.ttr, jr.body_size,\n                                  t, jr.id);\n-            j->next = j->prev = j;\n+            job_list_reset(j);\n             j->r.created_at = jr.created_at;\n         }\n         j->r = jr;\n-        job_insert(l, j);\n+        job_list_insert(l, j);\n \n         // full record; read the job body\n         if (namelen) {\n@@ -243,7 +243,7 @@ readrec(File *f, Job *l, int *err)\n         return 1;\n     case Invalid:\n         if (j) {\n-            job_remove(j);\n+            job_list_remove(j);\n             filermjob(j->file, j);\n             job_free(j);\n         }\n@@ -253,7 +253,7 @@ readrec(File *f, Job *l, int *err)\n Error:\n     *err = 1;\n     if (j) {\n-        job_remove(j);\n+        job_list_remove(j);\n         filermjob(j->file, j);\n         job_free(j);\n     }\n@@ -337,7 +337,7 @@ readrec5(File *f, Job *l, int *err)\n             t = tube_find_or_make(tubename);\n             j = make_job_with_id(jr.pri, jr.delay, jr.ttr, jr.body_size,\n                                  t, jr.id);\n-            j->next = j->prev = j;\n+            job_list_reset(j);\n         }\n         j->r.id = jr.id;\n         j->r.pri = jr.pri;\n@@ -352,7 +352,7 @@ readrec5(File *f, Job *l, int *err)\n         j->r.bury_ct = jr.bury_ct;\n         j->r.kick_ct = jr.kick_ct;\n         j->r.state = jr.state;\n-        job_insert(l, j);\n+        job_list_insert(l, j);\n \n         // full record; read the job body\n         if (namelen) {\n@@ -379,7 +379,7 @@ readrec5(File *f, Job *l, int *err)\n         return 1;\n     case Invalid:\n         if (j) {\n-            job_remove(j);\n+            job_list_remove(j);\n             filermjob(j->file, j);\n             job_free(j);\n         }\n@@ -389,7 +389,7 @@ readrec5(File *f, Job *l, int *err)\n Error:\n     *err = 1;\n     if (j) {\n-        job_remove(j);\n+        job_list_remove(j);\n         filermjob(j->file, j);\n         job_free(j);\n     }\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -104,7 +104,7 @@ allocate_job(int body_size)\n     j->r.created_at = nanoseconds();\n     j->r.body_size = body_size;\n     j->body = (char *)j + sizeof(Job);\n-    j->next = j->prev = j;      // not in a linked list\n+    job_list_reset(j);\n     return j;\n }\n \n@@ -115,7 +115,10 @@ make_job_with_id(uint32 pri, int64 delay, int64 ttr,\n     Job *j;\n \n     j = allocate_job(body_size);\n-    if (!j) return twarnx(\"OOM\"), (Job *) 0;\n+    if (!j) {\n+        twarnx(\"OOM\");\n+        return (Job *) 0;\n+    }\n \n     if (id) {\n         j->r.id = id;\n@@ -190,15 +193,16 @@ job_delay_less(void *ja, void *jb)\n Job *\n job_copy(Job *j)\n {\n-    Job *n;\n-\n     if (!j) return NULL;\n \n-    n = malloc(sizeof(Job) + j->r.body_size);\n-    if (!n) return twarnx(\"OOM\"), (Job *) 0;\n+    Job *n = malloc(sizeof(Job) + j->r.body_size);\n+    if (!n) {\n+        twarnx(\"OOM\");\n+        return (Job *) 0;\n+    }\n \n     memcpy(n, j, sizeof(Job) + j->r.body_size);\n-    n->next = n->prev = n; /* not in a linked list */\n+    job_list_reset(n);\n \n     n->file = NULL; /* copies do not have refcnt on the wal */\n \n@@ -221,30 +225,39 @@ job_state(Job *j)\n     return \"invalid\";\n }\n \n+// job_list_reset detaches head from the list,\n+// marking the list starting in head pointing to itself.\n+void\n+job_list_reset(Job *head)\n+{\n+    head->prev = head;\n+    head->next = head;\n+}\n+\n int\n-job_list_any_p(Job *head)\n+job_list_is_empty(Job *head)\n {\n-    return head->next != head || head->prev != head;\n+    return head->next == head && head->prev == head;\n }\n \n Job *\n-job_remove(Job *j)\n+job_list_remove(Job *j)\n {\n     if (!j) return NULL;\n-    if (!job_list_any_p(j)) return NULL; /* not in a doubly-linked list */\n+    if (job_list_is_empty(j)) return NULL; /* not in a doubly-linked list */\n \n     j->next->prev = j->prev;\n     j->prev->next = j->next;\n \n-    j->prev = j->next = j;\n+    job_list_reset(j);\n \n     return j;\n }\n \n void\n-job_insert(Job *head, Job *j)\n+job_list_insert(Job *head, Job *j)\n {\n-    if (job_list_any_p(j)) return; /* already in a linked list */\n+    if (!job_list_is_empty(j)) return; /* already in a linked list */\n \n     j->prev = head->prev;\n     j->next = head;\n\ndiff --git a/net.c b/net.c\n--- a/net.c\n+++ b/net.c\n@@ -218,7 +218,8 @@ make_server_socket(char *host, char *port)\n      * and return. */\n     r = sd_listen_fds(1);\n     if (r < 0) {\n-        return twarn(\"sd_listen_fds\"), -1;\n+        twarn(\"sd_listen_fds\");\n+        return -1;\n     }\n     if (r > 0) {\n         if (r > 1) {\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -276,7 +276,7 @@ static Job *remove_buried_job(Job *j);\n static int\n buried_job_p(Tube *t)\n {\n-    return job_list_any_p(&t->buried);\n+    return !job_list_is_empty(&t->buried);\n }\n \n // epollq_add schedules connection c in the s->conns heap, adds c\n@@ -391,15 +391,12 @@ reply_job(Conn *c, Job *j, const char *msg)\n \n // remove_waiting_conn unsets CONN_TYPE_WAITING for the connection,\n // removes it from the waiting_conns set of every tube it's watching.\n-Conn *\n+// Noop if connection is not waiting.\n+void\n remove_waiting_conn(Conn *c)\n {\n-    // What for is this check? If this function returns NULL then\n-    // functions calling it hit null pointer dereference afterwards\n-    // or just do nothing at best. Maybe NULL result should produce\n-    // INTERNAL_ERROR to the client, meaning a bug in the code.\n     if (!conn_waiting(c))\n-        return NULL;\n+        return;\n \n     c->type &= ~CONN_TYPE_WAITING;\n     global_stat.waiting_ct--;\n@@ -409,7 +406,6 @@ remove_waiting_conn(Conn *c)\n         t->stat.waiting_ct--;\n         ms_remove(&t->waiting_conns, c);\n     }\n-    return c;\n }\n \n // enqueue_waiting_conn sets CONN_TYPE_WAITING for the connection,\n@@ -427,26 +423,6 @@ enqueue_waiting_conn(Conn *c)\n     }\n }\n \n-// TODO: inline this obscure function to the process_queue();\n-// this function does a sequence of many things, all are side effects,\n-// there is no point to have it as separate function.\n-static void\n-reserve_job(Conn *c, Job *j)\n-{\n-    j->r.deadline_at = nanoseconds() + j->r.ttr;\n-    global_stat.reserved_ct++; /* stats */\n-    j->tube->stat.reserved_ct++;\n-    j->r.reserve_ct++;\n-    j->r.state = Reserved;\n-    job_insert(&c->reserved_jobs, j);\n-    j->reserver = c;\n-    c->pending_timeout = -1;\n-    if (c->soonest_job && j->r.deadline_at < c->soonest_job->r.deadline_at) {\n-        c->soonest_job = j;\n-    }\n-    reply_job(c, j, MSG_RESERVED);\n-}\n-\n // next_awaited_job iterates through all the tubes with awaiting connections,\n // returns the next ready job with the smallest priority.\n // If jobs has the same priority it picks the job with smaller id.\n@@ -488,13 +464,17 @@ process_queue()\n             global_stat.urgent_ct--;\n             j->tube->stat.urgent_ct--;\n         }\n-        Conn *next = ms_take(&j->tube->waiting_conns);\n-        if (next==NULL) {\n+\n+        Conn *c = ms_take(&j->tube->waiting_conns);\n+        if (c == NULL) {\n             twarnx(\"waiting_conns is empty\");\n             continue;\n         }\n-        next = remove_waiting_conn(next);\n-        reserve_job(next, j);\n+        global_stat.reserved_ct++;\n+\n+        remove_waiting_conn(c);\n+        conn_reserve_job(c, j);\n+        reply_job(c, j, MSG_RESERVED);\n     }\n }\n \n@@ -568,7 +548,7 @@ bury_job(Server *s, Job *j, char update_store)\n         j->walresv += z;\n     }\n \n-    job_insert(&j->tube->buried, j);\n+    job_list_insert(&j->tube->buried, j);\n     global_stat.buried_ct++;\n     j->tube->stat.buried_ct++;\n     j->r.state = Buried;\n@@ -588,8 +568,8 @@ bury_job(Server *s, Job *j, char update_store)\n void\n enqueue_reserved_jobs(Conn *c)\n {\n-    while (job_list_any_p(&c->reserved_jobs)) {\n-        Job *j = job_remove(c->reserved_jobs.next);\n+    while (!job_list_is_empty(&c->reserved_jobs)) {\n+        Job *j = job_list_remove(c->reserved_jobs.next);\n         int r = enqueue_job(c->srv, j, 0, 0);\n         if (r < 1)\n             bury_job(c->srv, j, 0);\n@@ -691,7 +671,7 @@ static Job *\n remove_buried_job(Job *j)\n {\n     if (!j || j->r.state != Buried) return NULL;\n-    j = job_remove(j);\n+    j = job_list_remove(j);\n     if (j) {\n         global_stat.buried_ct--;\n         j->tube->stat.buried_ct--;\n@@ -1240,7 +1220,7 @@ maybe_enqueue_incoming_job(Conn *c)\n static Job *\n remove_this_reserved_job(Conn *c, Job *j)\n {\n-    j = job_remove(j);\n+    j = job_list_remove(j);\n     if (j) {\n         global_stat.reserved_ct--;\n         j->tube->stat.reserved_ct--;\n@@ -1834,10 +1814,12 @@ conn_timeout(Conn *c)\n     }\n \n     if (should_timeout) {\n-        reply_msg(remove_waiting_conn(c), MSG_DEADLINE_SOON);\n+        remove_waiting_conn(c);\n+        reply_msg(c, MSG_DEADLINE_SOON);\n     } else if (conn_waiting(c) && c->pending_timeout >= 0) {\n         c->pending_timeout = -1;\n-        reply_msg(remove_waiting_conn(c), MSG_TIMED_OUT);\n+        remove_waiting_conn(c);\n+        reply_msg(c, MSG_TIMED_OUT);\n     }\n }\n \n@@ -2008,7 +1990,8 @@ conn_process_io(Conn *c)\n     case STATE_WAIT:\n         if (c->halfclosed) {\n             c->pending_timeout = -1;\n-            reply_msg(remove_waiting_conn(c), MSG_TIMED_OUT);\n+            remove_waiting_conn(c);\n+            reply_msg(c, MSG_TIMED_OUT);\n             return;\n         }\n         break;\n@@ -2208,7 +2191,8 @@ prot_init()\n     ms_init(&tubes, NULL, NULL);\n \n     TUBE_ASSIGN(default_tube, tube_find_or_make(\"default\"));\n-    if (!default_tube) twarnx(\"Out of memory during startup!\");\n+    if (!default_tube)\n+        twarnx(\"Out of memory during startup!\");\n }\n \n // For each job in list, inserts the job into the appropriate data\n@@ -2224,7 +2208,7 @@ prot_replay(Server *s, Job *list)\n \n     for (j = list->next ; j != list ; j = nj) {\n         nj = j->next;\n-        job_remove(j);\n+        job_list_remove(j);\n         int z = walresvupdate(&s->wal);\n         if (!z) {\n             twarnx(\"failed to reserve space\");\n", "test_patch": "", "problem_statement": "improve clarity for job_list_* operations\nBunch of functions renamed here and there.\r\nremote_waiting_conn() does not return anything anymore,\r\ninstead it is noop for not waiting connection.\r\n\r\nreserve_job() body mostly was moved to conn_reserve_job().\r\nthe rest was left in place of the call to it.", "version": "1.11", "language": "C", "created_at": "2019-08-17T13:12:22Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-295", "repo": "beanstalkd/beanstalkd", "pull_number": 295, "base_commit": "d2922bd4ac2ad9047d081f1b044db4a2314bcf82", "patch": "diff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -34,7 +34,7 @@ store_job(job j)\n     all_jobs_used++;\n \n     /* accept a load factor of 4 */\n-    if (all_jobs_used > (all_jobs_cap << 2)) rehash();\n+    if (all_jobs_used > (all_jobs_cap >> 2)) rehash();\n }\n \n static void\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -12,7 +12,7 @@ static job *all_jobs = all_jobs_init;\n static size_t all_jobs_cap = 12289; /* == primes[0] */\n static size_t all_jobs_used = 0;\n \n-static int hash_table_was_oom = 0;\n+static int hash_table_max_prime = NUM_PRIMES;\n \n static void rehash();\n \n@@ -44,13 +44,13 @@ rehash()\n     size_t old_cap = all_jobs_cap, old_used = all_jobs_used, i;\n \n     if (cur_prime >= NUM_PRIMES) return;\n-    if (hash_table_was_oom) return;\n+    if (hash_table_max_prime <= cur_prime) return;\n \n     all_jobs_cap = primes[++cur_prime];\n     all_jobs = calloc(all_jobs_cap, sizeof(job));\n     if (!all_jobs) {\n         twarnx(\"Failed to allocate %zu new hash buckets\", all_jobs_cap);\n-        hash_table_was_oom = 1;\n+        hash_table_max_prime = cur_prime;\n         --cur_prime;\n         all_jobs = old;\n         all_jobs_cap = old_cap;\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -72,6 +72,40 @@ rehash()\n     }\n }\n \n+static void\n+rehash_down()\n+{\n+    job *old = all_jobs;\n+    size_t old_cap = all_jobs_cap, old_used = all_jobs_used, i;\n+\n+    if (cur_prime <= 0) return;\n+\n+    all_jobs_cap = primes[--cur_prime];\n+    all_jobs = calloc(all_jobs_cap, sizeof(job));\n+    if (!all_jobs) {\n+        twarnx(\"Failed to allocate %zu new hash buckets\", all_jobs_cap);\n+        hash_table_max_prime = cur_prime;\n+        ++cur_prime;\n+        all_jobs = old;\n+        all_jobs_cap = old_cap;\n+        all_jobs_used = old_used;\n+        return;\n+    }\n+    all_jobs_used = 0;\n+\n+    for (i = 0; i < old_cap; i++) {\n+        while (old[i]) {\n+            job j = old[i];\n+            old[i] = j->ht_next;\n+            j->ht_next = NULL;\n+            store_job(j);\n+        }\n+    }\n+    if (old != all_jobs_init) {\n+        free(old);\n+    }\n+}\n+\n job\n job_find(uint64 job_id)\n {\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -169,6 +169,9 @@ job_hash_free(job j)\n         *slot = (*slot)->ht_next;\n         --all_jobs_used;\n     }\n+\n+    // Downscale when the hashmap is too sparse\n+    if (all_jobs_used < (all_jobs_cap >> 4) && cur_prime > 0) rehash_down();\n }\n \n void\n\ndiff --git a/primes.c b/primes.c\n--- a/primes.c\n+++ b/primes.c\n@@ -1,11 +1,13 @@\n #include <stdlib.h>\n \n+// prime // downscale treshold / upscale treshold\n+\n size_t primes[] = {\n-    12289,\n-    24593,\n-    49193,\n-    98387,\n-    196799,\n+    12289, // NA / 3072\n+    24593, // 1537 / 6148\n+    49193, // 3074 / 12298\n+    98387, // 6149 / 24596\n+    196799, // etc\n     393611,\n     787243,\n     1574491,\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -34,7 +34,7 @@ store_job(job j)\n     all_jobs_used++;\n \n     /* accept a load factor of 4 */\n-    if (all_jobs_used > (all_jobs_cap >> 2)) rehash();\n+    if (all_jobs_used > (all_jobs_cap << 2)) rehash();\n }\n \n static void\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -171,7 +171,7 @@ job_hash_free(job j)\n     }\n \n     // Downscale when the hashmap is too sparse\n-    if (all_jobs_used < (all_jobs_cap >> 4) && cur_prime > 0) rehash_down();\n+    if (all_jobs_used < (all_jobs_cap >> 4)) rehash_down();\n }\n \n void\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -34,58 +34,32 @@ store_job(job j)\n     all_jobs_used++;\n \n     /* accept a load factor of 4 */\n-    if (all_jobs_used > (all_jobs_cap << 2)) rehash();\n+    if (all_jobs_used > (all_jobs_cap << 2)) rehash(1);\n }\n \n static void\n-rehash()\n+rehash(int is_upscaling)\n {\n     job *old = all_jobs;\n     size_t old_cap = all_jobs_cap, old_used = all_jobs_used, i;\n+    int old_prime = cur_prime;\n \n-    if (cur_prime >= NUM_PRIMES) return;\n-    if (hash_table_max_prime <= cur_prime) return;\n-\n-    all_jobs_cap = primes[++cur_prime];\n-    all_jobs = calloc(all_jobs_cap, sizeof(job));\n-    if (!all_jobs) {\n-        twarnx(\"Failed to allocate %zu new hash buckets\", all_jobs_cap);\n-        hash_table_max_prime = cur_prime;\n-        --cur_prime;\n-        all_jobs = old;\n-        all_jobs_cap = old_cap;\n-        all_jobs_used = old_used;\n-        return;\n-    }\n-    all_jobs_used = 0;\n-\n-    for (i = 0; i < old_cap; i++) {\n-        while (old[i]) {\n-            job j = old[i];\n-            old[i] = j->ht_next;\n-            j->ht_next = NULL;\n-            store_job(j);\n-        }\n+    if (is_upscaling) {\n+        if (cur_prime >= NUM_PRIMES) return;\n+        if (hash_table_max_prime <= cur_prime) return;\n+        ++cur_prime;\n     }\n-    if (old != all_jobs_init) {\n-        free(old);\n+    else {\n+        if (cur_prime <= 0) return;\n+        --cur_prime;\n     }\n-}\n-\n-static void\n-rehash_down()\n-{\n-    job *old = all_jobs;\n-    size_t old_cap = all_jobs_cap, old_used = all_jobs_used, i;\n \n-    if (cur_prime <= 0) return;\n-\n-    all_jobs_cap = primes[--cur_prime];\n+    all_jobs_cap = primes[cur_prime];\n     all_jobs = calloc(all_jobs_cap, sizeof(job));\n     if (!all_jobs) {\n         twarnx(\"Failed to allocate %zu new hash buckets\", all_jobs_cap);\n         hash_table_max_prime = cur_prime;\n-        ++cur_prime;\n+        cur_prime = old_prime;\n         all_jobs = old;\n         all_jobs_cap = old_cap;\n         all_jobs_used = old_used;\n@@ -171,7 +145,7 @@ job_hash_free(job j)\n     }\n \n     // Downscale when the hashmap is too sparse\n-    if (all_jobs_used < (all_jobs_cap >> 4)) rehash_down();\n+    if (all_jobs_used < (all_jobs_cap >> 4)) rehash(0);\n }\n \n void\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -12,7 +12,7 @@ static job *all_jobs = all_jobs_init;\n static size_t all_jobs_cap = 12289; /* == primes[0] */\n static size_t all_jobs_used = 0;\n \n-static int hash_table_max_prime = NUM_PRIMES;\n+static int hash_table_was_oom = 1;\n \n static void rehash();\n \n@@ -46,7 +46,7 @@ rehash(int is_upscaling)\n \n     if (is_upscaling) {\n         if (cur_prime >= NUM_PRIMES) return;\n-        if (hash_table_max_prime <= cur_prime) return;\n+        if (hash_table_was_oom) return;\n         ++cur_prime;\n     }\n     else {\n@@ -58,14 +58,15 @@ rehash(int is_upscaling)\n     all_jobs = calloc(all_jobs_cap, sizeof(job));\n     if (!all_jobs) {\n         twarnx(\"Failed to allocate %zu new hash buckets\", all_jobs_cap);\n-        hash_table_max_prime = cur_prime;\n+        hash_table_was_oom = 1;\n         cur_prime = old_prime;\n         all_jobs = old;\n         all_jobs_cap = old_cap;\n         all_jobs_used = old_used;\n         return;\n     }\n     all_jobs_used = 0;\n+    hash_table_was_oom = 0;\n \n     for (i = 0; i < old_cap; i++) {\n         while (old[i]) {\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -43,16 +43,13 @@ rehash(int is_upscaling)\n     job *old = all_jobs;\n     size_t old_cap = all_jobs_cap, old_used = all_jobs_used, i;\n     int old_prime = cur_prime;\n+    int d = is_upscaling ? 1 : -1;\n \n-    if (is_upscaling) {\n-        if (cur_prime >= NUM_PRIMES) return;\n-        if (hash_table_was_oom) return;\n-        ++cur_prime;\n-    }\n-    else {\n-        if (cur_prime <= 0) return;\n-        --cur_prime;\n-    }\n+    if (cur_prime + d >= NUM_PRIMES) return;\n+    if (cur_prime + d < 0) return;\n+    if (is_upscaling && hash_table_was_oom) return;\n+\n+    cur_prime += d;\n \n     all_jobs_cap = primes[cur_prime];\n     all_jobs = calloc(all_jobs_cap, sizeof(job));\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -12,7 +12,7 @@ static job *all_jobs = all_jobs_init;\n static size_t all_jobs_cap = 12289; /* == primes[0] */\n static size_t all_jobs_used = 0;\n \n-static int hash_table_was_oom = 1;\n+static int hash_table_was_oom = 0;\n \n static void rehash();\n \n", "test_patch": "", "problem_statement": "Reduce the size of the hashmap when it's too sparse\nHi,\n\nIn my team, we use beanstalkd a lot and we found that it holds a large quantity of memory if it has been filled with a large collections once, even if it's empty afterwards.\n\nI investigated the code and found out that beanstalkd keep a hash map relating ids to their job. This hash map is extended when at least a quarter of it is filled, but it never tries to shrink. So I implemented this shrinking, with a factor of 1/16 to prevent the hash map from scaling too often.\n\nI hope it helps !", "version": "1.10", "language": "C", "created_at": "2016-01-28T14:35:28Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-510", "repo": "beanstalkd/beanstalkd", "pull_number": 510, "base_commit": "357a0651d6bbf364bbb4890d95e3bae476eb58ed", "patch": "diff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -38,12 +38,12 @@ make_conn(int fd, char start_state, Tube *use, Tube *watch)\n     Conn *c;\n \n     c = new(Conn);\n-    if (!c) return twarn(\"OOM\"), NULL;\n+    if (!c) return twarnerr(\"OOM\"), NULL;\n \n     ms_init(&c->watch, (ms_event_fn) on_watch, (ms_event_fn) on_ignore);\n     if (!ms_append(&c->watch, watch)) {\n         free(c);\n-        return twarn(\"OOM\"), NULL;\n+        return twarnerr(\"OOM\"), NULL;\n     }\n \n     TUBE_ASSIGN(c->use, use);\n\ndiff --git a/darwin.c b/darwin.c\n--- a/darwin.c\n+++ b/darwin.c\n@@ -41,7 +41,7 @@ sockinit(void)\n {\n     kq = kqueue();\n     if (kq == -1) {\n-        twarn(\"kqueue\");\n+        twarnerr(\"kqueue\");\n         return -1;\n     }\n     return 0;\n@@ -100,7 +100,7 @@ socknext(Socket **s, int64 timeout)\n     ts.tv_nsec = timeout % 1000000000;\n     r = kevent(kq, NULL, 0, &ev, 1, &ts);\n     if (r == -1 && errno != EINTR) {\n-        twarn(\"kevent\");\n+        twarnerr(\"kevent\");\n         return -1;\n     }\n \n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -231,13 +231,19 @@ struct Tube {\n };\n \n \n-#define twarn(fmt, args...) warn(\"%s:%d in %s: \" fmt, \\\n-                                 __FILE__, __LINE__, __func__, ##args)\n-#define twarnx(fmt, args...) warnx(\"%s:%d in %s: \" fmt, \\\n-                                   __FILE__, __LINE__, __func__, ##args)\n+#define twarnerr(fmt, args...) \\\n+    warnerr(\"%s:%d in %s: \" fmt, __FILE__, __LINE__, __func__, ##args)\n+#define twarn(fmt, args...) \\\n+    warn(\"%s:%d in %s: \" fmt, __FILE__, __LINE__, __func__, ##args)\n \n+// warnerr prints fmt and the error message based on errno into stderr:\n+// \"progname: fmt: error message\"\n+void warnerr(const char *fmt, ...) __attribute__((format(printf, 1, 2)));\n+\n+// warn prints fmt into stderr:\n+// \"progname: fmt\"\n void warn(const char *fmt, ...) __attribute__((format(printf, 1, 2)));\n-void warnx(const char *fmt, ...) __attribute__((format(printf, 1, 2)));\n+\n char* fmtalloc(char *fmt, ...) __attribute__((format(printf, 1, 2)));\n void* zalloc(int n);\n #define new(T) zalloc(sizeof(T))\n@@ -248,7 +254,8 @@ extern const char *progname;\n int64 nanoseconds(void);\n int   rawfalloc(int fd, int len);\n \n-#define make_job(pri,delay,ttr,body_size,tube) make_job_with_id(pri,delay,ttr,body_size,tube,0)\n+#define make_job(pri,delay,ttr,body_size,tube) \\\n+    make_job_with_id(pri,delay,ttr,body_size,tube,0)\n \n Job *allocate_job(int body_size);\n Job *make_job_with_id(uint pri, int64 delay, int64 ttr,\n\ndiff --git a/file.c b/file.c\n--- a/file.c\n+++ b/file.c\n@@ -124,7 +124,7 @@ fileread(File *f, Job *list)\n         return err;\n     }\n \n-    warnx(\"%s: unknown version: %d\", f->path, v);\n+    warn(\"%s: unknown version: %d\", f->path, v);\n     return 1;\n }\n \n@@ -144,7 +144,7 @@ readrec(File *f, Job *l, int *err)\n \n     r = read(f->fd, &namelen, sizeof(int));\n     if (r == -1) {\n-        twarn(\"read\");\n+        twarnerr(\"read\");\n         warnpos(f, 0, \"error\");\n         *err = 1;\n         return 0;\n@@ -274,7 +274,7 @@ readrec5(File *f, Job *l, int *err)\n \n     r = read(f->fd, &namelen, sizeof(namelen));\n     if (r == -1) {\n-        twarn(\"read\");\n+        twarnerr(\"read\");\n         warnpos(f, 0, \"error\");\n         *err = 1;\n         return 0;\n@@ -403,7 +403,7 @@ readfull(File *f, void *c, int n, int *err, char *desc)\n \n     r = read(f->fd, c, n);\n     if (r == -1) {\n-        twarn(\"read\");\n+        twarnerr(\"read\");\n         warnpos(f, 0, \"error reading %s\", desc);\n         *err = 1;\n         return 0;\n@@ -443,25 +443,25 @@ filewopen(File *f)\n \n     fd = open(f->path, O_WRONLY|O_CREAT, 0400);\n     if (fd < 0) {\n-        twarn(\"open %s\", f->path);\n+        twarnerr(\"open %s\", f->path);\n         return;\n     }\n \n     r = falloc(fd, f->w->filesize);\n     if (r) {\n         close(fd);\n         errno = r;\n-        twarn(\"falloc %s\", f->path);\n+        twarnerr(\"falloc %s\", f->path);\n         r = unlink(f->path);\n         if (r) {\n-            twarn(\"unlink %s\", f->path);\n+            twarnerr(\"unlink %s\", f->path);\n         }\n         return;\n     }\n \n     n = write(fd, &ver, sizeof(int));\n     if (n < 0 || (size_t)n < sizeof(int)) {\n-        twarn(\"write %s\", f->path);\n+        twarnerr(\"write %s\", f->path);\n         close(fd);\n         return;\n     }\n@@ -481,7 +481,7 @@ filewrite(File *f, Job *j, void *buf, int len)\n \n     r = write(f->fd, buf, len);\n     if (r != len) {\n-        twarn(\"write\");\n+        twarnerr(\"write\");\n         return 0;\n     }\n \n@@ -535,7 +535,7 @@ filewclose(File *f)\n     if (f->free) {\n         errno = 0;\n         if (ftruncate(f->fd, f->w->filesize - f->free) != 0) {\n-            twarn(\"ftruncate\");\n+            twarnerr(\"ftruncate\");\n         }\n     }\n     close(f->fd);\n\ndiff --git a/job.c b/job.c\n--- a/job.c\n+++ b/job.c\n@@ -54,7 +54,7 @@ rehash(int is_upscaling)\n     all_jobs_cap = primes[cur_prime];\n     all_jobs = calloc(all_jobs_cap, sizeof(Job *));\n     if (!all_jobs) {\n-        twarnx(\"Failed to allocate %zu new hash buckets\", all_jobs_cap);\n+        twarn(\"Failed to allocate %zu new hash buckets\", all_jobs_cap);\n         hash_table_was_oom = 1;\n         cur_prime = old_prime;\n         all_jobs = old;\n@@ -96,7 +96,7 @@ allocate_job(int body_size)\n \n     j = malloc(sizeof(Job) + body_size);\n     if (!j) {\n-        twarnx(\"OOM\");\n+        twarn(\"OOM\");\n         return (Job *) 0;\n     }\n \n@@ -115,7 +115,7 @@ make_job_with_id(uint32 pri, int64 delay, int64 ttr,\n     Job *j;\n \n     j = allocate_job(body_size);\n-    if (!j) return twarnx(\"OOM\"), (Job *) 0;\n+    if (!j) return twarn(\"OOM\"), (Job *) 0;\n \n     if (id) {\n         j->r.id = id;\n@@ -195,7 +195,7 @@ job_copy(Job *j)\n     if (!j) return NULL;\n \n     n = malloc(sizeof(Job) + j->r.body_size);\n-    if (!n) return twarnx(\"OOM\"), (Job *) 0;\n+    if (!n) return twarn(\"OOM\"), (Job *) 0;\n \n     memcpy(n, j, sizeof(Job) + j->r.body_size);\n     n->next = n->prev = n; /* not in a linked list */\n\ndiff --git a/linux.c b/linux.c\n--- a/linux.c\n+++ b/linux.c\n@@ -31,7 +31,7 @@ sockinit(void)\n {\n     epfd = epoll_create(1);\n     if (epfd == -1) {\n-        twarn(\"epoll_create\");\n+        twarnerr(\"epoll_create\");\n         return -1;\n     }\n     return 0;\n@@ -78,7 +78,7 @@ socknext(Socket **s, int64 timeout)\n \n     r = epoll_wait(epfd, &ev, 1, (int)(timeout/1000000));\n     if (r == -1 && errno != EINTR) {\n-        twarn(\"epoll_wait\");\n+        twarnerr(\"epoll_wait\");\n         exit(1);\n     }\n \n\ndiff --git a/main.c b/main.c\n--- a/main.c\n+++ b/main.c\n@@ -15,23 +15,23 @@ su(const char *user)\n     errno = 0;\n     struct passwd *pwent = getpwnam(user);\n     if (errno) {\n-        twarn(\"getpwnam(\\\"%s\\\")\", user);\n+        twarnerr(\"getpwnam(\\\"%s\\\")\", user);\n         exit(32);\n     }\n     if (!pwent) {\n-        twarnx(\"getpwnam(\\\"%s\\\"): no such user\", user);\n+        twarn(\"getpwnam(\\\"%s\\\"): no such user\", user);\n         exit(33);\n     }\n \n     int r = setgid(pwent->pw_gid);\n     if (r == -1) {\n-        twarn(\"setgid(%d \\\"%s\\\")\", pwent->pw_gid, user);\n+        twarnerr(\"setgid(%d \\\"%s\\\")\", pwent->pw_gid, user);\n         exit(34);\n     }\n \n     r = setuid(pwent->pw_uid);\n     if (r == -1) {\n-        twarn(\"setuid(%d \\\"%s\\\")\", pwent->pw_uid, user);\n+        twarnerr(\"setuid(%d \\\"%s\\\")\", pwent->pw_uid, user);\n         exit(34);\n     }\n }\n@@ -45,20 +45,20 @@ set_sig_handlers()\n     sa.sa_flags = 0;\n     int r = sigemptyset(&sa.sa_mask);\n     if (r == -1) {\n-        twarn(\"sigemptyset()\");\n+        twarnerr(\"sigemptyset()\");\n         exit(111);\n     }\n \n     r = sigaction(SIGPIPE, &sa, 0);\n     if (r == -1) {\n-        twarn(\"sigaction(SIGPIPE)\");\n+        twarnerr(\"sigaction(SIGPIPE)\");\n         exit(111);\n     }\n \n     sa.sa_handler = enter_drain_mode;\n     r = sigaction(SIGUSR1, &sa, 0);\n     if (r == -1) {\n-        twarn(\"sigaction(SIGUSR1)\");\n+        twarnerr(\"sigaction(SIGUSR1)\");\n         exit(111);\n     }\n }\n@@ -78,7 +78,7 @@ main(int argc, char **argv)\n \n     int r = make_server_socket(srv.addr, srv.port);\n     if (r == -1) {\n-        twarnx(\"make_server_socket()\");\n+        twarn(\"make_server_socket()\");\n         exit(111);\n     }\n \n@@ -95,7 +95,7 @@ main(int argc, char **argv)\n         // to use the wal directory at a time. So acquire a lock\n         // now and never release it.\n         if (!waldirlock(&srv.wal)) {\n-            twarnx(\"failed to lock wal dir %s\", srv.wal.dir);\n+            twarn(\"failed to lock wal dir %s\", srv.wal.dir);\n             exit(10);\n         }\n \n@@ -104,7 +104,7 @@ main(int argc, char **argv)\n         walinit(&srv.wal, &list);\n         r = prot_replay(&srv, &list);\n         if (!r) {\n-            twarnx(\"failed to replay log\");\n+            twarn(\"failed to replay log\");\n             exit(1);\n         }\n     }\n\ndiff --git a/net.c b/net.c\n--- a/net.c\n+++ b/net.c\n@@ -22,22 +22,22 @@ make_server_socket(char *host, char *port)\n      * return. */\n     r = sd_listen_fds(1);\n     if (r < 0) {\n-        return twarn(\"sd_listen_fds\"), -1;\n+        return twarnerr(\"sd_listen_fds\"), -1;\n     }\n     if (r > 0) {\n         if (r > 1) {\n-            twarnx(\"inherited more than one listen socket;\"\n+            twarn(\"inherited more than one listen socket;\"\n                    \" ignoring all but the first\");\n         }\n         fd = SD_LISTEN_FDS_START;\n         r = sd_is_socket_inet(fd, 0, SOCK_STREAM, 1, 0);\n         if (r < 0) {\n             errno = -r;\n-            twarn(\"sd_is_socket_inet\");\n+            twarnerr(\"sd_is_socket_inet\");\n             return -1;\n         }\n         if (!r) {\n-            twarnx(\"inherited fd is not a TCP listen socket\");\n+            twarn(\"inherited fd is not a TCP listen socket\");\n             return -1;\n         }\n         return fd;\n@@ -49,60 +49,60 @@ make_server_socket(char *host, char *port)\n     hints.ai_flags = AI_PASSIVE;\n     r = getaddrinfo(host, port, &hints, &airoot);\n     if (r != 0) {\n-      twarnx(\"getaddrinfo(): %s\", gai_strerror(r));\n+      twarn(\"getaddrinfo(): %s\", gai_strerror(r));\n       return -1;\n     }\n \n     for(ai = airoot; ai; ai = ai->ai_next) {\n       fd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n       if (fd == -1) {\n-        twarn(\"socket()\");\n+        twarnerr(\"socket()\");\n         continue;\n       }\n \n       flags = fcntl(fd, F_GETFL, 0);\n       if (flags < 0) {\n-        twarn(\"getting flags\");\n+        twarnerr(\"getting flags\");\n         close(fd);\n         continue;\n       }\n \n       r = fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n       if (r == -1) {\n-        twarn(\"setting O_NONBLOCK\");\n+        twarnerr(\"setting O_NONBLOCK\");\n         close(fd);\n         continue;\n       }\n \n       flags = 1;\n       r = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &flags, sizeof flags);\n       if (r == -1) {\n-        twarn(\"setting SO_REUSEADDR on fd %d\", fd);\n+        twarnerr(\"setting SO_REUSEADDR on fd %d\", fd);\n         close(fd);\n         continue;\n       }\n       r = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &flags, sizeof flags);\n       if (r == -1) {\n-        twarn(\"setting SO_KEEPALIVE on fd %d\", fd);\n+        twarnerr(\"setting SO_KEEPALIVE on fd %d\", fd);\n         close(fd);\n         continue;\n       }\n       r = setsockopt(fd, SOL_SOCKET, SO_LINGER, &linger, sizeof linger);\n       if (r == -1) {\n-        twarn(\"setting SO_LINGER on fd %d\", fd);\n+        twarnerr(\"setting SO_LINGER on fd %d\", fd);\n         close(fd);\n         continue;\n       }\n       r = setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flags, sizeof flags);\n       if (r == -1) {\n-        twarn(\"setting TCP_NODELAY on fd %d\", fd);\n+        twarnerr(\"setting TCP_NODELAY on fd %d\", fd);\n         close(fd);\n         continue;\n       }\n \n       r = bind(fd, ai->ai_addr, ai->ai_addrlen);\n       if (r == -1) {\n-        twarn(\"bind()\");\n+        twarnerr(\"bind()\");\n         close(fd);\n         continue;\n       }\n@@ -132,7 +132,7 @@ make_server_socket(char *host, char *port)\n \n       r = listen(fd, 1024);\n       if (r == -1) {\n-        twarn(\"listen()\");\n+        twarnerr(\"listen()\");\n         close(fd);\n         continue;\n       }\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -315,7 +315,7 @@ protrmdirty(Conn *c)\n \n #define reply_msg(c,m) reply((c),(m),CONSTSTRLEN(m),STATE_SENDWORD)\n \n-#define reply_serr(c,e) (twarnx(\"server error: %s\",(e)),\\\n+#define reply_serr(c,e) (twarn(\"server error: %s\",(e)),\\\n                          reply_msg((c),(e)))\n \n static void\n@@ -701,7 +701,7 @@ check_err(Conn *c, const char *s)\n     if (errno == EINTR) return;\n     if (errno == EWOULDBLOCK) return;\n \n-    twarn(\"%s\", s);\n+    twarnerr(\"%s\", s);\n     c->state = STATE_CLOSE;\n     return;\n }\n@@ -1269,7 +1269,7 @@ dispatch_cmd(Conn *c)\n         /* OOM? */\n         if (!c->in_job) {\n             /* throw away the job body and respond with OUT_OF_MEMORY */\n-            twarnx(\"server error: \" MSG_OUT_OF_MEMORY);\n+            twarn(\"server error: \" MSG_OUT_OF_MEMORY);\n             return skip(c, body_size + 2, MSG_OUT_OF_MEMORY);\n         }\n \n@@ -1852,7 +1852,7 @@ update_conns()\n         c->next = NULL;\n         r = sockwant(&c->sock, c->rw);\n         if (r == -1) {\n-            twarn(\"sockwant\");\n+            twarnerr(\"sockwant\");\n             connclose(c);\n         }\n     }\n@@ -1862,7 +1862,7 @@ static void\n h_conn(const int fd, const short which, Conn *c)\n {\n     if (fd != c->sock.fd) {\n-        twarnx(\"Argh! event fd doesn't match conn fd.\");\n+        twarn(\"Argh! event fd doesn't match conn fd.\");\n         close(fd);\n         connclose(c);\n         update_conns();\n@@ -1956,7 +1956,7 @@ h_accept(const int fd, const short which, Server *s)\n     socklen_t addrlen = sizeof addr;\n     int cfd = accept(fd, (struct sockaddr *)&addr, &addrlen);\n     if (cfd == -1) {\n-        if (errno != EAGAIN && errno != EWOULDBLOCK) twarn(\"accept()\");\n+        if (errno != EAGAIN && errno != EWOULDBLOCK) twarnerr(\"accept()\");\n         update_conns();\n         return;\n     }\n@@ -1966,7 +1966,7 @@ h_accept(const int fd, const short which, Server *s)\n \n     int flags = fcntl(cfd, F_GETFL, 0);\n     if (flags < 0) {\n-        twarn(\"getting flags\");\n+        twarnerr(\"getting flags\");\n         close(cfd);\n         if (verbose) {\n             printf(\"close %d\\n\", cfd);\n@@ -1977,7 +1977,7 @@ h_accept(const int fd, const short which, Server *s)\n \n     int r = fcntl(cfd, F_SETFL, flags | O_NONBLOCK);\n     if (r < 0) {\n-        twarn(\"setting O_NONBLOCK\");\n+        twarnerr(\"setting O_NONBLOCK\");\n         close(cfd);\n         if (verbose) {\n             printf(\"close %d\\n\", cfd);\n@@ -1988,7 +1988,7 @@ h_accept(const int fd, const short which, Server *s)\n \n     Conn *c = make_conn(cfd, STATE_WANTCOMMAND, default_tube, default_tube);\n     if (!c) {\n-        twarnx(\"make_conn() failed\");\n+        twarn(\"make_conn() failed\");\n         close(cfd);\n         if (verbose) {\n             printf(\"close %d\\n\", cfd);\n@@ -2003,7 +2003,7 @@ h_accept(const int fd, const short which, Server *s)\n \n     r = sockwant(&c->sock, 'r');\n     if (r == -1) {\n-        twarn(\"sockwant\");\n+        twarnerr(\"sockwant\");\n         close(cfd);\n         if (verbose) {\n             printf(\"close %d\\n\", cfd);\n@@ -2022,15 +2022,15 @@ prot_init()\n \n     int dev_random = open(\"/dev/urandom\", O_RDONLY);\n     if (dev_random < 0) {\n-        twarn(\"open /dev/urandom\");\n+        twarnerr(\"open /dev/urandom\");\n         exit(50);\n     }\n \n     int i, r;\n     byte rand_data[NumIdBytes];\n     r = read(dev_random, &rand_data, NumIdBytes);\n     if (r != NumIdBytes) {\n-        twarn(\"read /dev/urandom\");\n+        twarnerr(\"read /dev/urandom\");\n         exit(50);\n     }\n     for (i = 0; i < NumIdBytes; i++) {\n@@ -2039,14 +2039,14 @@ prot_init()\n     close(dev_random);\n \n     if (uname(&node_info) == -1) {\n-        warn(\"uname\");\n+        twarn(\"uname\");\n         exit(50);\n     }\n \n     ms_init(&tubes, NULL, NULL);\n \n     TUBE_ASSIGN(default_tube, tube_find_or_make(\"default\"));\n-    if (!default_tube) twarnx(\"Out of memory during startup!\");\n+    if (!default_tube) twarn(\"Out of memory during startup!\");\n }\n \n // For each job in list, inserts the job into the appropriate data\n@@ -2065,7 +2065,7 @@ prot_replay(Server *s, Job *list)\n         job_remove(j);\n         z = walresvupdate(&s->wal);\n         if (!z) {\n-            twarnx(\"failed to reserve space\");\n+            twarn(\"failed to reserve space\");\n             return 0;\n         }\n         delay = 0;\n@@ -2081,7 +2081,7 @@ prot_replay(Server *s, Job *list)\n             /* fall through */\n         default:\n             r = enqueue_job(s, j, delay, 0);\n-            if (r < 1) twarnx(\"error recovering job %\"PRIu64, j->r.id);\n+            if (r < 1) twarn(\"error recovering job %\"PRIu64, j->r.id);\n         }\n     }\n     return 1;\n\ndiff --git a/serv.c b/serv.c\n--- a/serv.c\n+++ b/serv.c\n@@ -19,7 +19,7 @@ srvserve(Server *s)\n     int64 period;\n \n     if (sockinit() == -1) {\n-        twarnx(\"sockinit\");\n+        twarn(\"sockinit\");\n         exit(1);\n     }\n \n@@ -30,13 +30,13 @@ srvserve(Server *s)\n \n     r = listen(s->sock.fd, 1024);\n     if (r == -1) {\n-        twarn(\"listen\");\n+        twarnerr(\"listen\");\n         return;\n     }\n \n     r = sockwant(&s->sock, 'r');\n     if (r == -1) {\n-        twarn(\"sockwant\");\n+        twarnerr(\"sockwant\");\n         exit(2);\n     }\n \n@@ -46,7 +46,7 @@ srvserve(Server *s)\n \n         int rw = socknext(&sock, period);\n         if (rw == -1) {\n-            twarnx(\"socknext\");\n+            twarn(\"socknext\");\n             exit(1);\n         }\n \n\ndiff --git a/sunos.c b/sunos.c\n--- a/sunos.c\n+++ b/sunos.c\n@@ -35,7 +35,7 @@ sockinit(void)\n {\n     portfd = port_create();\n     if (portfd == -1) {\n-        twarn(\"port_create\");\n+        twarnerr(\"port_create\");\n         return -1;\n     }\n     return 0;\n@@ -86,7 +86,7 @@ socknext(Socket **s, int64 timeout)\n     ts.tv_nsec = timeout % 1000000000;\n     r = port_getn(portfd, &pe, 1, &n, &ts);\n     if (r == -1 && errno != ETIME && errno != EINTR) {\n-        twarn(\"port_getn\");\n+        twarnerr(\"port_getn\");\n         return -1;\n     }\n \n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -47,7 +47,7 @@ muststart(char *a0, char *a1, char *a2, char *a3, char *a4)\n {\n     srvpid = fork();\n     if (srvpid < 0) {\n-        twarn(\"fork\");\n+        twarnerr(\"fork\");\n         exit(1);\n     }\n \n@@ -74,26 +74,26 @@ mustdiallocal(int port)\n     int r = inet_aton(\"127.0.0.1\", &addr.sin_addr);\n     if (!r) {\n         errno = EINVAL;\n-        twarn(\"inet_aton\");\n+        twarnerr(\"inet_aton\");\n         exit(1);\n     }\n \n     int fd = socket(AF_INET, SOCK_STREAM, 0);\n     if (fd == -1) {\n-        twarn(\"socket\");\n+        twarnerr(\"socket\");\n         exit(1);\n     }\n \n     // Fix of the benchmarking issue on Linux. See issue #430.\n     int flags = 1;\n     if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flags, sizeof(int))) {\n-        twarn(\"setting TCP_NODELAY on fd %d\", fd);\n+        twarnerr(\"setting TCP_NODELAY on fd %d\", fd);\n         exit(1);\n     }\n \n     r = connect(fd, (struct sockaddr *)&addr, sizeof addr);\n     if (r == -1) {\n-        twarn(\"connect\");\n+        twarnerr(\"connect\");\n         exit(1);\n     }\n \n@@ -115,15 +115,15 @@ set_sig_handler()\n     sa.sa_flags = 0;\n     int r = sigemptyset(&sa.sa_mask);\n     if (r == -1) {\n-        twarn(\"sigemptyset()\");\n+        twarnerr(\"sigemptyset()\");\n         exit(111);\n     }\n \n     // This is required to trigger gcov on exit. See issue #443.\n     sa.sa_handler = exit_process;\n     r = sigaction(SIGTERM, &sa, 0);\n     if (r == -1) {\n-        twarn(\"sigaction(SIGTERM)\");\n+        twarnerr(\"sigaction(SIGTERM)\");\n         exit(111);\n     }\n }\n@@ -167,7 +167,7 @@ mustforksrv(void)\n     int port = ntohs(addr.sin_port);\n     srvpid = fork();\n     if (srvpid < 0) {\n-        twarn(\"fork\");\n+        twarnerr(\"fork\");\n         exit(1);\n     }\n \n@@ -188,7 +188,7 @@ mustforksrv(void)\n         // to use the wal directory at a time. So acquire a lock\n         // now and never release it.\n         if (!waldirlock(&srv.wal)) {\n-            twarnx(\"failed to lock wal dir %s\", srv.wal.dir);\n+            twarn(\"failed to lock wal dir %s\", srv.wal.dir);\n             exit(10);\n         }\n \n@@ -200,7 +200,7 @@ mustforksrv(void)\n         walinit(&srv.wal, &list);\n         int ok = prot_replay(&srv, &list);\n         if (!ok) {\n-            twarnx(\"failed to replay log\");\n+            twarn(\"failed to replay log\");\n             exit(11);\n         }\n     }\n@@ -307,7 +307,7 @@ filesize(char *path)\n \n     int r = stat(path, &s);\n     if (r == -1) {\n-        twarn(\"stat\");\n+        twarnerr(\"stat\");\n         exit(1);\n     }\n     return s.st_size;\n\ndiff --git a/time.c b/time.c\n--- a/time.c\n+++ b/time.c\n@@ -10,7 +10,7 @@ nanoseconds(void)\n     struct timeval tv;\n \n     r = gettimeofday(&tv, 0);\n-    if (r != 0) return warnx(\"gettimeofday\"), -1; // can't happen\n+    if (r != 0) return warn(\"gettimeofday\"), -1; // can't happen\n \n     return ((int64)tv.tv_sec)*1000000000 + ((int64)tv.tv_usec)*1000;\n }\n\ndiff --git a/tube.c b/tube.c\n--- a/tube.c\n+++ b/tube.c\n@@ -16,7 +16,7 @@ make_tube(const char *name)\n     t->name[MAX_TUBE_NAME_LEN - 1] = '\\0';\n     strncpy(t->name, name, MAX_TUBE_NAME_LEN - 1);\n     if (t->name[MAX_TUBE_NAME_LEN - 1] != '\\0')\n-        twarnx(\"truncating tube name\");\n+        twarn(\"truncating tube name\");\n \n     t->ready.less = job_pri_less;\n     t->delay.less = job_delay_less;\n@@ -46,7 +46,7 @@ tube_dref(Tube *t)\n {\n     if (!t) return;\n     if (t->refs < 1)\n-        return twarnx(\"refs is zero for tube: %s\", t->name);\n+        return twarn(\"refs is zero for tube: %s\", t->name);\n \n     --t->refs;\n     if (t->refs < 1)\n\ndiff --git a/util.c b/util.c\n--- a/util.c\n+++ b/util.c\n@@ -10,37 +10,40 @@\n const char *progname;\n \n static void\n-vwarnx(const char *err, const char *fmt, va_list args)\n+_warnerr(const char *err, const char *fmt, va_list args)\n __attribute__((format(printf, 2, 0)));\n \n+// _warnerr prints formatted text prefixed by progname into stderr.\n+// If err is not NULL, it is printed at last.\n static void\n-vwarnx(const char *err, const char *fmt, va_list args)\n+_warnerr(const char *err, const char *fmt, va_list args)\n {\n     fprintf(stderr, \"%s: \", progname);\n     if (fmt) {\n         vfprintf(stderr, fmt, args);\n-        if (err) fprintf(stderr, \": %s\", err);\n+        if (err)\n+            fprintf(stderr, \": %s\", err);\n     }\n     fputc('\\n', stderr);\n }\n \n void\n-warn(const char *fmt, ...)\n+warnerr(const char *fmt, ...)\n {\n     char *err = strerror(errno); /* must be done first thing */\n     va_list args;\n \n     va_start(args, fmt);\n-    vwarnx(err, fmt, args);\n+    _warnerr(err, fmt, args);\n     va_end(args);\n }\n \n void\n-warnx(const char *fmt, ...)\n+warn(const char *fmt, ...)\n {\n     va_list args;\n     va_start(args, fmt);\n-    vwarnx(NULL, fmt, args);\n+    _warnerr(NULL, fmt, args);\n     va_end(args);\n }\n \n@@ -87,7 +90,7 @@ static void\n warn_systemd_ignored_option(char *opt, char *arg)\n {\n     if (sd_listen_fds(0) > 0) {\n-        warnx(\"inherited listen fd; ignoring option: %s %s\", opt, arg);\n+        warn(\"inherited listen fd; ignoring option: %s %s\", opt, arg);\n     }\n }\n \n@@ -126,7 +129,7 @@ static char *flagusage(char *flag) __attribute__ ((noreturn));\n static char *\n flagusage(char *flag)\n {\n-    warnx(\"flag requires an argument: %s\", flag);\n+    warn(\"flag requires an argument: %s\", flag);\n     usage(5);\n }\n \n@@ -139,7 +142,7 @@ parse_size_t(char *str)\n \n     r = sscanf(str, \"%zu%c\", &size, &x);\n     if (1 != r) {\n-        warnx(\"invalid size: %s\", str);\n+        warn(\"invalid size: %s\", str);\n         usage(5);\n     }\n     return size;\n@@ -167,7 +170,7 @@ optparse(Server *s, char **argv)\n                 case 'z':\n                     job_data_size_limit = parse_size_t(EARGF(flagusage(\"-z\")));\n                     if (job_data_size_limit > JOB_DATA_SIZE_LIMIT_MAX) {\n-                        warnx(\"maximum job size was set to %d\", JOB_DATA_SIZE_LIMIT_MAX);\n+                        warn(\"maximum job size was set to %d\", JOB_DATA_SIZE_LIMIT_MAX);\n                         job_data_size_limit = JOB_DATA_SIZE_LIMIT_MAX;\n                     }\n                     break;\n@@ -204,13 +207,13 @@ optparse(Server *s, char **argv)\n                     verbose++;\n                     break;\n                 default:\n-                    warnx(\"unknown flag: %s\", arg-2);\n+                    warn(\"unknown flag: %s\", arg-2);\n                     usage(5);\n             }\n         }\n     }\n     if (arg) {\n-        warnx(\"unknown argument: %s\", arg-1);\n+        warn(\"unknown argument: %s\", arg-1);\n         usage(5);\n     }\n }\n\ndiff --git a/walg.c b/walg.c\n--- a/walg.c\n+++ b/walg.c\n@@ -78,7 +78,7 @@ usenext(Wal *w)\n \n     f = w->cur;\n     if (!f->next) {\n-        twarnx(\"there is no next wal file\");\n+        twarn(\"there is no next wal file\");\n         return 0;\n     }\n \n@@ -130,7 +130,7 @@ moveone(Wal *w)\n     j = w->head->jlist.fnext;\n     if (!j || j == &w->head->jlist) {\n         // head holds no jlist; can't happen\n-        twarnx(\"head holds no jlist\");\n+        twarn(\"head holds no jlist\");\n         return;\n     }\n \n@@ -165,7 +165,7 @@ walsync(Wal *w)\n     if (w->wantsync && now >= w->lastsync+w->syncrate) {\n         w->lastsync = now;\n         if (fsync(w->cur->fd) == -1) {\n-            twarn(\"fsync\");\n+            twarnerr(\"fsync\");\n         }\n     }\n }\n@@ -216,13 +216,13 @@ makenextfile(Wal *w)\n \n     f = new(File);\n     if (!f) {\n-        twarnx(\"OOM\");\n+        twarn(\"OOM\");\n         return 0;\n     }\n \n     if (!fileinit(f, w, w->next)) {\n         free(f);\n-        twarnx(\"OOM\");\n+        twarn(\"OOM\");\n         return 0;\n     }\n \n@@ -286,7 +286,7 @@ balancerest(Wal *w, File *b, int n)\n     }\n \n     if (needfree(w, r) != r) {\n-        twarnx(\"needfree\");\n+        twarn(\"needfree\");\n         return 0;\n     }\n     moveresv(w->tail, b, r);\n@@ -316,7 +316,7 @@ balance(Wal *w, int n)\n \n         r = needfree(w, m);\n         if (r != m) {\n-            twarnx(\"needfree\");\n+            twarn(\"needfree\");\n             return 0;\n         }\n \n@@ -347,7 +347,7 @@ reserve(Wal *w, int n)\n \n     r = needfree(w, n);\n     if (r != n) {\n-        twarnx(\"needfree\");\n+        twarn(\"needfree\");\n         return 0;\n     }\n \n@@ -409,15 +409,15 @@ waldirlock(Wal *w)\n \n     path_length = strlen(w->dir) + strlen(\"/lock\") + 1;\n     if ((path = malloc(path_length)) == NULL) {\n-        twarn(\"malloc\");\n+        twarnerr(\"malloc\");\n         return 0;\n     }\n     r = snprintf(path, path_length, \"%s/lock\", w->dir);\n \n     fd = open(path, O_WRONLY|O_CREAT, 0600);\n     free(path);\n     if (fd == -1) {\n-        twarn(\"open\");\n+        twarnerr(\"open\");\n         return 0;\n     }\n \n@@ -427,7 +427,7 @@ waldirlock(Wal *w)\n     lk.l_len = 0;\n     r = fcntl(fd, F_SETLK, &lk);\n     if (r) {\n-        twarn(\"fcntl\");\n+        twarnerr(\"fcntl\");\n         return 0;\n     }\n \n@@ -447,19 +447,19 @@ walread(Wal *w, Job *list, int min)\n     for (i = min; i < w->next; i++) {\n         f = new(File);\n         if (!f) {\n-            twarnx(\"OOM\");\n+            twarn(\"OOM\");\n             exit(1);\n         }\n \n         if (!fileinit(f, w, i)) {\n             free(f);\n-            twarnx(\"OOM\");\n+            twarn(\"OOM\");\n             exit(1);\n         }\n \n         fd = open(f->path, O_RDONLY);\n         if (fd < 0) {\n-            twarn(\"open %s\", f->path);\n+            twarnerr(\"open %s\", f->path);\n             free(f->path);\n             free(f);\n             continue;\n@@ -472,8 +472,8 @@ walread(Wal *w, Job *list, int min)\n     }\n \n     if (err) {\n-        warnx(\"Errors reading one or more WAL files.\");\n-        warnx(\"Continuing. You may be missing data.\");\n+        warn(\"Errors reading one or more WAL files.\");\n+        warn(\"Continuing. You may be missing data.\");\n     }\n }\n \n@@ -488,7 +488,7 @@ walinit(Wal *w, Job *list)\n \n     // first writable file\n     if (!makenextfile(w)) {\n-        twarnx(\"makenextfile\");\n+        twarn(\"makenextfile\");\n         exit(1);\n     }\n \n", "test_patch": "", "problem_statement": "make names of warn* functions and macros consistent\ntwarn* macros and warn* functions names are now consistent.\r\n\r\n-err suffix means that the function uses errno to print error message.\r\nno suffix means that the function ignores errno.\r\n\r\nUpdates #488", "version": "1.11", "language": "C", "created_at": "2019-07-29T08:38:01Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-530", "repo": "beanstalkd/beanstalkd", "pull_number": 530, "base_commit": "980f841c0f1b26c5c5f77e47585701c86c52cb4b", "patch": "diff --git a/file.c b/file.c\n--- a/file.c\n+++ b/file.c\n@@ -450,7 +450,8 @@ filewopen(File *f)\n \n     r = falloc(fd, f->w->filesize);\n     if (r) {\n-        close(fd);\n+        if (close(fd) == -1)\n+            twarn(\"close\");\n         errno = r;\n         twarn(\"falloc %s\", f->path);\n         r = unlink(f->path);\n@@ -463,7 +464,8 @@ filewopen(File *f)\n     n = write(fd, &ver, sizeof(int));\n     if (n < 0 || (size_t)n < sizeof(int)) {\n         twarn(\"write %s\", f->path);\n-        close(fd);\n+        if (close(fd) == -1)\n+            twarn(\"close\");\n         return;\n     }\n \n@@ -539,7 +541,8 @@ filewclose(File *f)\n             twarn(\"ftruncate\");\n         }\n     }\n-    close(f->fd);\n+    if (close(f->fd) == -1)\n+        twarn(\"close\");\n     f->iswopen = 0;\n     filedecref(f);\n }\n\ndiff --git a/walg.c b/walg.c\n--- a/walg.c\n+++ b/walg.c\n@@ -465,7 +465,8 @@ walread(Wal *w, Job *list, int min)\n         f->fd = fd;\n         fileadd(f, w);\n         err |= fileread(f, list);\n-        close(fd);\n+        if (close(fd) == -1)\n+            twarn(\"close\");\n     }\n \n     if (err) {\n", "test_patch": "", "problem_statement": "bracket with error-checking all the calls to close() on files\nclose() on a file can fail.", "version": "1.11", "language": "C", "created_at": "2019-08-07T09:22:46Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-516", "repo": "beanstalkd/beanstalkd", "pull_number": 516, "base_commit": "c76ae728f5bcb6ae096b7b7a80d638cfa5eef933", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -231,10 +231,23 @@ struct Tube {\n };\n \n \n-#define twarn(fmt, args...) warn(\"%s:%d in %s: \" fmt, \\\n-                                 __FILE__, __LINE__, __func__, ##args)\n-#define twarnx(fmt, args...) warnx(\"%s:%d in %s: \" fmt, \\\n-                                   __FILE__, __LINE__, __func__, ##args)\n+// Prints warning message on stderr in the format:\n+// <progname>: FILE:LINE in FUNC: <fmt>: <errno_msg>\n+#define twarn(...) __twarn(__VA_ARGS__, \"\")\n+\n+// Hack to quiet the compiler. When VA_ARGS in twarn() has one element,\n+// e.g. twarn(\"OOM\"), its replaced with __twarn(\"OOM\", \"\"),\n+// thus VA_ARGS is expanded to at least one element in warn().\n+#define __twarn(fmt, ...) \\\n+    warn(\"%s:%d in %s: \" fmt \"%s\", __FILE__, __LINE__, __func__, __VA_ARGS__)\n+\n+// Prints warning message on stderr in the format:\n+// <progname>: FILE:LINE in FUNC: <fmt>\n+#define twarnx(...) __twarnx(__VA_ARGS__, \"\")\n+\n+// See __twarn macro.\n+#define __twarnx(fmt, ...) \\\n+    warnx(\"%s:%d in %s: \" fmt \"%s\", __FILE__, __LINE__, __func__, __VA_ARGS__)\n \n void warn(const char *fmt, ...) __attribute__((format(printf, 1, 2)));\n void warnx(const char *fmt, ...) __attribute__((format(printf, 1, 2)));\n@@ -248,7 +261,9 @@ extern const char *progname;\n int64 nanoseconds(void);\n int   rawfalloc(int fd, int len);\n \n-#define make_job(pri,delay,ttr,body_size,tube) make_job_with_id(pri,delay,ttr,body_size,tube,0)\n+// Take ID for a jobs from next_id and allocate and store the job.\n+#define make_job(pri,delay,ttr,body_size,tube) \\\n+    make_job_with_id(pri,delay,ttr,body_size,tube,0)\n \n Job *allocate_job(int body_size);\n Job *make_job_with_id(uint pri, int64 delay, int64 ttr,\n", "test_patch": "", "problem_statement": "make VA_ARGS contain at least one element in twarn* macros\nThis is a bit hacky, but this makes code compile in pedantic mode.\r\nIt's the shorted solution to the problem so far.\r\n\r\nFixes #488", "version": "1.11", "language": "C", "created_at": "2019-07-30T14:05:26Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-532", "repo": "beanstalkd/beanstalkd", "pull_number": 532, "base_commit": "de06a3232b07c437d40a83bd0d92fb25016b0763", "patch": "diff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -1676,8 +1676,17 @@ cttest_binlog_v5()\n }\n \n static void\n-bench_put_delete_size(int n, int size)\n-{\n+bench_put_delete_size(int n, int size, int walsize, int sync, int64 syncrate_ms)\n+{\n+    if (walsize > 0) {\n+        srv.wal.dir = ctdir();\n+        srv.wal.use = 1;\n+        srv.wal.filesize = walsize;\n+        srv.wal.syncrate = syncrate_ms * 1000000;\n+        srv.wal.wantsync = sync;\n+    }\n+\n+    job_data_size_limit = JOB_DATA_SIZE_LIMIT_MAX;\n     int port = SERVER();\n     int fd = mustdiallocal(port);\n     char buf[50], put[50];\n@@ -1701,25 +1710,73 @@ bench_put_delete_size(int n, int size)\n }\n \n void\n-ctbench_put_delete_8(int n)\n+ctbench_put_delete_0008(int n)\n+{\n+    bench_put_delete_size(n, 8, 0, 0, 0);\n+}\n+\n+void\n+ctbench_put_delete_1024(int n)\n+{\n+    bench_put_delete_size(n, 1024, 0, 0, 0);\n+}\n+\n+void\n+ctbench_put_delete_8192(int n)\n+{\n+    bench_put_delete_size(n, 8192, 0, 0, 0);\n+}\n+\n+void\n+ctbench_put_delete_81920(int n)\n+{\n+    bench_put_delete_size(n, 81920, 0, 0, 0);\n+}\n+\n+void\n+ctbench_put_delete_wal_1024_fsync_000ms(int n)\n+{\n+    bench_put_delete_size(n, 1024, 512000, 1, 0);\n+}\n+\n+void\n+ctbench_put_delete_wal_1024_fsync_050ms(int n)\n+{\n+    bench_put_delete_size(n, 1024, 512000, 1, 100);\n+}\n+\n+void\n+ctbench_put_delete_wal_1024_fsync_200ms(int n)\n+{\n+    bench_put_delete_size(n, 1024, 512000, 1, 500);\n+}\n+\n+void\n+ctbench_put_delete_wal_1024_no_fsync(int n)\n+{\n+    bench_put_delete_size(n, 1024, 512000, 0, 0);\n+}\n+\n+void\n+ctbench_put_delete_wal_8192_fsync_000ms(int n)\n {\n-    bench_put_delete_size(n, 8);\n+    bench_put_delete_size(n, 8192, 512000, 1, 0);\n }\n \n void\n-ctbench_put_delete_1k(int n)\n+ctbench_put_delete_wal_8192_fsync_050ms(int n)\n {\n-    bench_put_delete_size(n, 1024);\n+    bench_put_delete_size(n, 8192, 512000, 1, 100);\n }\n \n void\n-ctbench_put_delete_8k(int n)\n+ctbench_put_delete_wal_8192_fsync_200ms(int n)\n {\n-    bench_put_delete_size(n, 8192);\n+    bench_put_delete_size(n, 8192, 512000, 1, 500);\n }\n \n void\n-ctbench_put_delete_64k(int n)\n+ctbench_put_delete_wal_8192_no_fsync(int n)\n {\n-    bench_put_delete_size(n, 65535);\n+    bench_put_delete_size(n, 8192, 512000, 0, 0);\n }\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -10,6 +10,7 @@\n #include <sys/types.h>\n #include <sys/socket.h>\n #include <sys/select.h>\n+#include <sys/un.h>\n #include <netdb.h>\n #include <netinet/in.h>\n #include <netinet/ip.h>\n@@ -30,6 +31,15 @@ static int64 timeout = 5000000000LL;\n static byte fallocpat[3];\n \n \n+static int\n+exist(char *path)\n+{\n+    struct stat s;\n+\n+    int r = stat(path, &s);\n+    return r != -1;\n+}\n+\n static int\n wrapfalloc(int fd, int size)\n {\n@@ -100,6 +110,29 @@ mustdiallocal(int port)\n     return fd;\n }\n \n+static int\n+mustdialunix(char *socket_file)\n+{\n+    struct sockaddr_un addr;\n+    const size_t maxlen = sizeof(addr.sun_path);\n+    addr.sun_family = AF_UNIX;\n+    snprintf(addr.sun_path, maxlen, \"%s\", socket_file);\n+\n+    int fd = socket(AF_UNIX, SOCK_STREAM, 0);\n+    if (fd == -1) {\n+        twarn(\"socket\");\n+        exit(1);\n+    }\n+\n+    int r = connect(fd, (struct sockaddr *)&addr, sizeof addr);\n+    if (r == -1) {\n+        twarn(\"connect\");\n+        exit(1);\n+    }\n+\n+    return fd;\n+}\n+\n static void\n exit_process(int signum)\n {\n@@ -142,6 +175,7 @@ kill_srvpid(void)\n }\n \n #define SERVER() (progname=__func__, mustforksrv())\n+#define SERVER_UNIX() (progname=__func__, mustforksrv_unix())\n \n // Forks the server storing the pid in srvpid.\n // The parent process returns port assigned.\n@@ -183,28 +217,46 @@ mustforksrv(void)\n     set_sig_handler();\n     prot_init();\n \n-    if (srv.wal.use) {\n-        // We want to make sure that only one beanstalkd tries\n-        // to use the wal directory at a time. So acquire a lock\n-        // now and never release it.\n-        if (!waldirlock(&srv.wal)) {\n-            twarnx(\"failed to lock wal dir %s\", srv.wal.dir);\n-            exit(10);\n-        }\n+    srv_acquire_wal(&srv);\n \n-        Job list = {\n-            .prev = NULL,\n-            .next = NULL,\n-        };\n-        list.prev = list.next = &list;\n-        walinit(&srv.wal, &list);\n-        int ok = prot_replay(&srv, &list);\n-        if (!ok) {\n-            twarnx(\"failed to replay log\");\n-            exit(11);\n-        }\n+    srvserve(&srv); /* does not return */\n+    exit(1); /* satisfy the compiler */\n+}\n+\n+static char *\n+mustforksrv_unix(void)\n+{\n+    static char path[90];\n+    char name[95];\n+    snprintf(path, sizeof(path), \"%s/socket\", ctdir());\n+    snprintf(name, sizeof(name), \"unix:%s\", path);\n+    srv.sock.fd = make_server_socket(name, NULL);\n+    if (srv.sock.fd == -1) {\n+        puts(\"mustforksrv_unix failed\");\n+        exit(1);\n+    }\n+\n+    srvpid = fork();\n+    if (srvpid < 0) {\n+        twarn(\"fork\");\n+        exit(1);\n+    }\n+\n+    if (srvpid > 0) {\n+        // On exit the parent (test) sends SIGTERM to the child.\n+        atexit(kill_srvpid);\n+        printf(\"start server socket=%s\\n\", path);\n+        assert(exist(path));\n+        return path;\n     }\n \n+    /* now in child */\n+\n+    set_sig_handler();\n+    prot_init();\n+\n+    srv_acquire_wal(&srv);\n+\n     srvserve(&srv); /* does not return */\n     exit(1); /* satisfy the compiler */\n }\n@@ -313,15 +365,6 @@ filesize(char *path)\n     return s.st_size;\n }\n \n-static int\n-exist(char *path)\n-{\n-    struct stat s;\n-\n-    int r = stat(path, &s);\n-    return r != -1;\n-}\n-\n void\n cttest_unknown_command()\n {\n@@ -383,6 +426,31 @@ cttest_peek_not_found()\n     ckresp(fd, \"NOT_FOUND\\r\\n\");\n }\n \n+void\n+cttest_peek_ok_unix()\n+{\n+    char *name = SERVER_UNIX();\n+    int fd = mustdialunix(name);\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"a\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+\n+    mustsend(fd, \"peek 1\\r\\n\");\n+    ckresp(fd, \"FOUND 1 1\\r\\n\");\n+    ckresp(fd, \"a\\r\\n\");\n+\n+    unlink(name);\n+}\n+\n+void\n+cttest_unix_auto_removal()\n+{\n+    // Twice, to trigger autoremoval\n+    SERVER_UNIX();\n+    kill_srvpid();\n+    SERVER_UNIX();\n+}\n+\n void\n cttest_peek_bad_format()\n {\n", "test_patch": "", "problem_statement": "add benchmarks for the fsync option turned on\nThe walsize does not affect benchmarks on MacOS, so it was\r\nset to arbitrary value of ~512k.", "version": "1.11", "language": "C", "created_at": "2019-08-08T08:23:34Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-497", "repo": "beanstalkd/beanstalkd", "pull_number": 497, "base_commit": "a6beb7b056e751b8920919c5427ed951466f45d7", "patch": "diff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -28,7 +28,7 @@ env:\n         - COVERAGE=OFF # Currently works only with gcc on linux\n \n before_script:\n-    - if [ \"${TRAVIS_OS_NAME}-${TRAVIS_COMPILER}\" = \"linux-gcc\" ]; then export COVERAGE=\"ON\"; fi\n+    - '[[ \"${TRAVIS_OS_NAME}-${TRAVIS_COMPILER}\" != \"linux-gcc\" ]] || export COVERAGE=\"ON\"'\n \n script:\n     - |\n@@ -37,26 +37,6 @@ script:\n           export CFLAGS=\"-O0 -ggdb -fprofile-arcs -ftest-coverage\"\n       fi\n     - make $MAKEJOBS || ( echo \"Build failure. Verbose build follows.\" && make V=1 ; false )\n-    - |\n-      if [ $COVERAGE = \"ON\" ]; then\n-          # Reset all execution counts to zero\n-          lcov \\\n-              --quiet \\\n-              --directory . \\\n-              --base-directory=$(pwd) \\\n-              --compat-libtool \\\n-              --zerocounters\n-\n-         # Capture coverage data\n-         lcov \\\n-             --quiet \\\n-              --directory . \\\n-              --base-directory=$(pwd) \\\n-              --capture \\\n-              --initial \\\n-              --compat-libtool \\\n-              --output-file $(pwd)/lcov.info\n-      fi\n     - make check -j1 VERBOSE=1\n \n jobs:\n@@ -99,33 +79,7 @@ jobs:\n           - make $MAKEJOBS bench\n \n after_success:\n-    - |\n-      if [ $COVERAGE = \"ON\" ]; then\n-          # Capture coverage data\n-          lcov \\\n-              --quiet \\\n-              --directory . \\\n-              --base-directory=$(pwd) \\\n-              --no-checksum \\\n-              --capture \\\n-              --compat-libtool \\\n-              --output-file $(pwd)/lcov.info\n-\n-          # Remove files matching exclude patterns\n-          lcov \\\n-              --quiet \\\n-              --remove $(pwd)/lcov.info \"ct/*\" \\\n-              --remove $(pwd)/lcov.info \"adm/*\" \\\n-              --remove $(pwd)/lcov.info \"pkg/*\" \\\n-              --remove $(pwd)/lcov.info \"test*.c\" \\\n-              --compat-libtool \\\n-              --output-file $(pwd)/lcov.info\n-\n-          # Run codecov\n-          curl -sSl https://codecov.io/bash -o ./codecov\n-          chmod +x ./codecov\n-          ./codecov -f $(pwd)/lcov.info\n-      fi\n+    - '[[ \"$COVERAGE\" != \"ON\" ]] || bash <(curl -s https://codecov.io/bash)'\n \n after_script:\n     - printf \"$TRAVIS_COMMIT_RANGE\\n\"\n\ndiff --git a/.codecov.yml b/.codecov.yml\n--- a/.codecov.yml\n+++ b/.codecov.yml\n@@ -24,3 +24,7 @@ comment:\n   layout: \"header, diff\"\n   behavior: default\n   require_changes: no\n+\n+ignore:\n+  - \"test*.c\"\n+  - \"ct\"\n\ndiff --git a/.codecov.yml b/.codecov.yml\n--- a/.codecov.yml\n+++ b/.codecov.yml\n@@ -26,5 +26,9 @@ comment:\n   require_changes: no\n \n ignore:\n+  # ignore files using wildcards\n   - \"test*.c\"\n-  - \"ct\"\n+  # ignore folders and all its contents\n+  - \"ct/.*\"\n+  - \"adm/.*\"\n+  - \"pkg/.*\"\n", "test_patch": "", "problem_statement": "move ignored coverage files from .travis.yml to .codecov.yml\n- [x] Symplify Travis CI configuration\r\n- [x] Move code coverage settings from .travis.yml to .codecov.yml\r\n- [x] Use codecov util only and do not call lcov\r\n- [x] Improve codecov configuration\r\n\r\n---\r\n\r\nResolves #483", "version": "1.11", "language": "C", "created_at": "2019-07-26T16:31:36Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-554", "repo": "beanstalkd/beanstalkd", "pull_number": 554, "base_commit": "7002f6b99282f1c8571cb7933d8128526f409f55", "patch": "diff --git a/darwin.c b/darwin.c\n--- a/darwin.c\n+++ b/darwin.c\n@@ -14,26 +14,6 @@ enum\n };\n \n static int  kq;\n-static char buf0[512]; /* buffer of zeros */\n-\n-\n-/* Allocate disk space.\n- * Expects fd's offset to be 0; may also reset fd's offset to 0.\n- * Returns 0 on success, and a positive errno otherwise. */\n-int\n-rawfalloc(int fd, int len)\n-{\n-    int i, w;\n-\n-    for (i = 0; i < len; i += w) {\n-        w = write(fd, buf0, sizeof buf0);\n-        if (w == -1) return errno;\n-    }\n-\n-    lseek(fd, 0, 0); /* do not care if this fails */\n-\n-    return 0;\n-}\n \n \n int\n\ndiff --git a/file.c b/file.c\n--- a/file.c\n+++ b/file.c\n@@ -50,6 +50,27 @@ enum\n \tJobrec5size = offsetof(Jobrec5, pad)\n };\n \n+// rawfalloc allocates disk space of len bytes.\n+// It expects fd's offset to be 0; may also reset fd's offset to 0.\n+// Returns 0 on success, and a positive errno otherwise.\n+int\n+rawfalloc(int fd, int len)\n+{\n+    // We do not use ftruncate() because it might extend the file\n+    // with a sequence of null bytes or a hole.\n+    // posix_fallocate() is not portable enough, might fail for NFS.\n+    static char buf[4096] = {0};\n+    int i, w;\n+\n+    for (i = 0; i < len; i += w) {\n+        w = write(fd, buf, sizeof buf);\n+        if (w == -1)\n+            return errno;\n+    }\n+    lseek(fd, 0, 0);            // do not care if this fails\n+    return 0;\n+}\n+\n void\n fileincref(File *f)\n {\n\ndiff --git a/linux.c b/linux.c\n--- a/linux.c\n+++ b/linux.c\n@@ -16,24 +16,6 @@\n static int epfd;\n \n \n-/* Allocate disk space.\n- * Expects fd's offset to be 0; may also reset fd's offset to 0.\n- * Returns 0 on success, and a positive errno otherwise. */\n-int\n-rawfalloc(int fd, int len)\n-{\n-    // XSI-conformant systems might not extend the file and return an error.\n-    // ftruncate() might extend the file with a sequence of null bytes or a hole.\n-    // Latter means that disk blocks are not allocated before the write happens.\n-    // To ensure that write won't fail because disk space is exhausted,\n-    // we might use posix_fallocate() that ensures disk allocation, but it\n-    // has limited support for NFS. Optionally can revert to regular write as on osx.\n-    if (!ftruncate(fd, len))\n-        return 0;\n-    return errno;\n-}\n-\n-\n int\n sockinit(void)\n {\n\ndiff --git a/sunos.c b/sunos.c\n--- a/sunos.c\n+++ b/sunos.c\n@@ -9,26 +9,6 @@\n #include \"dat.h\"\n \n static int portfd;\n-static char buf0[512]; /* buffer of zeros */\n-\n-/* Allocate disk space.\n- * Expects fd's offset to be 0; may also reset fd's offset to 0.\n- * Returns 0 on success, and a positive errno otherwise. */\n-int\n-rawfalloc(int fd, int len)\n-{\n-    int i, w;\n-\n-    for (i = 0; i < len; i += w) {\n-        w = write(fd, buf0, sizeof buf0);\n-        if (w == -1) return errno;\n-    }\n-\n-    lseek(fd, 0, 0); /* do not care if this fails */\n-\n-    return 0;\n-}\n-\n \n int\n sockinit(void)\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -1403,7 +1403,7 @@ cttest_binlog_size_limit()\n     int i = 0;\n     int gotsize;\n \n-    size = 1024;\n+    size = 4096;\n     srv.wal.dir = ctdir();\n     srv.wal.use = 1;\n     srv.wal.filesize = size;\n\ndiff --git a/util.c b/util.c\n--- a/util.c\n+++ b/util.c\n@@ -108,7 +108,7 @@ usage(int code)\n             \" -u USER  become user and group\\n\"\n             \" -z BYTES set the maximum job size in bytes (default is %d, max allowed is %d)\\n\"\n             \" -s BYTES set the size of each write-ahead log file (default is %d)\\n\"\n-            \"            (will be rounded up to a multiple of 512 bytes)\\n\"\n+            \"            (will be rounded up to a multiple of 4096 bytes)\\n\"\n             \" -c       compact the binlog (default)\\n\"\n             \" -n       do not compact the binlog\\n\"\n             \" -v       show version information\\n\"\n", "test_patch": "", "problem_statement": "write blocks to allocate files in rawfalloc on every OS\nInstead of having Linux implementation that uses ftruncate,\r\nallocate files by writing 4096 bytes blocks.\r\n\r\nFixes #537", "version": "1.11", "language": "C", "created_at": "2019-08-20T11:05:07Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-526", "repo": "beanstalkd/beanstalkd", "pull_number": 526, "base_commit": "b731750cf9e6e9fb845071aa37f81df3d7feb9fa", "patch": "diff --git a/.codecov.yml b/.codecov.yml\n--- a/.codecov.yml\n+++ b/.codecov.yml\n@@ -3,13 +3,17 @@ codecov:\n     require_ci_to_pass: yes\n \n coverage:\n-  precision: 1\n+  precision: 2\n   round: down\n-  range: \"70...100\"\n+  range: \"65...90\"\n \n   status:\n-    project: no\n-    patch: no\n+    project:\n+      default:\n+        threshold: 0.5 # Allow the coverage to drop by threshold %, and posting a success status.\n+    patch:\n+      default:\n+        target: 0% # trial operation\n     changes: no\n \n parsers:\n@@ -26,9 +30,15 @@ comment:\n   require_changes: no\n \n ignore:\n-  # ignore files using wildcards\n+  - \".git\"\n+  - \"*.yml\"\n+  - \"*.md\"\n+  # ignore test files\n   - \"test*.c\"\n+  # ignore sd-daemon.* since it's vendored as external lib\n+  - \"sd-daemon.*\"\n   # ignore folders and all its contents\n-  - \"ct/.*\"\n   - \"adm/.*\"\n+  - \"ct/.*\"\n+  - \"doc/.*\"\n   - \"pkg/.*\"\n", "test_patch": "", "problem_statement": "add merge check with threshold of 0.5%\nIgnore sd-daemon.* since we are not going to test it,\r\nignore \"doc/*\" and use more sane scale for coloring the badge.\r\n\r\nFixes #500", "version": "1.11", "language": "C", "created_at": "2019-08-04T15:58:11Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-544", "repo": "beanstalkd/beanstalkd", "pull_number": 544, "base_commit": "95e45b369eda9ad0088400081b7f7663b05cca8d", "patch": "diff --git a/net.c b/net.c\n--- a/net.c\n+++ b/net.c\n@@ -38,7 +38,7 @@ make_inet_socket(char *host, char *port)\n     struct addrinfo *airoot, *ai, hints;\n \n     memset(&hints, 0, sizeof(hints));\n-    hints.ai_family = PF_UNSPEC;\n+    hints.ai_family = AF_UNSPEC;\n     hints.ai_socktype = SOCK_STREAM;\n     hints.ai_flags = AI_PASSIVE;\n     r = getaddrinfo(host, port, &hints, &airoot);\n@@ -86,6 +86,16 @@ make_inet_socket(char *host, char *port)\n             continue;\n         }\n \n+        if (host == NULL && ai->ai_family == AF_INET6) {\n+            flags = 0;\n+            r = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &flags, sizeof(flags));\n+            if (r == -1) {\n+                twarn(\"setting IPV6_V6ONLY on fd %d\", fd);\n+                close(fd);\n+                continue;\n+            }\n+        }\n+\n         r = bind(fd, ai->ai_addr, ai->ai_addrlen);\n         if (r == -1) {\n             twarn(\"bind()\");\n", "test_patch": "", "problem_statement": "disable forced binding to IPV6-only stack if \"-l\" was not set\nThis issue appears on FreeBSD 8.4 where IPV6_V6ONLY is set to 1 by\r\ndefault. This patch unsets this flag if host was not specified.\r\n\r\nEach OS choses the default value for this flag, but it's better\r\nto override it for the case when listening on all interface is\r\nexpected.\r\n\r\nFixes #228", "version": "1.11", "language": "C", "created_at": "2019-08-13T19:24:36Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-584", "repo": "beanstalkd/beanstalkd", "pull_number": 584, "base_commit": "3434d21b399dea2629095b683137e69bd34e7b46", "patch": "diff --git a/CHANGELOG.md b/CHANGELOG.md\n--- a/CHANGELOG.md\n+++ b/CHANGELOG.md\n@@ -3,6 +3,8 @@ All notable changes to this project will be documented in this file.\n \n ## [Unreleased]\n \n+## [1.12] - 2020-06-04\n+\n - add support of UNIX domain sockets\n - add support of Solaris/illumos\n - add the \"reserve-job\" command\n@@ -27,6 +29,7 @@ All notable changes to this project will be documented in this file.\n - add DESTDIR support to Makefile\n \n \n-[unreleased]: https://github.com/beanstalkd/beanstalkd/compare/v1.11...HEAD\n+[unreleased]: https://github.com/beanstalkd/beanstalkd/compare/v1.12...HEAD\n+[1.12]:       https://github.com/beanstalkd/beanstalkd/compare/v1.11...v1.12\n [1.11]:       https://github.com/beanstalkd/beanstalkd/compare/v1.10...v1.11\n [1.10]:       https://github.com/beanstalkd/beanstalkd/compare/v1.9...v1.10\n", "test_patch": "", "problem_statement": "Updates changelog with 1.12 release\nSigned-off-by: Thomas Parrott <tomp@tomp.uk>", "version": "1.12", "language": "C", "created_at": "2020-06-04T20:01:18Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-556", "repo": "beanstalkd/beanstalkd", "pull_number": 556, "base_commit": "912ce0217a6c353b7200dd4b097235cab6f6335a", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -395,7 +395,7 @@ struct Conn {\n     // while in_job_read is nonzero, we are in bit bucket mode and\n     // in_job_read's meaning is inverted -- then it counts the bytes that\n     // remain to be thrown away.\n-    int32 in_job_read;\n+    int64 in_job_read;\n     Job   *in_job;              // a job to be read from the client\n \n     Job *out_job;               // a job to be sent to the client\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -789,9 +789,9 @@ fill_extra_data(Conn *c)\n     if (!c->cmd_len) return; /* we don't have a complete command */\n \n     /* how many extra bytes did we read? */\n-    int32 extra_bytes = c->cmd_read - c->cmd_len;\n+    int64 extra_bytes = c->cmd_read - c->cmd_len;\n \n-    int32 job_data_bytes = 0;\n+    int64 job_data_bytes = 0;\n     /* how many bytes should we put into the job body? */\n     if (c->in_job) {\n         job_data_bytes = min(extra_bytes, c->in_job->r.body_size);\n@@ -804,16 +804,16 @@ fill_extra_data(Conn *c)\n     }\n \n     /* how many bytes are left to go into the future cmd? */\n-    int32 cmd_bytes = extra_bytes - job_data_bytes;\n+    int64 cmd_bytes = extra_bytes - job_data_bytes;\n     memmove(c->cmd, c->cmd + c->cmd_len + job_data_bytes, cmd_bytes);\n     c->cmd_read = cmd_bytes;\n     c->cmd_len = 0; /* we no longer know the length of the new command */\n }\n \n-#define skip(conn,n,msg) (_skip(conn,n,msg,CONSTSTRLEN(msg)))\n+#define skip(conn,n,msg) (_skip(conn, n, msg, CONSTSTRLEN(msg)))\n \n static void\n-_skip(Conn *c, int32 n, char *msg, int msglen)\n+_skip(Conn *c, int64 n, char *msg, int msglen)\n {\n     /* Invert the meaning of in_job_read while throwing away data -- it\n      * counts the bytes that remain to be thrown away. */\n@@ -1286,7 +1286,7 @@ dispatch_cmd(Conn *c)\n \n         if (body_size > job_data_size_limit) {\n             /* throw away the job body and respond with JOB_TOO_BIG */\n-            skip(c, body_size + 2, MSG_JOB_TOO_BIG);\n+            skip(c, (int64)body_size + 2, MSG_JOB_TOO_BIG);\n             return;\n         }\n \n@@ -1847,7 +1847,8 @@ conn_want_command(Conn *c)\n static void\n conn_process_io(Conn *c)\n {\n-    int r, to_read;\n+    int r;\n+    int64 to_read;\n     Job *j;\n     struct iovec iov[2];\n \n", "test_patch": "", "problem_statement": "fix overflow error with job size bigger than uint32 width\nThe patch fixes segfault after the \"put 0 0 0 3000000000\" command.\r\n\r\nFixes #555", "version": "1.11", "language": "C", "created_at": "2019-08-22T07:58:01Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-533", "repo": "beanstalkd/beanstalkd", "pull_number": 533, "base_commit": "a730b2ae94315b83b75e0a4283d933edf98c94c0", "patch": "diff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -226,7 +226,7 @@ connclose(Conn *c)\n     job_free(c->in_job);\n \n     /* was this a peek or stats command? */\n-    if (c->out_job && !c->out_job->r.id) job_free(c->out_job);\n+    if (c->out_job && c->out_job->r.state == Copy) job_free(c->out_job);\n \n     c->in_job = c->out_job = NULL;\n     c->in_job_read = 0;\n", "test_patch": "", "problem_statement": "Free placeholder stats/peek job by checking state in connclose\n\"Placeholder\" jobs used to return info (stats, list tube) have their state set to `Copy`, as well as copied jobs for peek commands. Consistent with https://github.com/beanstalkd/beanstalkd/blob/master/prot.c#L1859\r\n\r\nThere could also be a potential memory leak if a connection is closed with a pending peek job copy (where `c->out_job->r.id` is set).\r\n\r\nSidenote: should there be another enum constant added to better indicate the state of these fake jobs - rather than `Copy`?", "version": "1.11", "language": "C", "created_at": "2019-08-08T14:57:05Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-604", "repo": "beanstalkd/beanstalkd", "pull_number": 604, "base_commit": "0f927a237f52ba355d15d362c454ebbbbc172549", "patch": "diff --git a/doc/protocol.txt b/doc/protocol.txt\n--- a/doc/protocol.txt\n+++ b/doc/protocol.txt\n@@ -729,7 +729,7 @@ The pause-tube command can delay any new job being reserved for a given time. It\n \n     pause-tube <tube-name> <delay>\\r\\n\n \n- - <tube> is the tube to pause\n+ - <tube-name> is the tube to pause\n \n  - <delay> is an integer number of seconds < 2**32 to wait before reserving any more\n    jobs from the queue\n", "test_patch": "", "problem_statement": "fix pause-tube parameter\nFixed the form of the pause-tube command parameter description", "version": "1.12", "language": "C", "created_at": "2021-09-23T00:09:09Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-528", "repo": "beanstalkd/beanstalkd", "pull_number": 528, "base_commit": "5677064b5491f7b5ca694fd550f206e361474b5b", "patch": "diff --git a/main.c b/main.c\n--- a/main.c\n+++ b/main.c\n@@ -36,6 +36,12 @@ su(const char *user)\n     }\n }\n \n+static void\n+handle_sigterm_pid1()\n+{\n+    raise(SIGKILL);\n+}\n+\n static void\n set_sig_handlers()\n {\n@@ -61,6 +67,18 @@ set_sig_handlers()\n         twarn(\"sigaction(SIGUSR1)\");\n         exit(111);\n     }\n+\n+    // Workaround for running the server with pid=1 in Docker.\n+    // Handle SIGTERM so the server is killed immediately and\n+    // not after 10 seconds timeout. See issue #527.\n+    if (getpid() == 1) {\n+        sa.sa_handler = handle_sigterm_pid1;\n+        r = sigaction(SIGTERM, &sa, 0);\n+        if (r == -1) {\n+            twarn(\"sigaction(SIGTERM)\");\n+            exit(111);\n+        }\n+    }\n }\n \n int\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -14,6 +14,7 @@\n #include <netinet/in.h>\n #include <inttypes.h>\n #include <stdarg.h>\n+#include <signal.h>\n \n /* job body cannot be greater than this many bytes long */\n size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n@@ -226,7 +227,10 @@ static struct stats global_stat = {0, 0, 0, 0, 0, 0, 0};\n \n static Tube *default_tube;\n \n-static int drain_mode = 0;\n+// If drain_mode is 1, then server does not accept new jobs.\n+// Variable is set by the SIGUSR1 handler.\n+static volatile sig_atomic_t drain_mode = 0;\n+\n static int64 started_at;\n \n enum { instance_id_bytes = 8 };\n@@ -275,6 +279,9 @@ buried_job_p(Tube *t)\n     return job_list_any_p(&t->buried);\n }\n \n+// epollq_add schedules connection c in the s->conns heap, adds c\n+// to the epollq list to change expected operation in event notifications.\n+// rw='w' means to notify when socket is writeable, 'r' - readable, 'h' - closed.\n static void\n epollq_add(Conn *c, char rw) {\n     c->rw = rw;\n@@ -283,7 +290,7 @@ epollq_add(Conn *c, char rw) {\n     epollq = c;\n }\n \n-// Remove connection c from the epollq.\n+// epollq_rmconn removes connection c from the epollq.\n static void\n epollq_rmconn(Conn *c)\n {\n@@ -304,8 +311,8 @@ epollq_rmconn(Conn *c)\n     epollq = newhead;\n }\n \n-// Propagate changes to event notification mechanism about wanted responses\n-// from connections. Clear the epollq list.\n+// Propagate changes to event notification mechanism about expected operations\n+// in connections' sockets. Clear the epollq list.\n static void\n epollq_apply()\n {\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -96,13 +96,14 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define MSG_EXPECTED_CRLF \"EXPECTED_CRLF\\r\\n\"\n #define MSG_JOB_TOO_BIG \"JOB_TOO_BIG\\r\\n\"\n \n-#define STATE_WANTCOMMAND 0\n-#define STATE_WANTDATA 1\n-#define STATE_SENDJOB 2\n-#define STATE_SENDWORD 3\n-#define STATE_WAIT 4\n-#define STATE_BITBUCKET 5\n-#define STATE_CLOSE 6\n+// Connection can be in one of these states:\n+#define STATE_WANTCOMMAND 0    // conn expects a command from the client\n+#define STATE_WANTDATA 1       // conn expects a job data\n+#define STATE_SENDJOB 2        // conn sends job to the client\n+#define STATE_SENDWORD 3       // conn sends a line reply\n+#define STATE_WAIT 4           // client awaits for the job reservation\n+#define STATE_BITBUCKET 5      // conn discards content\n+#define STATE_CLOSE 6          // conn should be closed\n \n #define OP_UNKNOWN 0\n #define OP_PUT 1\n", "test_patch": "", "problem_statement": "handle SIGTERM to allow quick exit under Docker\nBefore this patch: when beanstalkd with PID=1 received SIGTERM\r\nrunning inside of Docker container, the process never exited.\r\nDocker SIGKILLed the process after 10s timeout.\r\n\r\nThis change adds an ability to handle such case without timeout.\r\nServer will signal itself SIGKILL when SIGTERM is received.\r\nThis allows instant termination. This is part of the crash-only\r\nstrategy so crashing this way is okay.\r\n\r\nFixes #527", "version": "1.11", "language": "C", "created_at": "2019-08-06T10:10:25Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-515", "repo": "beanstalkd/beanstalkd", "pull_number": 515, "base_commit": "917b4e7b6814044722990162227db79ae32bcaaf", "patch": "diff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -333,9 +333,12 @@ reply_line(Conn *c, int state, const char *fmt, ...)\n     va_end(ap);\n \n     /* Make sure the buffer was big enough. If not, we have a bug. */\n-    if (r >= LINE_BUF_SIZE) return reply_serr(c, MSG_INTERNAL_ERROR);\n+    if (r >= LINE_BUF_SIZE) {\n+        reply_serr(c, MSG_INTERNAL_ERROR);\n+        return;\n+    }\n \n-    return reply(c, c->reply_buf, r, state);\n+    reply(c, c->reply_buf, r, state);\n }\n \n static void\n@@ -345,8 +348,8 @@ reply_job(Conn *c, Job *j, const char *word)\n     c->out_job = j;\n     c->out_job_sent = 0;\n \n-    return reply_line(c, STATE_SENDJOB, \"%s %\"PRIu64\" %u\\r\\n\",\n-                      word, j->r.id, j->r.body_size - 2);\n+    reply_line(c, STATE_SENDJOB, \"%s %\"PRIu64\" %u\\r\\n\",\n+               word, j->r.id, j->r.body_size - 2);\n }\n \n Conn *\n@@ -381,7 +384,7 @@ reserve_job(Conn *c, Job *j)\n     if (c->soonest_job && j->r.deadline_at < c->soonest_job->r.deadline_at) {\n         c->soonest_job = j;\n     }\n-    return reply_job(c, j, MSG_RESERVED);\n+    reply_job(c, j, MSG_RESERVED);\n }\n \n static Job *\n@@ -703,7 +706,6 @@ check_err(Conn *c, const char *s)\n \n     twarn(\"%s\", s);\n     c->state = STATE_CLOSE;\n-    return;\n }\n \n /* Scan the given string for the sequence \"\\r\\n\" and return the line length.\n@@ -804,14 +806,15 @@ _skip(Conn *c, int32 n, char *msg, int msglen)\n     c->in_job_read = n;\n     fill_extra_data(c);\n \n-    if (c->in_job_read == 0)\n-        return reply(c, msg, msglen, STATE_SENDWORD);\n+    if (c->in_job_read == 0) {\n+        reply(c, msg, msglen, STATE_SENDWORD);\n+        return;\n+    }\n \n     c->reply = msg;\n     c->reply_len = msglen;\n     c->reply_sent = 0;\n     c->state = STATE_BITBUCKET;\n-    return;\n }\n \n static void\n@@ -826,7 +829,8 @@ enqueue_incoming_job(Conn *c)\n     /* check if the trailer is present and correct */\n     if (memcmp(j->body + j->r.body_size - 2, \"\\r\\n\", 2)) {\n         job_free(j);\n-        return reply_msg(c, MSG_EXPECTED_CRLF);\n+        reply_msg(c, MSG_EXPECTED_CRLF);\n+        return;\n     }\n \n     if (verbose >= 2) {\n@@ -835,21 +839,34 @@ enqueue_incoming_job(Conn *c)\n \n     if (drain_mode) {\n         job_free(j);\n-        return reply_serr(c, MSG_DRAINING);\n+        reply_serr(c, MSG_DRAINING);\n+        return;\n     }\n \n-    if (j->walresv) return reply_serr(c, MSG_INTERNAL_ERROR);\n+    if (j->walresv) {\n+        reply_serr(c, MSG_INTERNAL_ERROR);\n+        return;\n+    }\n     j->walresv = walresvput(&c->srv->wal, j);\n-    if (!j->walresv) return reply_serr(c, MSG_OUT_OF_MEMORY);\n+    if (!j->walresv) {\n+        reply_serr(c, MSG_OUT_OF_MEMORY);\n+        return;\n+    }\n \n     /* we have a complete job, so let's stick it in the pqueue */\n     r = enqueue_job(c->srv, j, j->r.delay, 1);\n-    if (r < 0) return reply_serr(c, MSG_INTERNAL_ERROR);\n+    if (r < 0) {\n+        reply_serr(c, MSG_INTERNAL_ERROR);\n+        return;\n+    }\n \n     global_stat.total_jobs_ct++;\n     j->tube->stat.total_jobs_ct++;\n \n-    if (r == 1) return reply_line(c, STATE_SENDWORD, MSG_INSERTED_FMT, j->r.id);\n+    if (r == 1) {\n+        reply_line(c, STATE_SENDWORD, MSG_INSERTED_FMT, j->r.id);\n+        return;\n+    }\n \n     /* out of memory trying to grow the queue, so it gets buried */\n     bury_job(c->srv, j, 0);\n@@ -1050,7 +1067,10 @@ do_stats(Conn *c, fmt_fn fmt, void *data)\n     stats_len = fmt(NULL, 0, data) + 16;\n \n     c->out_job = allocate_job(stats_len); /* fake job to hold stats data */\n-    if (!c->out_job) return reply_serr(c, MSG_OUT_OF_MEMORY);\n+    if (!c->out_job) {\n+        reply_serr(c, MSG_OUT_OF_MEMORY);\n+        return;\n+    }\n \n     /* Mark this job as a copy so it can be appropriately freed later on */\n     c->out_job->r.state = Copy;\n@@ -1059,10 +1079,13 @@ do_stats(Conn *c, fmt_fn fmt, void *data)\n     r = fmt(c->out_job->body, stats_len, data);\n     /* and set the actual body size */\n     c->out_job->r.body_size = r;\n-    if (r > stats_len) return reply_serr(c, MSG_INTERNAL_ERROR);\n+    if (r > stats_len) {\n+        reply_serr(c, MSG_INTERNAL_ERROR);\n+        return;\n+    }\n \n     c->out_job_sent = 0;\n-    return reply_line(c, STATE_SENDJOB, \"OK %d\\r\\n\", r - 2);\n+    reply_line(c, STATE_SENDJOB, \"OK %d\\r\\n\", r - 2);\n }\n \n static void\n@@ -1080,7 +1103,10 @@ do_list_tubes(Conn *c, Ms *l)\n     }\n \n     c->out_job = allocate_job(resp_z); /* fake job to hold response data */\n-    if (!c->out_job) return reply_serr(c, MSG_OUT_OF_MEMORY);\n+    if (!c->out_job) {\n+        reply_serr(c, MSG_OUT_OF_MEMORY);\n+        return;\n+    }\n \n     /* Mark this job as a copy so it can be appropriately freed later on */\n     c->out_job->r.state = Copy;\n@@ -1096,7 +1122,7 @@ do_list_tubes(Conn *c, Ms *l)\n     buf[1] = '\\n';\n \n     c->out_job_sent = 0;\n-    return reply_line(c, STATE_SENDJOB, \"OK %zu\\r\\n\", resp_z - 2);\n+    reply_line(c, STATE_SENDJOB, \"OK %zu\\r\\n\", resp_z - 2);\n }\n \n static int\n@@ -1165,7 +1191,10 @@ maybe_enqueue_incoming_job(Conn *c)\n     Job *j = c->in_job;\n \n     /* do we have a complete job? */\n-    if (c->in_job_read == j->r.body_size) return enqueue_incoming_job(c);\n+    if (c->in_job_read == j->r.body_size) {\n+        enqueue_incoming_job(c);\n+        return;\n+    }\n \n     /* otherwise we have incomplete data, so just keep waiting */\n     c->state = STATE_WANTDATA;\n@@ -1225,7 +1254,8 @@ dispatch_cmd(Conn *c)\n \n     /* check for possible maliciousness */\n     if (strlen(c->cmd) != c->cmd_len - 2) {\n-        return reply_msg(c, MSG_BAD_FORMAT);\n+        reply_msg(c, MSG_BAD_FORMAT);\n+        return;\n     }\n \n     type = which_cmd(c);\n@@ -1235,28 +1265,26 @@ dispatch_cmd(Conn *c)\n \n     switch (type) {\n     case OP_PUT:\n-        if (read_u32(&pri, c->cmd + 4, &delay_buf))\n-            return reply_msg(c, MSG_BAD_FORMAT);\n-\n-        if (read_duration(&delay, delay_buf, &ttr_buf))\n-            return reply_msg(c, MSG_BAD_FORMAT);\n-\n-        if (read_duration(&ttr, ttr_buf, &size_buf))\n-            return reply_msg(c, MSG_BAD_FORMAT);\n-\n-        if (read_u32(&body_size, size_buf, &end_buf))\n-            return reply_msg(c, MSG_BAD_FORMAT);\n-\n+        if (read_u32(&pri, c->cmd + 4, &delay_buf) ||\n+            read_duration(&delay, delay_buf, &ttr_buf) ||\n+            read_duration(&ttr, ttr_buf, &size_buf) ||\n+            read_u32(&body_size, size_buf, &end_buf)) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n         op_ct[type]++;\n \n         if (body_size > job_data_size_limit) {\n             /* throw away the job body and respond with JOB_TOO_BIG */\n-            return skip(c, body_size + 2, MSG_JOB_TOO_BIG);\n+            skip(c, body_size + 2, MSG_JOB_TOO_BIG);\n+            return;\n         }\n \n         /* don't allow trailing garbage */\n-        if (end_buf[0] != '\\0')\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+        if (end_buf[0] != '\\0') {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n \n         connsetproducer(c);\n \n@@ -1270,98 +1298,123 @@ dispatch_cmd(Conn *c)\n         if (!c->in_job) {\n             /* throw away the job body and respond with OUT_OF_MEMORY */\n             twarnx(\"server error: \" MSG_OUT_OF_MEMORY);\n-            return skip(c, body_size + 2, MSG_OUT_OF_MEMORY);\n+            skip(c, body_size + 2, MSG_OUT_OF_MEMORY);\n+            return;\n         }\n \n         fill_extra_data(c);\n \n         /* it's possible we already have a complete job */\n         maybe_enqueue_incoming_job(c);\n+        return;\n \n-        break;\n     case OP_PEEK_READY:\n         /* don't allow trailing garbage */\n         if (c->cmd_len != CMD_PEEK_READY_LEN + 2) {\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n         }\n         op_ct[type]++;\n \n         if (c->use->ready.len) {\n             j = job_copy(c->use->ready.data[0]);\n         }\n \n-        if (!j) return reply_msg(c, MSG_NOTFOUND);\n-\n+        if (!j) {\n+            reply_msg(c, MSG_NOTFOUND);\n+            return;\n+        }\n         reply_job(c, j, MSG_FOUND);\n-        break;\n+        return;\n+\n     case OP_PEEK_DELAYED:\n         /* don't allow trailing garbage */\n         if (c->cmd_len != CMD_PEEK_DELAYED_LEN + 2) {\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n         }\n         op_ct[type]++;\n \n         if (c->use->delay.len) {\n             j = job_copy(c->use->delay.data[0]);\n         }\n \n-        if (!j) return reply_msg(c, MSG_NOTFOUND);\n-\n+        if (!j) {\n+            reply_msg(c, MSG_NOTFOUND);\n+            return;\n+        }\n         reply_job(c, j, MSG_FOUND);\n-        break;\n+        return;\n+\n     case OP_PEEK_BURIED:\n         /* don't allow trailing garbage */\n         if (c->cmd_len != CMD_PEEK_BURIED_LEN + 2) {\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n         }\n         op_ct[type]++;\n \n         j = job_copy(buried_job_p(c->use)? j = c->use->buried.next : NULL);\n \n-        if (!j) return reply_msg(c, MSG_NOTFOUND);\n-\n+        if (!j) {\n+            reply_msg(c, MSG_NOTFOUND);\n+            return;\n+        }\n         reply_job(c, j, MSG_FOUND);\n-        break;\n-    case OP_PEEKJOB:\n-        if (read_u64(&id, c->cmd + CMD_PEEKJOB_LEN, NULL))\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+        return;\n \n+    case OP_PEEKJOB:\n+        if (read_u64(&id, c->cmd + CMD_PEEKJOB_LEN, NULL)) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n         op_ct[type]++;\n \n         /* So, peek is annoying, because some other connection might free the\n          * job while we are still trying to write it out. So we copy it and\n          * free the copy when it's done sending, in the \"reset_conn\" function. */\n         j = job_copy(peek_job(id));\n \n-        if (!j) return reply_msg(c, MSG_NOTFOUND);\n-\n+        if (!j) {\n+            reply_msg(c, MSG_NOTFOUND);\n+            return;\n+        }\n         reply_job(c, j, MSG_FOUND);\n-        break;\n+        return;\n+\n     case OP_RESERVE_TIMEOUT:\n         errno = 0;\n         timeout = strtol(c->cmd + CMD_RESERVE_TIMEOUT_LEN, &end_buf, 10);\n-        if (errno)\n-            return reply_msg(c, MSG_BAD_FORMAT);\n-    case OP_RESERVE: /* FALLTHROUGH */\n+        if (errno) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n+        /* FALLTHROUGH */\n+\n+    case OP_RESERVE:\n         /* don't allow trailing garbage */\n         if (type == OP_RESERVE && c->cmd_len != CMD_RESERVE_LEN + 2) {\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n         }\n-\n         op_ct[type]++;\n         connsetworker(c);\n \n         if (conndeadlinesoon(c) && !conn_ready(c)) {\n-            return reply_msg(c, MSG_DEADLINE_SOON);\n+            reply_msg(c, MSG_DEADLINE_SOON);\n+            return;\n         }\n \n         /* try to get a new job for this guy */\n         wait_for_job(c, timeout);\n         process_queue();\n-        break;\n+        return;\n+\n     case OP_DELETE:\n-        if (read_u64(&id, c->cmd + CMD_DELETE_LEN, NULL))\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+        if (read_u64(&id, c->cmd + CMD_DELETE_LEN, NULL)) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n         op_ct[type]++;\n \n         j = job_find(id);\n@@ -1370,8 +1423,10 @@ dispatch_cmd(Conn *c)\n             remove_buried_job(j) ? :\n             remove_delayed_job(j);\n \n-        if (!j)\n-            return reply_msg(c, MSG_NOTFOUND);\n+        if (!j) {\n+            reply_msg(c, MSG_NOTFOUND);\n+            return;\n+        }\n \n         j->tube->stat.total_delete_ct++;\n \n@@ -1380,33 +1435,37 @@ dispatch_cmd(Conn *c)\n         walmaint(&c->srv->wal);\n         job_free(j);\n \n-        if (!r)\n-            return reply_serr(c, MSG_INTERNAL_ERROR);\n-\n+        if (!r) {\n+            reply_serr(c, MSG_INTERNAL_ERROR);\n+            return;\n+        }\n         reply_msg(c, MSG_DELETED);\n-        break;\n-    case OP_RELEASE:\n-        if (read_u64(&id, c->cmd + CMD_RELEASE_LEN, &pri_buf))\n-            return reply_msg(c, MSG_BAD_FORMAT);\n-\n-        if (read_u32(&pri, pri_buf, &delay_buf))\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+        return;\n \n-        if (read_duration(&delay, delay_buf, NULL))\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+    case OP_RELEASE:\n+        if (read_u64(&id, c->cmd + CMD_RELEASE_LEN, &pri_buf) ||\n+            read_u32(&pri, pri_buf, &delay_buf) ||\n+            read_duration(&delay, delay_buf, NULL)) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n         op_ct[type]++;\n \n         j = remove_reserved_job(c, job_find(id));\n \n-        if (!j)\n-            return reply_msg(c, MSG_NOTFOUND);\n+        if (!j) {\n+            reply_msg(c, MSG_NOTFOUND);\n+            return;\n+        }\n \n         /* We want to update the delay deadline on disk, so reserve space for\n          * that. */\n         if (delay) {\n             int z = walresvupdate(&c->srv->wal);\n-            if (!z)\n-                return reply_serr(c, MSG_OUT_OF_MEMORY);\n+            if (!z) {\n+                reply_serr(c, MSG_OUT_OF_MEMORY);\n+                return;\n+            }\n             j->walresv += z;\n         }\n \n@@ -1415,208 +1474,271 @@ dispatch_cmd(Conn *c)\n         j->r.release_ct++;\n \n         r = enqueue_job(c->srv, j, delay, !!delay);\n-        if (r < 0)\n-            return reply_serr(c, MSG_INTERNAL_ERROR);\n+        if (r < 0) {\n+            reply_serr(c, MSG_INTERNAL_ERROR);\n+            return;\n+        }\n         if (r == 1) {\n-            return reply_msg(c, MSG_RELEASED);\n+            reply_msg(c, MSG_RELEASED);\n+            return;\n         }\n \n         /* out of memory trying to grow the queue, so it gets buried */\n         bury_job(c->srv, j, 0);\n         reply_msg(c, MSG_BURIED);\n-        break;\n-    case OP_BURY:\n-        if (read_u64(&id, c->cmd + CMD_BURY_LEN, &pri_buf))\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+        return;\n \n-        if (read_u32(&pri, pri_buf, NULL))\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+    case OP_BURY:\n+        if (read_u64(&id, c->cmd + CMD_BURY_LEN, &pri_buf) ||\n+            read_u32(&pri, pri_buf, NULL)) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n \n         op_ct[type]++;\n \n         j = remove_reserved_job(c, job_find(id));\n \n-        if (!j)\n-            return reply_msg(c, MSG_NOTFOUND);\n+        if (!j) {\n+            reply_msg(c, MSG_NOTFOUND);\n+            return;\n+        }\n \n         j->r.pri = pri;\n         r = bury_job(c->srv, j, 1);\n-        if (!r)\n-            return reply_serr(c, MSG_INTERNAL_ERROR);\n+        if (!r) {\n+            reply_serr(c, MSG_INTERNAL_ERROR);\n+            return;\n+        }\n         reply_msg(c, MSG_BURIED);\n-        break;\n+        return;\n+\n     case OP_KICK:\n         errno = 0;\n         count = strtoul(c->cmd + CMD_KICK_LEN, &end_buf, 10);\n-        if (end_buf == c->cmd + CMD_KICK_LEN) {\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+        if (end_buf == c->cmd + CMD_KICK_LEN || errno) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n         }\n-        if (errno) return reply_msg(c, MSG_BAD_FORMAT);\n \n         op_ct[type]++;\n \n         i = kick_jobs(c->srv, c->use, count);\n+        reply_line(c, STATE_SENDWORD, \"KICKED %u\\r\\n\", i);\n+        return;\n \n-        return reply_line(c, STATE_SENDWORD, \"KICKED %u\\r\\n\", i);\n     case OP_KICKJOB:\n-        if (read_u64(&id, c->cmd + CMD_KICKJOB_LEN, NULL))\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+        if (read_u64(&id, c->cmd + CMD_KICKJOB_LEN, NULL)) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n \n         op_ct[type]++;\n \n         j = job_find(id);\n-        if (!j)\n-            return reply_msg(c, MSG_NOTFOUND);\n+        if (!j) {\n+            reply_msg(c, MSG_NOTFOUND);\n+            return;\n+        }\n \n         if ((j->r.state == Buried && kick_buried_job(c->srv, j)) ||\n             (j->r.state == Delayed && kick_delayed_job(c->srv, j))) {\n             reply_msg(c, MSG_KICKED);\n         } else {\n-            return reply_msg(c, MSG_NOTFOUND);\n+            reply_msg(c, MSG_NOTFOUND);\n         }\n-        break;\n-    case OP_TOUCH:\n-        if (read_u64(&id, c->cmd + CMD_TOUCH_LEN, NULL))\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+        return;\n \n+    case OP_TOUCH:\n+        if (read_u64(&id, c->cmd + CMD_TOUCH_LEN, NULL)) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n         op_ct[type]++;\n \n         j = touch_job(c, job_find(id));\n \n         if (j) {\n             reply_msg(c, MSG_TOUCHED);\n         } else {\n-            return reply_msg(c, MSG_NOTFOUND);\n+            reply_msg(c, MSG_NOTFOUND);\n         }\n-        break;\n+        return;\n+\n     case OP_STATS:\n         /* don't allow trailing garbage */\n         if (c->cmd_len != CMD_STATS_LEN + 2) {\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n         }\n-\n         op_ct[type]++;\n \n         do_stats(c, fmt_stats, c->srv);\n-        break;\n-    case OP_STATSJOB:\n-        if (read_u64(&id, c->cmd + CMD_STATSJOB_LEN, NULL))\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+        return;\n \n+    case OP_STATSJOB:\n+        if (read_u64(&id, c->cmd + CMD_STATSJOB_LEN, NULL)) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n         op_ct[type]++;\n \n         j = peek_job(id);\n-        if (!j)\n-            return reply_msg(c, MSG_NOTFOUND);\n+        if (!j) {\n+            reply_msg(c, MSG_NOTFOUND);\n+            return;\n+        }\n \n-        if (!j->tube)\n-            return reply_serr(c, MSG_INTERNAL_ERROR);\n+        if (!j->tube) {\n+            reply_serr(c, MSG_INTERNAL_ERROR);\n+            return;\n+        }\n         do_stats(c, (fmt_fn) fmt_job_stats, j);\n-        break;\n+        return;\n+\n     case OP_STATS_TUBE:\n         name = c->cmd + CMD_STATS_TUBE_LEN;\n-        if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT);\n-\n+        if (!name_is_ok(name, 200)) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n         op_ct[type]++;\n \n         t = tube_find(name);\n-        if (!t) return reply_msg(c, MSG_NOTFOUND);\n-\n+        if (!t) {\n+            reply_msg(c, MSG_NOTFOUND);\n+            return;\n+        }\n         do_stats(c, (fmt_fn) fmt_stats_tube, t);\n         t = NULL;\n-        break;\n+        return;\n+\n     case OP_LIST_TUBES:\n         /* don't allow trailing garbage */\n         if (c->cmd_len != CMD_LIST_TUBES_LEN + 2) {\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n         }\n-\n         op_ct[type]++;\n         do_list_tubes(c, &tubes);\n-        break;\n+        return;\n+\n     case OP_LIST_TUBE_USED:\n         /* don't allow trailing garbage */\n         if (c->cmd_len != CMD_LIST_TUBE_USED_LEN + 2) {\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n         }\n-\n         op_ct[type]++;\n         reply_line(c, STATE_SENDWORD, \"USING %s\\r\\n\", c->use->name);\n-        break;\n+        return;\n+\n     case OP_LIST_TUBES_WATCHED:\n         /* don't allow trailing garbage */\n         if (c->cmd_len != CMD_LIST_TUBES_WATCHED_LEN + 2) {\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n         }\n-\n         op_ct[type]++;\n         do_list_tubes(c, &c->watch);\n-        break;\n+        return;\n+\n     case OP_USE:\n         name = c->cmd + CMD_USE_LEN;\n-        if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT);\n+        if (!name_is_ok(name, 200)) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n         op_ct[type]++;\n \n         TUBE_ASSIGN(t, tube_find_or_make(name));\n-        if (!t) return reply_serr(c, MSG_OUT_OF_MEMORY);\n+        if (!t) {\n+            reply_serr(c, MSG_OUT_OF_MEMORY);\n+            return;\n+        }\n \n         c->use->using_ct--;\n         TUBE_ASSIGN(c->use, t);\n         TUBE_ASSIGN(t, NULL);\n         c->use->using_ct++;\n \n         reply_line(c, STATE_SENDWORD, \"USING %s\\r\\n\", c->use->name);\n-        break;\n+        return;\n+\n     case OP_WATCH:\n         name = c->cmd + CMD_WATCH_LEN;\n-        if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT);\n+        if (!name_is_ok(name, 200)) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n         op_ct[type]++;\n \n         TUBE_ASSIGN(t, tube_find_or_make(name));\n-        if (!t) return reply_serr(c, MSG_OUT_OF_MEMORY);\n+        if (!t) {\n+            reply_serr(c, MSG_OUT_OF_MEMORY);\n+            return;\n+        }\n \n         r = 1;\n-        if (!ms_contains(&c->watch, t)) r = ms_append(&c->watch, t);\n+        if (!ms_contains(&c->watch, t))\n+            r = ms_append(&c->watch, t);\n         TUBE_ASSIGN(t, NULL);\n-        if (!r) return reply_serr(c, MSG_OUT_OF_MEMORY);\n-\n+        if (!r) {\n+            reply_serr(c, MSG_OUT_OF_MEMORY);\n+            return;\n+        }\n         reply_line(c, STATE_SENDWORD, \"WATCHING %zu\\r\\n\", c->watch.len);\n-        break;\n+        return;\n+\n     case OP_IGNORE:\n         name = c->cmd + CMD_IGNORE_LEN;\n-        if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT);\n+        if (!name_is_ok(name, 200)) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n         op_ct[type]++;\n \n         t = NULL;\n         for (i = 0; i < c->watch.len; i++) {\n             t = c->watch.items[i];\n-            if (strncmp(t->name, name, MAX_TUBE_NAME_LEN) == 0) break;\n+            if (strncmp(t->name, name, MAX_TUBE_NAME_LEN) == 0)\n+                break;\n             t = NULL;\n         }\n \n-        if (t && c->watch.len < 2) return reply_msg(c, MSG_NOT_IGNORED);\n+        if (t && c->watch.len < 2) {\n+            reply_msg(c, MSG_NOT_IGNORED);\n+            return;\n+        }\n \n-        if (t) ms_remove(&c->watch, t); /* may free t if refcount => 0 */\n+        if (t)\n+            ms_remove(&c->watch, t); /* may free t if refcount => 0 */\n         t = NULL;\n-\n         reply_line(c, STATE_SENDWORD, \"WATCHING %zu\\r\\n\", c->watch.len);\n-        break;\n+        return;\n+\n     case OP_QUIT:\n         c->state = STATE_CLOSE;\n-        break;\n+        return;\n+\n     case OP_PAUSE_TUBE:\n+        if (read_tube_name(&name, c->cmd + CMD_PAUSE_TUBE_LEN, &delay_buf) ||\n+            read_duration(&delay, delay_buf, NULL)) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n         op_ct[type]++;\n \n-        r = read_tube_name(&name, c->cmd + CMD_PAUSE_TUBE_LEN, &delay_buf);\n-        if (r) return reply_msg(c, MSG_BAD_FORMAT);\n-\n-        r = read_duration(&delay, delay_buf, NULL);\n-        if (r) return reply_msg(c, MSG_BAD_FORMAT);\n-\n         *delay_buf = '\\0';\n-        if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT);\n+        if (!name_is_ok(name, 200)) {\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n+        }\n         t = tube_find(name);\n-        if (!t) return reply_msg(c, MSG_NOTFOUND);\n+        if (!t) {\n+            reply_msg(c, MSG_NOTFOUND);\n+            return;\n+        }\n \n         // Always pause for a positive amount of time, to make sure\n         // that waiting clients wake up when the deadline arrives.\n@@ -1629,9 +1751,10 @@ dispatch_cmd(Conn *c)\n         t->stat.pause_ct++;\n \n         reply_line(c, STATE_SENDWORD, \"PAUSED\\r\\n\");\n-        break;\n+        return;\n+\n     default:\n-        return reply_msg(c, MSG_UNKNOWN_COMMAND);\n+        reply_msg(c, MSG_UNKNOWN_COMMAND);\n     }\n }\n \n@@ -1650,7 +1773,8 @@ conn_timeout(Conn *c)\n     Job *j;\n \n     /* Check if the client was trying to reserve a job. */\n-    if (conn_waiting(c) && conndeadlinesoon(c)) should_timeout = 1;\n+    if (conn_waiting(c) && conndeadlinesoon(c))\n+        should_timeout = 1;\n \n     /* Check if any reserved jobs have run out of time. We should do this\n      * whether or not the client is waiting for a new reservation. */\n@@ -1668,15 +1792,16 @@ conn_timeout(Conn *c)\n         timeout_ct++; /* stats */\n         j->r.timeout_ct++;\n         r = enqueue_job(c->srv, remove_this_reserved_job(c, j), 0, 0);\n-        if (r < 1) bury_job(c->srv, j, 0); /* out of memory, so bury it */\n+        if (r < 1)\n+            bury_job(c->srv, j, 0); /* out of memory, so bury it */\n         connsched(c);\n     }\n \n     if (should_timeout) {\n-        return reply_msg(remove_waiting_conn(c), MSG_DEADLINE_SOON);\n+        reply_msg(remove_waiting_conn(c), MSG_DEADLINE_SOON);\n     } else if (conn_waiting(c) && c->pending_timeout >= 0) {\n         c->pending_timeout = -1;\n-        return reply_msg(remove_waiting_conn(c), MSG_TIMED_OUT);\n+        reply_msg(remove_waiting_conn(c), MSG_TIMED_OUT);\n     }\n }\n \n@@ -1712,8 +1837,10 @@ conn_data(Conn *c)\n     switch (c->state) {\n     case STATE_WANTCOMMAND:\n         r = read(c->sock.fd, c->cmd + c->cmd_read, LINE_BUF_SIZE - c->cmd_read);\n-        if (r == -1)\n-            return check_err(c, \"read()\");\n+        if (r == -1) {\n+            check_err(c, \"read()\");\n+            return;\n+        }\n         if (r == 0) {\n             c->state = STATE_CLOSE;\n             return;\n@@ -1735,7 +1862,8 @@ conn_data(Conn *c)\n         /* command line too long? */\n         if (c->cmd_read == LINE_BUF_SIZE) {\n             c->cmd_read = 0; /* discard the input so far */\n-            return reply_msg(c, MSG_BAD_FORMAT);\n+            reply_msg(c, MSG_BAD_FORMAT);\n+            return;\n         }\n \n         /* otherwise we have an incomplete line, so just keep waiting */\n@@ -1745,7 +1873,10 @@ conn_data(Conn *c)\n          * counts the bytes that remain to be thrown away. */\n         to_read = min(c->in_job_read, BUCKET_BUF_SIZE);\n         r = read(c->sock.fd, bucket, to_read);\n-        if (r == -1) return check_err(c, \"read()\");\n+        if (r == -1) {\n+            check_err(c, \"read()\");\n+            return;\n+        }\n         if (r == 0) {\n             c->state = STATE_CLOSE;\n             return;\n@@ -1756,15 +1887,18 @@ conn_data(Conn *c)\n         /* (c->in_job_read < 0) can't happen */\n \n         if (c->in_job_read == 0) {\n-            return reply(c, c->reply, c->reply_len, STATE_SENDWORD);\n+            reply(c, c->reply, c->reply_len, STATE_SENDWORD);\n+            return;\n         }\n         break;\n     case STATE_WANTDATA:\n         j = c->in_job;\n \n         r = read(c->sock.fd, j->body + c->in_job_read, j->r.body_size -c->in_job_read);\n-        if (r == -1)\n-            return check_err(c, \"read()\");\n+        if (r == -1) {\n+            check_err(c, \"read()\");\n+            return;\n+        }\n         if (r == 0) {\n             c->state = STATE_CLOSE;\n             return;\n@@ -1778,8 +1912,10 @@ conn_data(Conn *c)\n         break;\n     case STATE_SENDWORD:\n         r= write(c->sock.fd, c->reply + c->reply_sent, c->reply_len - c->reply_sent);\n-        if (r == -1)\n-            return check_err(c, \"write()\");\n+        if (r == -1) {\n+            check_err(c, \"write()\");\n+            return;\n+        }\n         if (r == 0) {\n             c->state = STATE_CLOSE;\n             return;\n@@ -1789,7 +1925,10 @@ conn_data(Conn *c)\n \n         /* (c->reply_sent > c->reply_len) can't happen */\n \n-        if (c->reply_sent == c->reply_len) return reset_conn(c);\n+        if (c->reply_sent == c->reply_len) {\n+            reset_conn(c);\n+            return;\n+        }\n \n         /* otherwise we sent an incomplete reply, so just keep waiting */\n         break;\n@@ -1802,8 +1941,10 @@ conn_data(Conn *c)\n         iov[1].iov_len = j->r.body_size - c->out_job_sent;\n \n         r = writev(c->sock.fd, iov, 2);\n-        if (r == -1)\n-            return check_err(c, \"writev()\");\n+        if (r == -1) {\n+            check_err(c, \"writev()\");\n+            return;\n+        }\n         if (r == 0) {\n             c->state = STATE_CLOSE;\n             return;\n@@ -1823,15 +1964,17 @@ conn_data(Conn *c)\n             if (verbose >= 2) {\n                 printf(\">%d job %\"PRIu64\"\\n\", c->sock.fd, j->r.id);\n             }\n-            return reset_conn(c);\n+            reset_conn(c);\n+            return;\n         }\n \n         /* otherwise we sent incomplete data, so just keep waiting */\n         break;\n     case STATE_WAIT:\n         if (c->halfclosed) {\n             c->pending_timeout = -1;\n-            return reply_msg(remove_waiting_conn(c), MSG_TIMED_OUT);\n+            reply_msg(remove_waiting_conn(c), MSG_TIMED_OUT);\n+            return;\n         }\n         break;\n     }\n\ndiff --git a/tube.c b/tube.c\n--- a/tube.c\n+++ b/tube.c\n@@ -45,8 +45,10 @@ void\n tube_dref(Tube *t)\n {\n     if (!t) return;\n-    if (t->refs < 1)\n-        return twarnx(\"refs is zero for tube: %s\", t->name);\n+    if (t->refs < 1) {\n+        twarnx(\"refs is zero for tube: %s\", t->name);\n+        return;\n+    }\n \n     --t->refs;\n     if (t->refs < 1)\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -229,11 +229,8 @@ static Tube *default_tube;\n static int drain_mode = 0;\n static int64 started_at;\n \n-enum {\n-  NumIdBytes = 8\n-};\n-\n-static char id[NumIdBytes * 2 + 1]; // hex-encoded len of NumIdBytes\n+enum { instance_id_bytes = 8 };\n+static char instance_hex[instance_id_bytes * 2 + 1]; // hex-encoded len of instance_id_bytes\n \n static struct utsname node_info;\n static uint64 op_ct[TOTAL_OPS], timeout_ct = 0;\n@@ -945,7 +942,7 @@ fmt_stats(char *buf, size_t size, void *x)\n             srv->wal.nrec,\n             srv->wal.filesize,\n             drain_mode ? \"true\" : \"false\",\n-            id,\n+            instance_hex,\n             node_info.nodename);\n }\n \n@@ -1417,11 +1414,16 @@ dispatch_cmd(Conn *c)\n         }\n         op_ct[type]++;\n \n-        j = job_find(id);\n-        j = remove_reserved_job(c, j) ? :\n-            remove_ready_job(j) ? :\n-            remove_buried_job(j) ? :\n-            remove_delayed_job(j);\n+        {\n+            Job *jf = job_find(id);\n+            j = remove_reserved_job(c, jf);\n+            if (!j)\n+                j = remove_ready_job(jf);\n+            if (!j)\n+                j = remove_buried_job(jf);\n+            if (!j)\n+                j = remove_delayed_job(jf);\n+        }\n \n         if (!j) {\n             reply_msg(c, MSG_NOTFOUND);\n@@ -2170,14 +2172,14 @@ prot_init()\n     }\n \n     int i, r;\n-    byte rand_data[NumIdBytes];\n-    r = read(dev_random, &rand_data, NumIdBytes);\n-    if (r != NumIdBytes) {\n+    byte rand_data[instance_id_bytes];\n+    r = read(dev_random, &rand_data, instance_id_bytes);\n+    if (r != instance_id_bytes) {\n         twarn(\"read /dev/urandom\");\n         exit(50);\n     }\n-    for (i = 0; i < NumIdBytes; i++) {\n-        sprintf(id + (i * 2), \"%02x\", rand_data[i]);\n+    for (i = 0; i < instance_id_bytes; i++) {\n+        sprintf(instance_hex + (i * 2), \"%02x\", rand_data[i]);\n     }\n     close(dev_random);\n \n\ndiff --git a/tube.c b/tube.c\n--- a/tube.c\n+++ b/tube.c\n@@ -97,6 +97,9 @@ tube_find(const char *name)\n Tube *\n tube_find_or_make(const char *name)\n {\n-    return tube_find(name) ? : make_and_insert_tube(name);\n+    Tube *t = tube_find(name);\n+    if (t)\n+        return t;\n+    return make_and_insert_tube(name);\n }\n \n", "test_patch": "", "problem_statement": "do not return void expressions\nIt is confusing to understand and it is against C99.\r\n\r\nAlso remove redundant returns in end of of functions.", "version": "1.11", "language": "C", "created_at": "2019-07-30T07:09:20Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-581", "repo": "beanstalkd/beanstalkd", "pull_number": 581, "base_commit": "c73be666e7ce4377eb6ba122eeb73b762247a163", "patch": "diff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -62,6 +62,9 @@ typedef int(FAlloc)(int, int);\n // The width is restricted by Jobrec.body_size that is int32.\n #define JOB_DATA_SIZE_LIMIT_MAX 1073741824\n \n+// The default value for the fsync (-f) parameter, milliseconds.\n+#define DEFAULT_FSYNC_MS 50\n+\n // Use this macro to designate unused parameters in functions.\n #define UNUSED_PARAMETER(x) (void)(x)\n \n@@ -437,8 +440,8 @@ struct Wal {\n     int64  alive; // bytes in use\n     int64  nmig;  // migrations\n     int64  nrec;  // records written ever\n-    int    wantsync;\n-    int64  syncrate;\n+    int    wantsync; // do we sync to disk?\n+    int64  syncrate; // how often we sync to disk, in nanoseconds\n     int64  lastsync;\n };\n int  waldirlock(Wal*);\n\ndiff --git a/serv.c b/serv.c\n--- a/serv.c\n+++ b/serv.c\n@@ -7,6 +7,8 @@ struct Server srv = {\n     .port = Portdef,\n     .wal = {\n         .filesize = Filesizedef,\n+        .wantsync = 1,\n+        .syncrate = DEFAULT_FSYNC_MS * 1000000,\n     },\n };\n \n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -2054,13 +2054,13 @@ ctbench_put_delete_wal_1024_fsync_000ms(int n)\n void\n ctbench_put_delete_wal_1024_fsync_050ms(int n)\n {\n-    bench_put_delete_size(n, 1024, 512000, 1, 100);\n+    bench_put_delete_size(n, 1024, 512000, 1, 50);\n }\n \n void\n ctbench_put_delete_wal_1024_fsync_200ms(int n)\n {\n-    bench_put_delete_size(n, 1024, 512000, 1, 500);\n+    bench_put_delete_size(n, 1024, 512000, 1, 200);\n }\n \n void\n@@ -2078,13 +2078,13 @@ ctbench_put_delete_wal_8192_fsync_000ms(int n)\n void\n ctbench_put_delete_wal_8192_fsync_050ms(int n)\n {\n-    bench_put_delete_size(n, 8192, 512000, 1, 100);\n+    bench_put_delete_size(n, 8192, 512000, 1, 50);\n }\n \n void\n ctbench_put_delete_wal_8192_fsync_200ms(int n)\n {\n-    bench_put_delete_size(n, 8192, 512000, 1, 500);\n+    bench_put_delete_size(n, 8192, 512000, 1, 200);\n }\n \n void\n\ndiff --git a/testutil.c b/testutil.c\n--- a/testutil.c\n+++ b/testutil.c\n@@ -29,7 +29,8 @@ cttest_opt_none()\n     assert(srv.addr == NULL);\n     assert(job_data_size_limit == JOB_DATA_SIZE_LIMIT_DEFAULT);\n     assert(srv.wal.filesize == Filesizedef);\n-    assert(srv.wal.wantsync == 0);\n+    assert(srv.wal.wantsync == 1);\n+    assert(srv.wal.syncrate == DEFAULT_FSYNC_MS*1000000);\n     assert(srv.user == NULL);\n     assert(srv.wal.dir == NULL);\n     assert(srv.wal.use == 0);\n\ndiff --git a/util.c b/util.c\n--- a/util.c\n+++ b/util.c\n@@ -105,19 +105,21 @@ usage(int code)\n             \"\\n\"\n             \"Options:\\n\"\n             \" -b DIR   write-ahead log directory\\n\"\n-            \" -f MS    fsync at most once every MS milliseconds\"\n-                       \" (use -f0 for \\\"always fsync\\\")\\n\"\n-            \" -F       never fsync (default)\\n\"\n+            \" -f MS    fsync at most once every MS milliseconds (default is %dms);\\n\"\n+            \"          use -f0 for \\\"always fsync\\\"\\n\"\n+            \" -F       never fsync\\n\"\n             \" -l ADDR  listen on address (default is 0.0.0.0)\\n\"\n             \" -p PORT  listen on port (default is \" Portdef \")\\n\"\n             \" -u USER  become user and group\\n\"\n-            \" -z BYTES set the maximum job size in bytes (default is %d, max allowed is %d)\\n\"\n-            \" -s BYTES set the size of each write-ahead log file (default is %d)\\n\"\n-            \"            (will be rounded up to a multiple of 4096 bytes)\\n\"\n+            \" -z BYTES set the maximum job size in bytes (default is %d);\\n\"\n+            \"          max allowed is %d bytes\\n\"\n+            \" -s BYTES set the size of each write-ahead log file (default is %d);\\n\"\n+            \"          will be rounded up to a multiple of 4096 bytes\\n\"\n             \" -v       show version information\\n\"\n             \" -V       increase verbosity\\n\"\n             \" -h       show this help\\n\",\n             progname,\n+            DEFAULT_FSYNC_MS,\n             JOB_DATA_SIZE_LIMIT_DEFAULT,\n             JOB_DATA_SIZE_LIMIT_MAX,\n             Filesizedef);\n", "test_patch": "", "problem_statement": "sync to the disk every 50ms as default behaviour\nThis won't result in degradation of speed but minimizes the data loss\r\non disk in the case of server crash.\r\n\r\nBenchmarks to prove:\r\n```\r\nctbench_put_delete_1024\t\t\t    5000\t    321840 ns/op\t   4.83 MB/s\r\nctbench_put_delete_wal_1024_fsync_000ms\t     100\t  10783976 ns/op\t   0.10 MB/s\r\nctbench_put_delete_wal_1024_fsync_050ms\t    3000\t    401186 ns/op\t   3.01 MB/s\r\nctbench_put_delete_wal_1024_fsync_200ms\t    3000\t    372918 ns/op\t   3.04 MB/s\r\nctbench_put_delete_wal_1024_no_fsync\t    3000\t    358677 ns/op\t   3.05 MB/s\r\n\r\nctbench_put_delete_8192\t\t\t    5000\t    389117 ns/op\t  37.42 MB/s\r\nctbench_put_delete_wal_8192_fsync_000ms\t     200\t   9642472 ns/op\t   1.50 MB/s\r\nctbench_put_delete_wal_8192_fsync_050ms\t    2000\t    555952 ns/op\t  16.20 MB/s\r\nctbench_put_delete_wal_8192_fsync_200ms\t    2000\t    524707 ns/op\t  16.30 MB/s\r\nctbench_put_delete_wal_8192_no_fsync\t    3000\t    505258 ns/op\t  23.37 MB/s\r\n```\r\nFixes #548", "version": "1.11", "language": "C", "created_at": "2020-06-01T14:05:36Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-562", "repo": "beanstalkd/beanstalkd", "pull_number": 562, "base_commit": "fae6722d656d6d1c90c2483bfb4af6d352f937c9", "patch": "diff --git a/doc/protocol.txt b/doc/protocol.txt\n--- a/doc/protocol.txt\n+++ b/doc/protocol.txt\n@@ -42,7 +42,8 @@ the server will reply with one of the following error messages:\n    http://groups.google.com/group/beanstalk-talk.\n \n  - \"BAD_FORMAT\\r\\n\" The client sent a command line that was not well-formed.\n-   This can happen if the line does not end with \\r\\n, if non-numeric\n+   This can happen if the line's length exceeds 224 bytes including \\r\\n,\n+   if the name of a tube exceeds 200 bytes, if non-numeric\n    characters occur where an integer is expected, if the wrong number of\n    arguments are present, or if the command line is mal-formed in any other\n    way.\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -96,13 +96,14 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n #define MSG_JOB_TOO_BIG \"JOB_TOO_BIG\\r\\n\"\n \n // Connection can be in one of these states:\n-#define STATE_WANTCOMMAND 0    // conn expects a command from the client\n-#define STATE_WANTDATA 1       // conn expects a job data\n-#define STATE_SENDJOB 2        // conn sends job to the client\n-#define STATE_SENDWORD 3       // conn sends a line reply\n-#define STATE_WAIT 4           // client awaits for the job reservation\n-#define STATE_BITBUCKET 5      // conn discards content\n-#define STATE_CLOSE 6          // conn should be closed\n+#define STATE_WANT_COMMAND  0  // conn expects a command from the client\n+#define STATE_WANT_DATA     1  // conn expects a job data\n+#define STATE_SEND_JOB      2  // conn sends job to the client\n+#define STATE_SEND_WORD     3  // conn sends a line reply\n+#define STATE_WAIT          4  // client awaits for the job reservation\n+#define STATE_BITBUCKET     5  // conn discards content\n+#define STATE_CLOSE         6  // conn should be closed\n+#define STATE_WANT_ENDLINE  7  // skip until the end of a line\n \n #define OP_UNKNOWN 0\n #define OP_PUT 1\n@@ -326,7 +327,7 @@ epollq_apply()\n }\n \n #define reply_msg(c, m) \\\n-    reply((c), (m), CONSTSTRLEN(m), STATE_SENDWORD)\n+    reply((c), (m), CONSTSTRLEN(m), STATE_SEND_WORD)\n \n #define reply_serr(c, e) \\\n     (twarnx(\"server error: %s\", (e)), reply_msg((c), (e)))\n@@ -380,7 +381,7 @@ reply_job(Conn *c, Job *j, const char *msg)\n {\n     c->out_job = j;\n     c->out_job_sent = 0;\n-    reply_line(c, STATE_SENDJOB, \"%s %\"PRIu64\" %u\\r\\n\",\n+    reply_line(c, STATE_SEND_JOB, \"%s %\"PRIu64\" %u\\r\\n\",\n                msg, j->r.id, j->r.body_size - 2);\n }\n \n@@ -839,7 +840,7 @@ _skip(Conn *c, int64 n, char *msg, int msglen)\n     fill_extra_data(c);\n \n     if (c->in_job_read == 0) {\n-        reply(c, msg, msglen, STATE_SENDWORD);\n+        reply(c, msg, msglen, STATE_SEND_WORD);\n         return;\n     }\n \n@@ -898,13 +899,13 @@ enqueue_incoming_job(Conn *c)\n     j->tube->stat.total_jobs_ct++;\n \n     if (r == 1) {\n-        reply_line(c, STATE_SENDWORD, MSG_INSERTED_FMT, j->r.id);\n+        reply_line(c, STATE_SEND_WORD, MSG_INSERTED_FMT, j->r.id);\n         return;\n     }\n \n     /* out of memory trying to grow the queue, so it gets buried */\n     bury_job(c->srv, j, 0);\n-    reply_line(c, STATE_SENDWORD, MSG_BURIED_FMT, j->r.id);\n+    reply_line(c, STATE_SEND_WORD, MSG_BURIED_FMT, j->r.id);\n }\n \n static uint\n@@ -1124,7 +1125,7 @@ do_stats(Conn *c, fmt_fn fmt, void *data)\n     }\n \n     c->out_job_sent = 0;\n-    reply_line(c, STATE_SENDJOB, \"OK %d\\r\\n\", r - 2);\n+    reply_line(c, STATE_SEND_JOB, \"OK %d\\r\\n\", r - 2);\n }\n \n static void\n@@ -1161,7 +1162,7 @@ do_list_tubes(Conn *c, Ms *l)\n     buf[1] = '\\n';\n \n     c->out_job_sent = 0;\n-    reply_line(c, STATE_SENDJOB, \"OK %zu\\r\\n\", resp_z - 2);\n+    reply_line(c, STATE_SEND_JOB, \"OK %zu\\r\\n\", resp_z - 2);\n }\n \n static int\n@@ -1236,7 +1237,7 @@ maybe_enqueue_incoming_job(Conn *c)\n     }\n \n     /* otherwise we have incomplete data, so just keep waiting */\n-    c->state = STATE_WANTDATA;\n+    c->state = STATE_WANT_DATA;\n }\n \n /* j can be NULL */\n@@ -1284,6 +1285,7 @@ dispatch_cmd(Conn *c)\n \n     /* NUL-terminate this string so we can use strtol and friends */\n     c->cmd[c->cmd_len - 2] = '\\0';\n+    printf(\"%zu %s\\n\", c->cmd_len, c->cmd);\n \n     /* check for possible maliciousness */\n     if (strlen(c->cmd) != c->cmd_len - 2) {\n@@ -1563,7 +1565,7 @@ dispatch_cmd(Conn *c)\n         op_ct[type]++;\n \n         i = kick_jobs(c->srv, c->use, count);\n-        reply_line(c, STATE_SENDWORD, \"KICKED %u\\r\\n\", i);\n+        reply_line(c, STATE_SEND_WORD, \"KICKED %u\\r\\n\", i);\n         return;\n \n     case OP_KICKJOB:\n@@ -1669,7 +1671,7 @@ dispatch_cmd(Conn *c)\n             return;\n         }\n         op_ct[type]++;\n-        reply_line(c, STATE_SENDWORD, \"USING %s\\r\\n\", c->use->name);\n+        reply_line(c, STATE_SEND_WORD, \"USING %s\\r\\n\", c->use->name);\n         return;\n \n     case OP_LIST_TUBES_WATCHED:\n@@ -1701,7 +1703,7 @@ dispatch_cmd(Conn *c)\n         TUBE_ASSIGN(t, NULL);\n         c->use->using_ct++;\n \n-        reply_line(c, STATE_SENDWORD, \"USING %s\\r\\n\", c->use->name);\n+        reply_line(c, STATE_SEND_WORD, \"USING %s\\r\\n\", c->use->name);\n         return;\n \n     case OP_WATCH:\n@@ -1726,7 +1728,7 @@ dispatch_cmd(Conn *c)\n             reply_serr(c, MSG_OUT_OF_MEMORY);\n             return;\n         }\n-        reply_line(c, STATE_SENDWORD, \"WATCHING %zu\\r\\n\", c->watch.len);\n+        reply_line(c, STATE_SEND_WORD, \"WATCHING %zu\\r\\n\", c->watch.len);\n         return;\n \n     case OP_IGNORE:\n@@ -1753,7 +1755,7 @@ dispatch_cmd(Conn *c)\n         if (t)\n             ms_remove(&c->watch, t); /* may free t if refcount => 0 */\n         t = NULL;\n-        reply_line(c, STATE_SENDWORD, \"WATCHING %zu\\r\\n\", c->watch.len);\n+        reply_line(c, STATE_SEND_WORD, \"WATCHING %zu\\r\\n\", c->watch.len);\n         return;\n \n     case OP_QUIT:\n@@ -1789,7 +1791,7 @@ dispatch_cmd(Conn *c)\n         t->pause = delay;\n         t->stat.pause_ct++;\n \n-        reply_line(c, STATE_SENDWORD, \"PAUSED\\r\\n\");\n+        reply_line(c, STATE_SEND_WORD, \"PAUSED\\r\\n\");\n         return;\n \n     default:\n@@ -1865,7 +1867,7 @@ conn_want_command(Conn *c)\n     c->out_job = NULL;\n \n     c->reply_sent = 0; /* now that we're done, reset this */\n-    c->state = STATE_WANTCOMMAND;\n+    c->state = STATE_WANT_COMMAND;\n }\n \n static void\n@@ -1877,7 +1879,7 @@ conn_process_io(Conn *c)\n     struct iovec iov[2];\n \n     switch (c->state) {\n-    case STATE_WANTCOMMAND:\n+    case STATE_WANT_COMMAND:\n         r = read(c->sock.fd, c->cmd + c->cmd_read, LINE_BUF_SIZE - c->cmd_read);\n         if (r == -1) {\n             check_err(c, \"read()\");\n@@ -1888,28 +1890,53 @@ conn_process_io(Conn *c)\n             return;\n         }\n \n-        c->cmd_read += r; /* we got some bytes */\n+        c->cmd_read += r;\n+        c->cmd_len = scan_line_end(c->cmd, c->cmd_read);\n+        if (c->cmd_len) {\n+            // We found complete command line. Bail out to h_conn.\n+            return;\n+        }\n+\n+        // c->cmd_read > LINE_BUF_SIZE can't happen\n+\n+        if (c->cmd_read == LINE_BUF_SIZE) {\n+            // Command line too long.\n+            // Put connection into special state that discards\n+            // the command line until the end line is found.\n+            c->cmd_read = 0; // discard the input so far\n+            c->state = STATE_WANT_ENDLINE;\n+        }\n+        // We have an incomplete line, so just keep waiting.\n+        return;\n \n-        c->cmd_len = scan_line_end(c->cmd, c->cmd_read); /* find the EOL */\n+    case STATE_WANT_ENDLINE:\n+        r = read(c->sock.fd, c->cmd + c->cmd_read, LINE_BUF_SIZE - c->cmd_read);\n+        if (r == -1) {\n+            check_err(c, \"read()\");\n+            return;\n+        }\n+        if (r == 0) {\n+            c->state = STATE_CLOSE;\n+            return;\n+        }\n \n-        /* yay, complete command line */\n+        c->cmd_read += r;\n+        c->cmd_len = scan_line_end(c->cmd, c->cmd_read);\n         if (c->cmd_len) {\n-            dispatch_cmd(c);\n+            // Found the EOL. Reply and reuse whatever was read afer the EOL.\n+            reply_msg(c, MSG_BAD_FORMAT);\n             fill_extra_data(c);\n             return;\n         }\n \n-        /* c->cmd_read > LINE_BUF_SIZE can't happen */\n+        // c->cmd_read > LINE_BUF_SIZE can't happen\n \n-        /* command line too long? */\n         if (c->cmd_read == LINE_BUF_SIZE) {\n-            c->cmd_read = 0; /* discard the input so far */\n-            reply_msg(c, MSG_BAD_FORMAT);\n-            return;\n+            // Keep discarding the input since no EOL was found.\n+            c->cmd_read = 0;\n         }\n+        return;\n \n-        /* otherwise we have an incomplete line, so just keep waiting */\n-        break;\n     case STATE_BITBUCKET: {\n         /* Invert the meaning of in_job_read while throwing away data -- it\n          * counts the bytes that remain to be thrown away. */\n@@ -1930,11 +1957,11 @@ conn_process_io(Conn *c)\n         /* (c->in_job_read < 0) can't happen */\n \n         if (c->in_job_read == 0) {\n-            reply(c, c->reply, c->reply_len, STATE_SENDWORD);\n+            reply(c, c->reply, c->reply_len, STATE_SEND_WORD);\n         }\n         return;\n     }\n-    case STATE_WANTDATA:\n+    case STATE_WANT_DATA:\n         j = c->in_job;\n \n         r = read(c->sock.fd, j->body + c->in_job_read, j->r.body_size -c->in_job_read);\n@@ -1952,8 +1979,8 @@ conn_process_io(Conn *c)\n         /* (j->in_job_read > j->r.body_size) can't happen */\n \n         maybe_enqueue_incoming_job(c);\n-        break;\n-    case STATE_SENDWORD:\n+        return;\n+    case STATE_SEND_WORD:\n         r= write(c->sock.fd, c->reply + c->reply_sent, c->reply_len - c->reply_sent);\n         if (r == -1) {\n             check_err(c, \"write()\");\n@@ -1975,7 +2002,7 @@ conn_process_io(Conn *c)\n \n         /* otherwise we sent an incomplete reply, so just keep waiting */\n         break;\n-    case STATE_SENDJOB:\n+    case STATE_SEND_JOB:\n         j = c->out_job;\n \n         iov[0].iov_base = (void *)(c->reply + c->reply_sent);\n@@ -2024,7 +2051,7 @@ conn_process_io(Conn *c)\n     }\n }\n \n-#define want_command(c) ((c)->sock.fd && ((c)->state == STATE_WANTCOMMAND))\n+#define want_command(c) ((c)->sock.fd && ((c)->state == STATE_WANT_COMMAND))\n #define cmd_data_ready(c) (want_command(c) && (c)->cmd_read)\n \n static void\n@@ -2159,7 +2186,7 @@ h_accept(const int fd, const short which, Server *s)\n         return;\n     }\n \n-    Conn *c = make_conn(cfd, STATE_WANTCOMMAND, default_tube, default_tube);\n+    Conn *c = make_conn(cfd, STATE_WANT_COMMAND, default_tube, default_tube);\n     if (!c) {\n         twarnx(\"make_conn() failed\");\n         close(cfd);\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -380,10 +380,15 @@ cttest_too_long_commandline()\n     int port = SERVER();\n     int fd = mustdiallocal(port);\n     int i;\n-    for (i = 0; i < 5; i++)\n-        mustsend(fd, \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\");\n+    for (i = 0; i < 10; i++)\n+        mustsend(fd, \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"); // 50 bytes\n     mustsend(fd, \"\\r\\n\");\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+    // Issue another command and check that reponse is not \"UNKNOWN_COMMAND\"\n+    // as described in issue #337\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"A\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n }\n \n void\n", "test_patch": "", "problem_statement": "fix response for the command that is too long\nBefore the patch, if a client sent too long command, server would\r\nrespond by BAD_FORMAT, followed by UNKNOWN_COMMAND. This resulted\r\nin desync between client and server.\r\n\r\nThis patch adds another state STATE_WANT_ENDLINE,\r\nwhose purpose is to drop command line until the EOL is found.\r\nClient can send as big command as he want and server will be able\r\nto skip it and return only one error message: BAD_FORMAT.\r\n\r\nSome STATE_* constants were renamed to improve readability.\r\n\r\nFixes #337", "version": "1.11", "language": "C", "created_at": "2019-09-06T08:00:18Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-520", "repo": "beanstalkd/beanstalkd", "pull_number": 520, "base_commit": "18decfbf6ed6ae9a0a29a00ac1923957b955250b", "patch": "diff --git a/testheap.c b/testheap.c\n--- a/testheap.c\n+++ b/testheap.c\n@@ -256,15 +256,16 @@ ctbench_heap_remove(int n)\n         assertf(j, \"allocate job\");\n         heapinsert(&h, j);\n     }\n-    Job *t[n];   // temp storage to deallocate jobs later\n+    Job **jj = calloc(n, sizeof(Job *)); // temp storage to deallocate jobs later\n \n     ctresettimer();\n     for (i = 0; i < n; i++) {\n-        t[i] = heapremove(&h, 0);\n+        jj[i] = (Job *)heapremove(&h, 0);\n     }\n     ctstoptimer();\n \n     free(h.data);\n     for (i = 0; i < n; i++)\n-        job_free(t[i]);\n+        job_free(jj[i]);\n+    free(jj);\n }\n", "test_patch": "", "problem_statement": "fix segfault in ctbench_heap_remove\nAllocate jobs on the heap instead of stack since n can grow big.", "version": "1.11", "language": "C", "created_at": "2019-08-02T14:17:57Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-542", "repo": "beanstalkd/beanstalkd", "pull_number": 542, "base_commit": "9eab16c85d2979292bbdfb14844cd7d584340415", "patch": "diff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -226,7 +226,8 @@ connclose(Conn *c)\n     job_free(c->in_job);\n \n     /* was this a peek or stats command? */\n-    if (c->out_job && c->out_job->r.state == Copy) job_free(c->out_job);\n+    if (c->out_job && c->out_job->r.state == Copy)\n+        job_free(c->out_job);\n \n     c->in_job = c->out_job = NULL;\n     c->in_job_read = 0;\n@@ -237,7 +238,8 @@ connclose(Conn *c)\n     cur_conn_ct--; /* stats */\n \n     remove_waiting_conn(c);\n-    if (has_reserved_job(c)) enqueue_reserved_jobs(c);\n+    if (has_reserved_job(c))\n+        enqueue_reserved_jobs(c);\n \n     ms_clear(&c->watch);\n     c->use->using_ct--;\n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -237,7 +237,7 @@ struct Tube {\n     char name[MAX_TUBE_NAME_LEN];\n     Heap ready;\n     Heap delay;\n-    Ms waiting;                 // set of conns\n+    Ms waiting_conns;           // conns waiting for the job at this moment\n     struct stats stat;\n     uint using_ct;\n     uint watching_ct;\n@@ -338,7 +338,6 @@ void enqueue_reserved_jobs(Conn *c);\n \n void enter_drain_mode(int sig);\n void h_accept(const int fd, const short which, Server *s);\n-void prot_remove_tube(Tube *t);\n int  prot_replay(Server *s, Job *list);\n \n \n@@ -385,13 +384,13 @@ struct Conn {\n     // in_job_read's meaning is inverted -- then it counts the bytes that\n     // remain to be thrown away.\n     int32 in_job_read;\n-    Job   *in_job;                 // a job to be read from the client\n+    Job   *in_job;              // a job to be read from the client\n \n-    Job *out_job;\n-    int out_job_sent;\n+    Job *out_job;               // a job to be sent to the client\n+    int out_job_sent;           // how many bytes of *out_job were sent already\n \n-    Ms  watch;\n-    Job reserved_jobs;             // linked list header\n+    Ms  watch;                  // the set of watched tubes by the connection\n+    Job reserved_jobs;          // linked list header\n };\n int  conn_less(void *ca, void *cb);\n void conn_setpos(void *c, size_t i);\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -358,6 +358,8 @@ static void\n reply_line(Conn*, int, const char*, ...)\n __attribute__((format(printf, 3, 4)));\n \n+// reply_line prints *fmt into c->reply_buffer and\n+// calls reply() for the string and state.\n static void\n reply_line(Conn *c, int state, const char *fmt, ...)\n {\n@@ -377,35 +379,58 @@ reply_line(Conn *c, int state, const char *fmt, ...)\n     reply(c, c->reply_buf, r, state);\n }\n \n+// reply_job tells the connection c which job to send,\n+// and replies with this line: <msg> <job_id> <job_size>.\n static void\n-reply_job(Conn *c, Job *j, const char *word)\n+reply_job(Conn *c, Job *j, const char *msg)\n {\n-    /* tell this connection which job to send */\n     c->out_job = j;\n     c->out_job_sent = 0;\n-\n     reply_line(c, STATE_SENDJOB, \"%s %\"PRIu64\" %u\\r\\n\",\n-               word, j->r.id, j->r.body_size - 2);\n+               msg, j->r.id, j->r.body_size - 2);\n }\n \n+// remove_waiting_conn unsets CONN_TYPE_WAITING for the connection,\n+// removes it from the waiting_conns set of every tube it's watching.\n Conn *\n remove_waiting_conn(Conn *c)\n {\n-    Tube *t;\n-    size_t i;\n-\n-    if (!conn_waiting(c)) return NULL;\n+    // What for is this check? If this function returns NULL then\n+    // functions calling it hit null pointer dereference afterwards\n+    // or just do nothing at best. Maybe NULL result should produce\n+    // INTERNAL_ERROR to the client, meaning a bug in the code.\n+    if (!conn_waiting(c))\n+        return NULL;\n \n     c->type &= ~CONN_TYPE_WAITING;\n     global_stat.waiting_ct--;\n+    size_t i;\n     for (i = 0; i < c->watch.len; i++) {\n-        t = c->watch.items[i];\n+        Tube *t = c->watch.items[i];\n         t->stat.waiting_ct--;\n-        ms_remove(&t->waiting, c);\n+        ms_remove(&t->waiting_conns, c);\n     }\n     return c;\n }\n \n+// enqueue_waiting_conn sets CONN_TYPE_WAITING for the connection,\n+// adds it to the waiting_conns set of every tube it's watching.\n+static void\n+enqueue_waiting_conn(Conn *c)\n+{\n+    c->type |= CONN_TYPE_WAITING;\n+    global_stat.waiting_ct++;\n+    size_t i;\n+    for (i = 0; i < c->watch.len; i++) {\n+        Tube *t = c->watch.items[i];\n+        t->stat.waiting_ct++;\n+        ms_append(&t->waiting_conns, c);\n+    }\n+}\n+\n+// TODO: inline this obscure function to the process_queue();\n+// this function does a sequence of many things, all are side effects,\n+// there is no point to have it as separate function.\n static void\n reserve_job(Conn *c, Job *j)\n {\n@@ -423,35 +448,38 @@ reserve_job(Conn *c, Job *j)\n     reply_job(c, j, MSG_RESERVED);\n }\n \n+// next_eligible_job iterates through all the tubes with awaiting connections,\n+// returns the next ready job with the smallest priority.\n+// If jobs has the same priority it picks the job with smaller id.\n+// All paused tubes with expired pause deadline are unpaused.\n static Job *\n next_eligible_job(int64 now)\n {\n-    Tube *t;\n     size_t i;\n     Job *j = NULL;\n-    Job *candidate;\n \n     for (i = 0; i < tubes.len; i++) {\n-        t = tubes.items[i];\n+        Tube *t = tubes.items[i];\n         if (t->pause) {\n-            if (t->deadline_at > now) continue;\n+            if (t->deadline_at > now)\n+                continue;\n             t->pause = 0;\n         }\n-        if (t->waiting.len && t->ready.len) {\n-            candidate = t->ready.data[0];\n+        if (t->waiting_conns.len && t->ready.len) {\n+            Job *candidate = t->ready.data[0];\n             if (!j || job_pri_less(candidate, j)) {\n                 j = candidate;\n             }\n         }\n     }\n-\n     return j;\n }\n \n+// process_queue performs reservation for every jobs that is awaited for.\n static void\n process_queue()\n {\n-    Job *j;\n+    Job *j = NULL;\n     int64 now = nanoseconds();\n \n     while ((j = next_eligible_job(now))) {\n@@ -461,7 +489,11 @@ process_queue()\n             global_stat.urgent_ct--;\n             j->tube->stat.urgent_ct--;\n         }\n-        reserve_job(remove_waiting_conn(ms_take(&j->tube->waiting)), j);\n+        Conn *next = ms_take(&j->tube->waiting_conns);\n+        next = remove_waiting_conn(next);\n+        // If next==NULL here, we have a bug. See the call above.\n+        // TODO: Report this bug on stderr and skip the conn.\n+        reserve_job(next, j);\n     }\n }\n \n@@ -481,11 +513,13 @@ delay_q_peek()\n         nj = t->delay.data[0];\n         if (!j || nj->r.deadline_at < j->r.deadline_at) j = nj;\n     }\n-\n     return j;\n }\n \n-/* Inserts job j in the tube, returns 1 on success, otherwise 0 */\n+// enqueue_job inserts job j in the tube, returns 1 on success, otherwise 0.\n+// If update_store then it writes an entry to WAL.\n+// On success it processes the queue.\n+// BUG: If maintenance of WAL has failed, it is not reported as error.\n static int\n enqueue_job(Server *s, Job *j, int64 delay, char update_store)\n {\n@@ -495,11 +529,13 @@ enqueue_job(Server *s, Job *j, int64 delay, char update_store)\n     if (delay) {\n         j->r.deadline_at = nanoseconds() + delay;\n         r = heapinsert(&j->tube->delay, j);\n-        if (!r) return 0;\n+        if (!r)\n+            return 0;\n         j->r.state = Delayed;\n     } else {\n         r = heapinsert(&j->tube->ready, j);\n-        if (!r) return 0;\n+        if (!r)\n+            return 0;\n         j->r.state = Ready;\n         ready_ct++;\n         if (j->r.pri < URGENT_THRESHOLD) {\n@@ -515,6 +551,8 @@ enqueue_job(Server *s, Job *j, int64 delay, char update_store)\n         walmaint(&s->wal);\n     }\n \n+    // The call below makes this function do too much.\n+    // TODO: refactor this call outside so the call is explicit (not hidden)?\n     process_queue();\n     return 1;\n }\n@@ -692,21 +730,6 @@ remove_ready_job(Job *j)\n     return j;\n }\n \n-static void\n-enqueue_waiting_conn(Conn *c)\n-{\n-    Tube *t;\n-    size_t i;\n-\n-    global_stat.waiting_ct++;\n-    c->type |= CONN_TYPE_WAITING;\n-    for (i = 0; i < c->watch.len; i++) {\n-        t = c->watch.items[i];\n-        t->stat.waiting_ct++;\n-        ms_append(&t->waiting, c);\n-    }\n-}\n-\n static Job *\n find_reserved_job_in_conn(Conn *c, Job *j)\n {\n@@ -724,12 +747,6 @@ touch_job(Conn *c, Job *j)\n     return j;\n }\n \n-static Job *\n-peek_job(uint64 id)\n-{\n-    return job_find(id);\n-}\n-\n static void\n check_err(Conn *c, const char *s)\n {\n@@ -759,12 +776,6 @@ scan_line_end(const char *s, int size)\n     return 0;\n }\n \n-static size_t\n-cmd_len(Conn *c)\n-{\n-    return scan_line_end(c->cmd, c->cmd_read);\n-}\n-\n /* parse the command line */\n static int\n which_cmd(Conn *c)\n@@ -888,6 +899,8 @@ enqueue_incoming_job(Conn *c)\n \n     /* we have a complete job, so let's stick it in the pqueue */\n     r = enqueue_job(c->srv, j, j->r.delay, 1);\n+\n+    // Dead code: condition cannot happen, r can take 1 or 0 values only.\n     if (r < 0) {\n         reply_serr(c, MSG_INTERNAL_ERROR);\n         return;\n@@ -1260,12 +1273,6 @@ name_is_ok(const char *name, size_t max)\n         strspn(name, NAME_CHARS) == len && name[0] != '-';\n }\n \n-void\n-prot_remove_tube(Tube *t)\n-{\n-    ms_remove(&tubes, t);\n-}\n-\n static void\n dispatch_cmd(Conn *c)\n {\n@@ -1404,8 +1411,8 @@ dispatch_cmd(Conn *c)\n \n         /* So, peek is annoying, because some other connection might free the\n          * job while we are still trying to write it out. So we copy it and\n-         * free the copy when it's done sending, in the \"reset_conn\" function. */\n-        j = job_copy(peek_job(id));\n+         * free the copy when it's done sending, in the \"conn_want_command\" function. */\n+        j = job_copy(job_find(id));\n \n         if (!j) {\n             reply_msg(c, MSG_NOTFOUND);\n@@ -1620,7 +1627,7 @@ dispatch_cmd(Conn *c)\n         }\n         op_ct[type]++;\n \n-        j = peek_job(id);\n+        j = job_find(id);\n         if (!j) {\n             reply_msg(c, MSG_NOTFOUND);\n             return;\n@@ -1851,20 +1858,21 @@ enter_drain_mode(int sig)\n }\n \n static void\n-reset_conn(Conn *c)\n+conn_want_command(Conn *c)\n {\n     epollq_add(c, 'r');\n \n     /* was this a peek or stats command? */\n-    if (c->out_job && c->out_job->r.state == Copy) job_free(c->out_job);\n+    if (c->out_job && c->out_job->r.state == Copy)\n+        job_free(c->out_job);\n     c->out_job = NULL;\n \n     c->reply_sent = 0; /* now that we're done, reset this */\n     c->state = STATE_WANTCOMMAND;\n }\n \n static void\n-conn_data(Conn *c)\n+conn_process_io(Conn *c)\n {\n     int r, to_read;\n     Job *j;\n@@ -1884,7 +1892,7 @@ conn_data(Conn *c)\n \n         c->cmd_read += r; /* we got some bytes */\n \n-        c->cmd_len = cmd_len(c); /* find the EOL */\n+        c->cmd_len = scan_line_end(c->cmd, c->cmd_read); /* find the EOL */\n \n         /* yay, complete command line */\n         if (c->cmd_len) {\n@@ -1962,7 +1970,7 @@ conn_data(Conn *c)\n         /* (c->reply_sent > c->reply_len) can't happen */\n \n         if (c->reply_sent == c->reply_len) {\n-            reset_conn(c);\n+            conn_want_command(c);\n             return;\n         }\n \n@@ -2000,7 +2008,7 @@ conn_data(Conn *c)\n             if (verbose >= 2) {\n                 printf(\">%d job %\"PRIu64\"\\n\", c->sock.fd, j->r.id);\n             }\n-            reset_conn(c);\n+            conn_want_command(c);\n             return;\n         }\n \n@@ -2034,8 +2042,8 @@ h_conn(const int fd, const short which, Conn *c)\n         c->halfclosed = 1;\n     }\n \n-    conn_data(c);\n-    while (cmd_data_ready(c) && (c->cmd_len = cmd_len(c))) {\n+    conn_process_io(c);\n+    while (cmd_data_ready(c) && (c->cmd_len = scan_line_end(c->cmd, c->cmd_read))) {\n         dispatch_cmd(c);\n         fill_extra_data(c);\n     }\n@@ -2075,6 +2083,8 @@ prottick(Server *s)\n             bury_job(s, j, 0);  /* out of memory */\n     }\n \n+    // Unpause every possible tube and process the queue.\n+    // Capture the smallest period from the soonest pause deadline.\n     size_t i;\n     for (i = 0; i < tubes.len; i++) {\n         t = tubes.items[i];\n@@ -2089,7 +2099,7 @@ prottick(Server *s)\n     }\n \n     // Process connections with pending timeouts. Release jobs with expired ttr.\n-    // Capture the period from the soonest connection.\n+    // Capture the smallest period from the soonest connection.\n     while (s->conns.len) {\n         Conn *c = s->conns.data[0];\n         d = c->tickat - now;\n\ndiff --git a/tube.c b/tube.c\n--- a/tube.c\n+++ b/tube.c\n@@ -26,18 +26,18 @@ make_tube(const char *name)\n     Job j = {.tube = NULL};\n     t->buried = j;\n     t->buried.prev = t->buried.next = &t->buried;\n-    ms_init(&t->waiting, NULL, NULL);\n+    ms_init(&t->waiting_conns, NULL, NULL);\n \n     return t;\n }\n \n static void\n tube_free(Tube *t)\n {\n-    prot_remove_tube(t);\n+    ms_remove(&tubes, t);\n     free(t->ready.data);\n     free(t->delay.data);\n-    ms_clear(&t->waiting);\n+    ms_clear(&t->waiting_conns);\n     free(t);\n }\n \n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -11,7 +11,6 @@\n #include <sys/types.h>\n #include <sys/utsname.h>\n #include <sys/socket.h>\n-#include <netinet/in.h>\n #include <inttypes.h>\n #include <stdarg.h>\n #include <signal.h>\n@@ -2122,7 +2121,7 @@ void\n h_accept(const int fd, const short which, Server *s)\n {\n     UNUSED_PARAMETER(which);\n-    struct sockaddr_in6 addr;\n+    struct sockaddr_storage addr;\n \n     socklen_t addrlen = sizeof addr;\n     int cfd = accept(fd, (struct sockaddr *)&addr, &addrlen);\n", "test_patch": "", "problem_statement": "add more comments and style fixes\nNo functional changes in this patch.", "version": "1.11", "language": "C", "created_at": "2019-08-12T09:42:36Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-576", "repo": "beanstalkd/beanstalkd", "pull_number": 576, "base_commit": "e938a56cdf8059f650aa96b4c022e6a046c391b2", "patch": "diff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -1300,7 +1300,6 @@ dispatch_cmd(Conn *c)\n \n     /* NUL-terminate this string so we can use strtol and friends */\n     c->cmd[c->cmd_len - 2] = '\\0';\n-    printf(\"%zu %s\\n\", c->cmd_len, c->cmd);\n \n     /* check for possible maliciousness */\n     if (strlen(c->cmd) != c->cmd_len - 2) {\n", "test_patch": "", "problem_statement": "remove accidental debugging printf\nSpotted by @Thoro: https://github.com/beanstalkd/beanstalkd/pull/562#issuecomment-614499194", "version": "1.11", "language": "C", "created_at": "2020-04-16T08:48:33Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-571", "repo": "beanstalkd/beanstalkd", "pull_number": 571, "base_commit": "9576b6f2271231a93069beb9b2afecd375d32de0", "patch": "diff --git a/doc/protocol.zh-CN.md b/doc/protocol.zh-CN.md\n--- a/doc/protocol.zh-CN.md\n+++ b/doc/protocol.zh-CN.md\n@@ -289,7 +289,7 @@ WATCHING <count>\\r\\n \u8868\u660e\u6210\u529f\n \n * `<count>` \u6574\u578b\u503c\uff0c\u5df2\u76d1\u63a7\u7684 tube \u6570\u91cf\n \n-####`ignore`\n+#### `ignore`\n \n \u4ece\u5df2\u76d1\u63a7\u7684 watch list \u5217\u8868\u4e2d\u79fb\u51fa\u7279\u5b9a\u7684 tube \n \n", "test_patch": "", "problem_statement": "Update protocol.zh-CN.md\nmodify doc format of cmd `ignore`", "version": "1.11", "language": "C", "created_at": "2020-02-23T05:06:36Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-577", "repo": "beanstalkd/beanstalkd", "pull_number": 577, "base_commit": "cde9fe94e6399044af8b7caca5daf3d5550d4bff", "patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -8,6 +8,7 @@ LDLIBS?=\n \n OS?=$(shell uname | tr 'A-Z' 'a-z')\n INSTALL?=install\n+PKG_CONFIG?=pkg-config\n \n ifeq ($(OS),sunos)\n override LDFLAGS += -lxnet -lsocket -lnsl\n@@ -26,7 +27,6 @@ OFILES=\\\n \tnet.o\\\n \tprimes.o\\\n \tprot.o\\\n-\tsd-daemon.o\\\n \tserv.o\\\n \ttime.o\\\n \ttube.o\\\n@@ -43,12 +43,26 @@ TOFILES=\\\n \n HFILES=\\\n \tdat.h\\\n-\tsd-daemon.h\\\n \n ifeq ($(OS),linux)\n    LDLIBS+=-lrt\n endif\n \n+# systemd support can be configured via USE_SYSTEMD:\n+#        no: disabled\n+#       yes: enabled, build fails if libsystemd is not found\n+# otherwise: enabled if libsystemd is found\n+ifneq ($(USE_SYSTEMD),no)\n+ifeq ($(shell $(PKG_CONFIG) --exists libsystemd && echo $$?),0)\n+\tLDLIBS+=$(shell $(PKG_CONFIG) --libs libsystemd)\n+\tCPPFLAGS+=-DHAVE_LIBSYSTEMD\n+else\n+ifeq ($(USE_SYSTEMD),yes)\n+$(error USE_SYSTEMD is set to \"$(USE_SYSTEMD)\", but $(PKG_CONFIG) cannot find libsystemd)\n+endif\n+endif\n+endif\n+\n CLEANFILES=\\\n \tvers.c\\\n \t$(wildcard *.gc*)\n\ndiff --git a/net.c b/net.c\n--- a/net.c\n+++ b/net.c\n@@ -1,5 +1,4 @@\n #include \"dat.h\"\n-#include \"sd-daemon.h\"\n #include <netdb.h>\n #include <stdio.h>\n #include <unistd.h>\n@@ -12,6 +11,10 @@\n #include <netinet/in.h>\n #include <netinet/tcp.h>\n \n+#ifdef HAVE_LIBSYSTEMD\n+#include <systemd/sd-daemon.h>\n+#endif\n+\n static int\n set_nonblocking(int fd)\n {\n@@ -211,6 +214,7 @@ make_unix_socket(char *path)\n int\n make_server_socket(char *host, char *port)\n {\n+#ifdef HAVE_LIBSYSTEMD\n     int fd = -1, r;\n \n     /* See if we got a listen fd from systemd. If so, all socket options etc\n@@ -247,6 +251,7 @@ make_server_socket(char *host, char *port)\n         }\n         return fd;\n     }\n+#endif\n \n     if (host && !strncmp(host, \"unix:\", 5)) {\n         return make_unix_socket(&host[5]);\n\ndiff --git a/sd-daemon.c b/sd-daemon.c\n--- a/sd-daemon.c\n+++ b/sd-daemon.c\n@@ -1,442 +0,0 @@\n-/*-*- Mode: C; c-basic-offset: 8; indent-tabs-mode: nil -*-*/\n-\n-/***\n-  Copyright 2010 Lennart Poettering\n-\n-  Permission is hereby granted, free of charge, to any person\n-  obtaining a copy of this software and associated documentation files\n-  (the \"Software\"), to deal in the Software without restriction,\n-  including without limitation the rights to use, copy, modify, merge,\n-  publish, distribute, sublicense, and/or sell copies of the Software,\n-  and to permit persons to whom the Software is furnished to do so,\n-  subject to the following conditions:\n-\n-  The above copyright notice and this permission notice shall be\n-  included in all copies or substantial portions of the Software.\n-\n-  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n-  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n-  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n-  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n-  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n-  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n-  SOFTWARE.\n-***/\n-\n-#ifndef _GNU_SOURCE\n-#define _GNU_SOURCE\n-#endif\n-\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <sys/socket.h>\n-#include <sys/un.h>\n-#include <fcntl.h>\n-#include <netinet/in.h>\n-#include <stdlib.h>\n-#include <errno.h>\n-#include <unistd.h>\n-#include <string.h>\n-#include <stdarg.h>\n-#include <stdio.h>\n-\n-#include \"sd-daemon.h\"\n-\n-#define UNUSED_PARAMETER(x) (void)(x)\n-\n-int sd_listen_fds(int unset_environment) {\n-\n-#if defined(DISABLE_SYSTEMD) || !defined(__linux__)\n-        UNUSED_PARAMETER(unset_environment);\n-        return 0;\n-#else\n-        int r, fd;\n-        const char *e;\n-        char *p = NULL;\n-        unsigned long l;\n-\n-        if (!(e = getenv(\"LISTEN_PID\"))) {\n-                r = 0;\n-                goto finish;\n-        }\n-\n-        errno = 0;\n-        l = strtoul(e, &p, 10);\n-\n-        if (errno != 0) {\n-                r = -errno;\n-                goto finish;\n-        }\n-\n-        if (!p || *p || l <= 0) {\n-                r = -EINVAL;\n-                goto finish;\n-        }\n-\n-        /* Is this for us? */\n-        if (getpid() != (pid_t) l) {\n-                r = 0;\n-                goto finish;\n-        }\n-\n-        if (!(e = getenv(\"LISTEN_FDS\"))) {\n-                r = 0;\n-                goto finish;\n-        }\n-\n-        errno = 0;\n-        l = strtoul(e, &p, 10);\n-\n-        if (errno != 0) {\n-                r = -errno;\n-                goto finish;\n-        }\n-\n-        if (!p || *p) {\n-                r = -EINVAL;\n-                goto finish;\n-        }\n-\n-        for (fd = SD_LISTEN_FDS_START; fd < SD_LISTEN_FDS_START + (int) l; fd ++) {\n-                int flags;\n-\n-                if ((flags = fcntl(fd, F_GETFD)) < 0) {\n-                        r = -errno;\n-                        goto finish;\n-                }\n-\n-                if (flags & FD_CLOEXEC)\n-                        continue;\n-\n-                if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0) {\n-                        r = -errno;\n-                        goto finish;\n-                }\n-        }\n-\n-        r = (int) l;\n-\n-finish:\n-        if (unset_environment) {\n-                unsetenv(\"LISTEN_PID\");\n-                unsetenv(\"LISTEN_FDS\");\n-        }\n-\n-        return r;\n-#endif\n-}\n-\n-int sd_is_fifo(int fd, const char *path) {\n-        struct stat st_fd;\n-\n-        if (fd < 0)\n-                return -EINVAL;\n-\n-        memset(&st_fd, 0, sizeof(st_fd));\n-        if (fstat(fd, &st_fd) < 0)\n-                return -errno;\n-\n-        if (!S_ISFIFO(st_fd.st_mode))\n-                return 0;\n-\n-        if (path) {\n-                struct stat st_path;\n-\n-                memset(&st_path, 0, sizeof(st_path));\n-                if (stat(path, &st_path) < 0) {\n-\n-                        if (errno == ENOENT || errno == ENOTDIR)\n-                                return 0;\n-\n-                        return -errno;\n-                }\n-\n-                return\n-                        st_path.st_dev == st_fd.st_dev &&\n-                        st_path.st_ino == st_fd.st_ino;\n-        }\n-\n-        return 1;\n-}\n-\n-static int sd_is_socket_internal(int fd, int type, int listening) {\n-        struct stat st_fd;\n-\n-        if (fd < 0 || type < 0)\n-                return -EINVAL;\n-\n-        if (fstat(fd, &st_fd) < 0)\n-                return -errno;\n-\n-        if (!S_ISSOCK(st_fd.st_mode))\n-                return 0;\n-\n-        if (type != 0) {\n-                int other_type = 0;\n-                socklen_t l = sizeof(other_type);\n-\n-                if (getsockopt(fd, SOL_SOCKET, SO_TYPE, &other_type, &l) < 0)\n-                        return -errno;\n-\n-                if (l != sizeof(other_type))\n-                        return -EINVAL;\n-\n-                if (other_type != type)\n-                        return 0;\n-        }\n-\n-        if (listening >= 0) {\n-                int accepting = 0;\n-                socklen_t l = sizeof(accepting);\n-\n-                if (getsockopt(fd, SOL_SOCKET, SO_ACCEPTCONN, &accepting, &l) < 0)\n-                        return -errno;\n-\n-                if (l != sizeof(accepting))\n-                        return -EINVAL;\n-\n-                if (!accepting != !listening)\n-                        return 0;\n-        }\n-\n-        return 1;\n-}\n-\n-union sockaddr_union {\n-        struct sockaddr sa;\n-        struct sockaddr_in in4;\n-        struct sockaddr_in6 in6;\n-        struct sockaddr_un un;\n-        struct sockaddr_storage storage;\n-};\n-\n-int sd_is_socket(int fd, int family, int type, int listening) {\n-        int r;\n-\n-        if (family < 0)\n-                return -EINVAL;\n-\n-        if ((r = sd_is_socket_internal(fd, type, listening)) <= 0)\n-                return r;\n-\n-        if (family > 0) {\n-                union sockaddr_union sockaddr;\n-                socklen_t l;\n-\n-                memset(&sockaddr, 0, sizeof(sockaddr));\n-                l = sizeof(sockaddr);\n-\n-                if (getsockname(fd, &sockaddr.sa, &l) < 0)\n-                        return -errno;\n-\n-                if (l < sizeof(sa_family_t))\n-                        return -EINVAL;\n-\n-                return sockaddr.sa.sa_family == family;\n-        }\n-\n-        return 1;\n-}\n-\n-int sd_is_socket_inet(int fd, int family, int type, int listening, uint16_t port) {\n-        union sockaddr_union sockaddr;\n-        socklen_t l;\n-        int r;\n-\n-        if (family != 0 && family != AF_INET && family != AF_INET6)\n-                return -EINVAL;\n-\n-        if ((r = sd_is_socket_internal(fd, type, listening)) <= 0)\n-                return r;\n-\n-        memset(&sockaddr, 0, sizeof(sockaddr));\n-        l = sizeof(sockaddr);\n-\n-        if (getsockname(fd, &sockaddr.sa, &l) < 0)\n-                return -errno;\n-\n-        if (l < sizeof(sa_family_t))\n-                return -EINVAL;\n-\n-        if (sockaddr.sa.sa_family != AF_INET &&\n-            sockaddr.sa.sa_family != AF_INET6)\n-                return 0;\n-\n-        if (family > 0)\n-                if (sockaddr.sa.sa_family != family)\n-                        return 0;\n-\n-        if (port > 0) {\n-                if (sockaddr.sa.sa_family == AF_INET) {\n-                        if (l < sizeof(struct sockaddr_in))\n-                                return -EINVAL;\n-\n-                        return htons(port) == sockaddr.in4.sin_port;\n-                } else {\n-                        if (l < sizeof(struct sockaddr_in6))\n-                                return -EINVAL;\n-\n-                        return htons(port) == sockaddr.in6.sin6_port;\n-                }\n-        }\n-\n-        return 1;\n-}\n-\n-int sd_is_socket_unix(int fd, int type, int listening, const char *path, size_t length) {\n-        union sockaddr_union sockaddr;\n-        socklen_t l;\n-        int r;\n-\n-        if ((r = sd_is_socket_internal(fd, type, listening)) <= 0)\n-                return r;\n-\n-        memset(&sockaddr, 0, sizeof(sockaddr));\n-        l = sizeof(sockaddr);\n-\n-        if (getsockname(fd, &sockaddr.sa, &l) < 0)\n-                return -errno;\n-\n-        if (l < sizeof(sa_family_t))\n-                return -EINVAL;\n-\n-        if (sockaddr.sa.sa_family != AF_UNIX)\n-                return 0;\n-\n-        if (path) {\n-                if (length <= 0)\n-                        length = strlen(path);\n-\n-                if (length <= 0)\n-                        /* Unnamed socket */\n-                        return l == sizeof(sa_family_t);\n-\n-                if (path[0])\n-                        /* Normal path socket */\n-                        return\n-                                (l >= sizeof(sa_family_t) + length + 1) &&\n-                                memcmp(path, sockaddr.un.sun_path, length+1) == 0;\n-                else\n-                        /* Abstract namespace socket */\n-                        return\n-                                (l == sizeof(sa_family_t) + length) &&\n-                                memcmp(path, sockaddr.un.sun_path, length) == 0;\n-        }\n-\n-        return 1;\n-}\n-\n-int sd_notify(int unset_environment, const char *state) {\n-#if defined(DISABLE_SYSTEMD) || !defined(__linux__) || !defined(SOCK_CLOEXEC)\n-        UNUSED_PARAMETER(unset_environment);\n-        UNUSED_PARAMETER(state);\n-        return 0;\n-#else\n-        int fd = -1, r;\n-        struct msghdr msghdr;\n-        struct iovec iovec;\n-        union sockaddr_union sockaddr;\n-        const char *e;\n-\n-        if (!state) {\n-                r = -EINVAL;\n-                goto finish;\n-        }\n-\n-        if (!(e = getenv(\"NOTIFY_SOCKET\")))\n-                return 0;\n-\n-        /* Must be an abstract socket, or an absolute path */\n-        if ((e[0] != '@' && e[0] != '/') || e[1] == 0) {\n-                r = -EINVAL;\n-                goto finish;\n-        }\n-\n-        if ((fd = socket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC, 0)) < 0) {\n-                r = -errno;\n-                goto finish;\n-        }\n-\n-        memset(&sockaddr, 0, sizeof(sockaddr));\n-        sockaddr.sa.sa_family = AF_UNIX;\n-        strncpy(sockaddr.un.sun_path, e, sizeof(sockaddr.un.sun_path));\n-\n-        if (sockaddr.un.sun_path[0] == '@')\n-                sockaddr.un.sun_path[0] = 0;\n-\n-        memset(&iovec, 0, sizeof(iovec));\n-        iovec.iov_base = (char*) state;\n-        iovec.iov_len = strlen(state);\n-\n-        memset(&msghdr, 0, sizeof(msghdr));\n-        msghdr.msg_name = &sockaddr;\n-        msghdr.msg_namelen = sizeof(sa_family_t) + strlen(e);\n-\n-        if (msghdr.msg_namelen > sizeof(struct sockaddr_un))\n-                msghdr.msg_namelen = sizeof(struct sockaddr_un);\n-\n-        msghdr.msg_iov = &iovec;\n-        msghdr.msg_iovlen = 1;\n-\n-        if (sendmsg(fd, &msghdr, MSG_NOSIGNAL) < 0) {\n-                r = -errno;\n-                goto finish;\n-        }\n-\n-        r = 1;\n-\n-finish:\n-        if (unset_environment)\n-                unsetenv(\"NOTIFY_SOCKET\");\n-\n-        if (fd >= 0)\n-                close(fd);\n-\n-        return r;\n-#endif\n-}\n-\n-int sd_notifyf(int unset_environment, const char *format, ...) {\n-#if defined(DISABLE_SYSTEMD) || !defined(__linux__)\n-        UNUSED_PARAMETER(unset_environment);\n-        UNUSED_PARAMETER(format);\n-        return 0;\n-#else\n-        va_list ap;\n-        char *p = NULL;\n-        int r;\n-\n-        va_start(ap, format);\n-        r = vasprintf(&p, format, ap);\n-        va_end(ap);\n-\n-        if (r < 0 || !p)\n-                return -ENOMEM;\n-\n-        r = sd_notify(unset_environment, p);\n-        free(p);\n-\n-        return r;\n-#endif\n-}\n-\n-int sd_booted(void) {\n-#if defined(DISABLE_SYSTEMD) || !defined(__linux__)\n-        return 0;\n-#else\n-\n-        struct stat a, b;\n-\n-        /* We simply test whether the systemd cgroup hierarchy is\n-         * mounted */\n-\n-        if (lstat(\"/sys/fs/cgroup\", &a) < 0)\n-                return 0;\n-\n-        if (lstat(\"/sys/fs/cgroup/systemd\", &b) < 0)\n-                return 0;\n-\n-        return a.st_dev != b.st_dev;\n-#endif\n-}\n\ndiff --git a/sd-daemon.h b/sd-daemon.h\n--- a/sd-daemon.h\n+++ b/sd-daemon.h\n@@ -1,261 +0,0 @@\n-/*-*- Mode: C; c-basic-offset: 8; indent-tabs-mode: nil -*-*/\n-\n-#ifndef foosddaemonhfoo\n-#define foosddaemonhfoo\n-\n-/***\n-  Copyright 2010 Lennart Poettering\n-\n-  Permission is hereby granted, free of charge, to any person\n-  obtaining a copy of this software and associated documentation files\n-  (the \"Software\"), to deal in the Software without restriction,\n-  including without limitation the rights to use, copy, modify, merge,\n-  publish, distribute, sublicense, and/or sell copies of the Software,\n-  and to permit persons to whom the Software is furnished to do so,\n-  subject to the following conditions:\n-\n-  The above copyright notice and this permission notice shall be\n-  included in all copies or substantial portions of the Software.\n-\n-  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n-  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n-  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n-  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n-  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n-  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n-  SOFTWARE.\n-***/\n-\n-#include <sys/types.h>\n-#include <inttypes.h>\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-/*\n-  Reference implementation of a few systemd related interfaces for\n-  writing daemons. These interfaces are trivial to implement. To\n-  simplify porting we provide this reference implementation.\n-  Applications are welcome to reimplement the algorithms described\n-  here if they do not want to include these two source files.\n-\n-  The following functionality is provided:\n-\n-  - Support for logging with log levels on stderr\n-  - File descriptor passing for socket-based activation\n-  - Daemon startup and status notification\n-  - Detection of systemd boots\n-\n-  You may compile this with -DDISABLE_SYSTEMD to disable systemd\n-  support. This makes all those calls NOPs that are directly related to\n-  systemd (i.e. only sd_is_xxx() will stay useful).\n-\n-  Since this is drop-in code we don't want any of our symbols to be\n-  exported in any case. Hence we declare hidden visibility for all of\n-  them.\n-\n-  You may find an up-to-date version of these source files online:\n-\n-  http://cgit.freedesktop.org/systemd/plain/src/sd-daemon.h\n-  http://cgit.freedesktop.org/systemd/plain/src/sd-daemon.c\n-\n-  This should compile on non-Linux systems, too, but with the\n-  exception of the sd_is_xxx() calls all functions will become NOPs.\n-\n-  See sd-daemon(7) for more information.\n-*/\n-\n-#if __GNUC__ >= 4\n-#define _sd_printf_attr_(a,b) __attribute__ ((format (printf, a, b)))\n-#else\n-#define _sd_printf_attr_(a,b)\n-#endif\n-\n-#if (__GNUC__ >= 4) && !defined(SD_EXPORT_SYMBOLS)\n-#define _sd_hidden_ __attribute__ ((visibility(\"hidden\")))\n-#else\n-#define _sd_hidden_\n-#endif\n-\n-/*\n-  Log levels for usage on stderr:\n-\n-          fprintf(stderr, SD_NOTICE \"Hello World!\\n\");\n-\n-  This is similar to printk() usage in the kernel.\n-*/\n-#define SD_EMERG   \"<0>\"  /* system is unusable */\n-#define SD_ALERT   \"<1>\"  /* action must be taken immediately */\n-#define SD_CRIT    \"<2>\"  /* critical conditions */\n-#define SD_ERR     \"<3>\"  /* error conditions */\n-#define SD_WARNING \"<4>\"  /* warning conditions */\n-#define SD_NOTICE  \"<5>\"  /* normal but significant condition */\n-#define SD_INFO    \"<6>\"  /* informational */\n-#define SD_DEBUG   \"<7>\"  /* debug-level messages */\n-\n-/* The first passed file descriptor is fd 3 */\n-#define SD_LISTEN_FDS_START 3\n-\n-/*\n-  Returns how many file descriptors have been passed, or a negative\n-  errno code on failure. Optionally, removes the $LISTEN_FDS and\n-  $LISTEN_PID file descriptors from the environment (recommended, but\n-  problematic in threaded environments). If r is the return value of\n-  this function you'll find the file descriptors passed as fds\n-  SD_LISTEN_FDS_START to SD_LISTEN_FDS_START+r-1. Returns a negative\n-  errno style error code on failure. This function call ensures that\n-  the FD_CLOEXEC flag is set for the passed file descriptors, to make\n-  sure they are not passed on to child processes. If FD_CLOEXEC shall\n-  not be set, the caller needs to unset it after this call for all file\n-  descriptors that are used.\n-\n-  See sd_listen_fds(3) for more information.\n-*/\n-int sd_listen_fds(int unset_environment) _sd_hidden_;\n-\n-/*\n-  Helper call for identifying a passed file descriptor. Returns 1 if\n-  the file descriptor is a FIFO in the file system stored under the\n-  specified path, 0 otherwise. If path is NULL a path name check will\n-  not be done and the call only verifies if the file descriptor\n-  refers to a FIFO. Returns a negative errno style error code on\n-  failure.\n-\n-  See sd_is_fifo(3) for more information.\n-*/\n-int sd_is_fifo(int fd, const char *path) _sd_hidden_;\n-\n-/*\n-  Helper call for identifying a passed file descriptor. Returns 1 if\n-  the file descriptor is a socket of the specified family (AF_INET,\n-  ...) and type (SOCK_DGRAM, SOCK_STREAM, ...), 0 otherwise. If\n-  family is 0 a socket family check will not be done. If type is 0 a\n-  socket type check will not be done and the call only verifies if\n-  the file descriptor refers to a socket. If listening is > 0 it is\n-  verified that the socket is in listening mode. (i.e. listen() has\n-  been called) If listening is == 0 it is verified that the socket is\n-  not in listening mode. If listening is < 0 no listening mode check\n-  is done. Returns a negative errno style error code on failure.\n-\n-  See sd_is_socket(3) for more information.\n-*/\n-int sd_is_socket(int fd, int family, int type, int listening) _sd_hidden_;\n-\n-/*\n-  Helper call for identifying a passed file descriptor. Returns 1 if\n-  the file descriptor is an Internet socket, of the specified family\n-  (either AF_INET or AF_INET6) and the specified type (SOCK_DGRAM,\n-  SOCK_STREAM, ...), 0 otherwise. If version is 0 a protocol version\n-  check is not done. If type is 0 a socket type check will not be\n-  done. If port is 0 a socket port check will not be done. The\n-  listening flag is used the same way as in sd_is_socket(). Returns a\n-  negative errno style error code on failure.\n-\n-  See sd_is_socket_inet(3) for more information.\n-*/\n-int sd_is_socket_inet(int fd, int family, int type, int listening, uint16_t port) _sd_hidden_;\n-\n-/*\n-  Helper call for identifying a passed file descriptor. Returns 1 if\n-  the file descriptor is an AF_UNIX socket of the specified type\n-  (SOCK_DGRAM, SOCK_STREAM, ...) and path, 0 otherwise. If type is 0\n-  a socket type check will not be done. If path is NULL a socket path\n-  check will not be done. For normal AF_UNIX sockets set length to\n-  0. For abstract namespace sockets set length to the length of the\n-  socket name (including the initial 0 byte), and pass the full\n-  socket path in path (including the initial 0 byte). The listening\n-  flag is used the same way as in sd_is_socket(). Returns a negative\n-  errno style error code on failure.\n-\n-  See sd_is_socket_unix(3) for more information.\n-*/\n-int sd_is_socket_unix(int fd, int type, int listening, const char *path, size_t length) _sd_hidden_;\n-\n-/*\n-  Informs systemd about changed daemon state. This takes a number of\n-  newline separated environment-style variable assignments in a\n-  string. The following variables are known:\n-\n-     READY=1      Tells systemd that daemon startup is finished (only\n-                  relevant for services of Type=notify). The passed\n-                  argument is a boolean \"1\" or \"0\". Since there is\n-                  little value in signalling non-readiness the only\n-                  value daemons should send is \"READY=1\".\n-\n-     STATUS=...   Passes a single-line status string back to systemd\n-                  that describes the daemon state. This is free-from\n-                  and can be used for various purposes: general state\n-                  feedback, fsck-like programs could pass completion\n-                  percentages and failing programs could pass a human\n-                  readable error message. Example: \"STATUS=Completed\n-                  66% of file system check...\"\n-\n-     ERRNO=...    If a daemon fails, the errno-style error code,\n-                  formatted as string. Example: \"ERRNO=2\" for ENOENT.\n-\n-     BUSERROR=... If a daemon fails, the D-Bus error-style error\n-                  code. Example: \"BUSERROR=org.freedesktop.DBus.Error.TimedOut\"\n-\n-     MAINPID=...  The main pid of a daemon, in case systemd did not\n-                  fork off the process itself. Example: \"MAINPID=4711\"\n-\n-  Daemons can choose to send additional variables. However, it is\n-  recommened to prefix variable names not listed above with X_.\n-\n-  Returns a negative errno-style error code on failure. Returns > 0\n-  if systemd could be notified, 0 if it couldn't possibly because\n-  systemd is not running.\n-\n-  Example: When a daemon finished starting up, it could issue this\n-  call to notify systemd about it:\n-\n-     sd_notify(0, \"READY=1\");\n-\n-  See sd_notifyf() for more complete examples.\n-\n-  See sd_notify(3) for more information.\n-*/\n-int sd_notify(int unset_environment, const char *state) _sd_hidden_;\n-\n-/*\n-  Similar to sd_notify() but takes a format string.\n-\n-  Example 1: A daemon could send the following after initialization:\n-\n-     sd_notifyf(0, \"READY=1\\n\"\n-                   \"STATUS=Processing requests...\\n\"\n-                   \"MAINPID=%lu\",\n-                   (unsigned long) getpid());\n-\n-  Example 2: A daemon could send the following shortly before\n-  exiting, on failure:\n-\n-     sd_notifyf(0, \"STATUS=Failed to start up: %s\\n\"\n-                   \"ERRNO=%i\",\n-                   strerror(errno),\n-                   errno);\n-\n-  See sd_notifyf(3) for more information.\n-*/\n-int sd_notifyf(int unset_environment, const char *format, ...) _sd_printf_attr_(2,3) _sd_hidden_;\n-\n-/*\n-  Returns > 0 if the system was booted with systemd. Returns < 0 on\n-  error. Returns 0 if the system was not booted with systemd. Note\n-  that all of the functions above handle non-systemd boots just\n-  fine. You should NOT protect them with a call to this function. Also\n-  note that this function checks whether the system, not the user\n-  session is controlled by systemd. However the functions above work\n-  for both session and system services.\n-\n-  See sd_booted(3) for more information.\n-*/\n-int sd_booted(void) _sd_hidden_;\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#endif\n\ndiff --git a/util.c b/util.c\n--- a/util.c\n+++ b/util.c\n@@ -5,7 +5,10 @@\n #include <stdio.h>\n #include <string.h>\n #include <stdarg.h>\n-#include \"sd-daemon.h\"\n+\n+#ifdef HAVE_LIBSYSTEMD\n+#include <systemd/sd-daemon.h>\n+#endif\n \n const char *progname;\n \n@@ -86,9 +89,11 @@ zalloc(int n)\n static void\n warn_systemd_ignored_option(char *opt, char *arg)\n {\n+#ifdef HAVE_LIBSYSTEMD\n     if (sd_listen_fds(0) > 0) {\n         warnx(\"inherited listen fd; ignoring option: %s %s\", opt, arg);\n     }\n+#endif\n }\n \n \n", "test_patch": "", "problem_statement": "systemd: replace vendored files with libsystemd\nFixes #501", "version": "1.11", "language": "C", "created_at": "2020-04-19T16:17:22Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-583", "repo": "beanstalkd/beanstalkd", "pull_number": 583, "base_commit": "7f25b6161d6f3fdfa51277ea5110b1971d2b75e1", "patch": "diff --git a/serv.c b/serv.c\n--- a/serv.c\n+++ b/serv.c\n@@ -39,7 +39,6 @@ void srv_acquire_wal(Server *s) {\n void\n srvserve(Server *s)\n {\n-    int r;\n     Socket *sock;\n \n     if (sockinit() == -1) {\n@@ -52,14 +51,7 @@ srvserve(Server *s)\n     s->conns.less = conn_less;\n     s->conns.setpos = conn_setpos;\n \n-    r = listen(s->sock.fd, 1024);\n-    if (r == -1) {\n-        twarn(\"listen\");\n-        return;\n-    }\n-\n-    r = sockwant(&s->sock, 'r');\n-    if (r == -1) {\n+    if (sockwant(&s->sock, 'r') == -1) {\n         twarn(\"sockwant\");\n         exit(2);\n     }\n", "test_patch": "", "problem_statement": "server: remove redundant listen\nThe socket is already listening after a call to make_server_socket.", "version": "1.12", "language": "C", "created_at": "2020-06-03T03:21:43Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-592", "repo": "beanstalkd/beanstalkd", "pull_number": 592, "base_commit": "50b2dab1b90fba536879f0c12f3008f2e410de43", "patch": "diff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -186,7 +186,7 @@ size_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n     \"draining: %s\\n\" \\\n     \"id: %s\\n\" \\\n     \"hostname: %s\\n\" \\\n-    \"os: %s\\n\" \\\n+    \"os: \\\"%s\\\"\\n\" \\\n     \"platform: %s\\n\" \\\n     \"\\r\\n\"\n \n", "test_patch": "", "problem_statement": "Make sure to quote os value in stats cmd\nThis prevents invalid yaml value when os might contain colons (`:`) such as:\r\n`Darwin Gilad-MBP 19.6.0 Darwin Kernel Version 19.6.0: Thu Jun 18 20:49:00 PDT 2020; root:xnu-6153.141.1~1/RELEASE_X86_64 x86_64`", "version": "1.12", "language": "C", "created_at": "2020-08-30T09:09:08Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-643", "repo": "beanstalkd/beanstalkd", "pull_number": 643, "base_commit": "8fc716606e4303ad714188465bb4bdcbf0ed3b01", "patch": "diff --git a/doc/protocol.txt b/doc/protocol.txt\n--- a/doc/protocol.txt\n+++ b/doc/protocol.txt\n@@ -592,6 +592,10 @@ they are not stored on disk with the -b flag.\n \n  - \"cmd-reserve\" is the cumulative number of reserve commands.\n \n+ - \"cmd-reserve-with-timeout\" is the cumulative number of reserve-with-timeout commands.\n+\n+ - \"cmd-touch\" is the cumulative number of touch commands.\n+\n  - \"cmd-use\" is the cumulative number of use commands.\n \n  - \"cmd-watch\" is the cumulative number of watch commands.\n", "test_patch": "", "problem_statement": "Add Missing Stats\nI noticed a few stats were missing from protocol.txt.", "version": "1.12", "language": "C", "created_at": "2023-02-09T03:45:23Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-484", "repo": "beanstalkd/beanstalkd", "pull_number": 484, "base_commit": "5ec9d64a418e8f72eddeaad0d8027cd108f9bc9f", "patch": "diff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -117,10 +117,7 @@ after_success:\n               --remove $(pwd)/lcov.info \"ct/*\" \\\n               --remove $(pwd)/lcov.info \"adm/*\" \\\n               --remove $(pwd)/lcov.info \"pkg/*\" \\\n-              --remove $(pwd)/lcov.info \"testheap.c\" \\\n-              --remove $(pwd)/lcov.info \"testjobs.c\" \\\n-              --remove $(pwd)/lcov.info \"testserv.c\" \\\n-              --remove $(pwd)/lcov.info \"testutil.c\" \\\n+              --remove $(pwd)/lcov.info \"test*.c\" \\\n               --compat-libtool \\\n               --output-file $(pwd)/lcov.info\n \n\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -37,6 +37,7 @@ OFILES=\\\n TOFILES=\\\n \ttestheap.o\\\n \ttestjobs.o\\\n+\ttestms.o\\\n \ttestserv.o\\\n \ttestutil.o\\\n \n\ndiff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -200,7 +200,7 @@ conn_ready(Conn *c)\n {\n     size_t i;\n \n-    for (i = 0; i < c->watch.used; i++) {\n+    for (i = 0; i < c->watch.len; i++) {\n         if (((tube) c->watch.items[i])->ready.len)\n             return 1;\n     }\n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -24,7 +24,6 @@ typedef struct Socket Socket;\n typedef struct Server Server;\n typedef struct Wal    Wal;\n \n-typedef void(*ms_event_fn)(ms a, void *item, size_t i);\n typedef void(*Handle)(void*, int rw);\n typedef int(FAlloc)(int, int);\n \n@@ -130,12 +129,29 @@ int sockinit(void);\n int sockwant(Socket*, int);\n int socknext(Socket**, int64);\n \n+\n+// ms_event_fn is called with the element being inserted/removed and its position.\n+typedef void(*ms_event_fn)(ms a, void *item, size_t i);\n+\n+// Resizable multiset\n struct ms {\n-    size_t used, cap, last;\n+    size_t len;                // amount of stored elements\n+    size_t cap;                // capacity\n+    size_t last;               // position of last taken element\n     void **items;\n-    ms_event_fn oninsert, onremove;\n+\n+    ms_event_fn oninsert;      // called on insertion of an element\n+    ms_event_fn onremove;      // called on removal of an element\n };\n \n+void ms_init(ms a, ms_event_fn oninsert, ms_event_fn onremove);\n+void ms_clear(ms a);\n+int ms_append(ms a, void *item);\n+int ms_remove(ms a, void *item);\n+int ms_contains(ms a, void *item);\n+void *ms_take(ms a);\n+\n+\n enum\n {\n     Walver = 7\n@@ -223,15 +239,6 @@ extern const char *progname;\n int64 nanoseconds(void);\n int   rawfalloc(int fd, int len);\n \n-\n-void ms_init(ms a, ms_event_fn oninsert, ms_event_fn onremove);\n-void ms_clear(ms a);\n-int ms_append(ms a, void *item);\n-int ms_remove(ms a, void *item);\n-int ms_contains(ms a, void *item);\n-void *ms_take(ms a);\n-\n-\n #define make_job(pri,delay,ttr,body_size,tube) make_job_with_id(pri,delay,ttr,body_size,tube,0)\n \n job allocate_job(int body_size);\n\ndiff --git a/ms.c b/ms.c\n--- a/ms.c\n+++ b/ms.c\n@@ -6,7 +6,7 @@\n void\n ms_init(ms a, ms_event_fn oninsert, ms_event_fn onremove)\n {\n-    a->used = a->cap = a->last = 0;\n+    a->len = a->cap = a->last = 0;\n     a->items = NULL;\n     a->oninsert = oninsert;\n     a->onremove = onremove;\n@@ -19,9 +19,10 @@ grow(ms a)\n     size_t ncap = (a->cap << 1) ? : 1;\n \n     nitems = malloc(ncap * sizeof(void *));\n-    if (!nitems) return;\n+    if (!nitems)\n+        return;\n \n-    memcpy(nitems, a->items, a->used * sizeof(void *));\n+    memcpy(nitems, a->items, a->len * sizeof(void *));\n     free(a->items);\n     a->items = nitems;\n     a->cap = ncap;\n@@ -30,11 +31,14 @@ grow(ms a)\n int\n ms_append(ms a, void *item)\n {\n-    if (a->used >= a->cap) grow(a);\n-    if (a->used >= a->cap) return 0;\n-\n-    a->items[a->used++] = item;\n-    if (a->oninsert) a->oninsert(a, item, a->used - 1);\n+    if (a->len >= a->cap)\n+        grow(a);\n+    if (a->len >= a->cap)\n+        return 0;\n+\n+    a->items[a->len++] = item;\n+    if (a->oninsert)\n+        a->oninsert(a, item, a->len - 1);\n     return 1;\n }\n \n@@ -43,12 +47,14 @@ ms_delete(ms a, size_t i)\n {\n     void *item;\n \n-    if (i >= a->used) return 0;\n+    if (i >= a->len)\n+        return 0;\n     item = a->items[i];\n-    a->items[i] = a->items[--a->used];\n+    a->items[i] = a->items[--a->len];\n \n     /* it has already been removed now */\n-    if (a->onremove) a->onremove(a, item, i);\n+    if (a->onremove)\n+        a->onremove(a, item, i);\n     return 1;\n }\n \n@@ -65,8 +71,9 @@ ms_remove(ms a, void *item)\n {\n     size_t i;\n \n-    for (i = 0; i < a->used; i++) {\n-        if (a->items[i] == item) return ms_delete(a, i);\n+    for (i = 0; i < a->len; i++) {\n+        if (a->items[i] == item)\n+            return ms_delete(a, i);\n     }\n     return 0;\n }\n@@ -76,8 +83,9 @@ ms_contains(ms a, void *item)\n {\n     size_t i;\n \n-    for (i = 0; i < a->used; i++) {\n-        if (a->items[i] == item) return 1;\n+    for (i = 0; i < a->len; i++) {\n+        if (a->items[i] == item)\n+            return 1;\n     }\n     return 0;\n }\n@@ -87,9 +95,13 @@ ms_take(ms a)\n {\n     void *item;\n \n-    if (!a->used) return NULL;\n+    if (!a->len)\n+        return NULL;\n \n-    a->last = a->last % a->used;\n+    // The result of last behaviour is that ms_take returns the oldest elements\n+    // first, exception is a row of multiple take calls without inserts on ms\n+    // of even number of elements. See the test.\n+    a->last = a->last % a->len;\n     item = a->items[a->last];\n     ms_delete(a, a->last);\n     ++a->last;\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -367,7 +367,7 @@ remove_waiting_conn(Conn *c)\n \n     c->type &= ~CONN_TYPE_WAITING;\n     global_stat.waiting_ct--;\n-    for (i = 0; i < c->watch.used; i++) {\n+    for (i = 0; i < c->watch.len; i++) {\n         t = c->watch.items[i];\n         t->stat.waiting_ct--;\n         ms_remove(&t->waiting, c);\n@@ -399,13 +399,13 @@ next_eligible_job(int64 now)\n     size_t i;\n     job j = NULL, candidate;\n \n-    for (i = 0; i < tubes.used; i++) {\n+    for (i = 0; i < tubes.len; i++) {\n         t = tubes.items[i];\n         if (t->pause) {\n             if (t->deadline_at > now) continue;\n             t->pause = 0;\n         }\n-        if (t->waiting.used && t->ready.len) {\n+        if (t->waiting.len && t->ready.len) {\n             candidate = t->ready.data[0];\n             if (!j || job_pri_less(candidate, j)) {\n                 j = candidate;\n@@ -440,7 +440,7 @@ delay_q_peek()\n     tube t;\n     job j = NULL, nj;\n \n-    for (i = 0; i < tubes.used; i++) {\n+    for (i = 0; i < tubes.len; i++) {\n         t = tubes.items[i];\n         if (t->delay.len == 0) {\n             continue;\n@@ -567,7 +567,7 @@ get_delayed_job_ct()\n     size_t i;\n     uint count = 0;\n \n-    for (i = 0; i < tubes.used; i++) {\n+    for (i = 0; i < tubes.len; i++) {\n         t = tubes.items[i];\n         count += t->delay.len;\n     }\n@@ -670,7 +670,7 @@ enqueue_waiting_conn(Conn *c)\n \n     global_stat.waiting_ct++;\n     c->type |= CONN_TYPE_WAITING;\n-    for (i = 0; i < c->watch.used; i++) {\n+    for (i = 0; i < c->watch.len; i++) {\n         t = c->watch.items[i];\n         t->stat.waiting_ct++;\n         ms_append(&t->waiting, c);\n@@ -917,7 +917,7 @@ fmt_stats(char *buf, size_t size, void *x)\n             timeout_ct,\n             global_stat.total_jobs_ct,\n             job_data_size_limit,\n-            tubes.used,\n+            tubes.len,\n             count_cur_conns(),\n             count_cur_producers(),\n             count_cur_workers(),\n@@ -1053,7 +1053,7 @@ do_list_tubes(Conn *c, ms l)\n \n     /* first, measure how big a buffer we will need */\n     resp_z = 6; /* initial \"---\\n\" and final \"\\r\\n\" */\n-    for (i = 0; i < l->used; i++) {\n+    for (i = 0; i < l->len; i++) {\n         t = l->items[i];\n         resp_z += 3 + strlen(t->name); /* including \"- \" and \"\\n\" */\n     }\n@@ -1067,7 +1067,7 @@ do_list_tubes(Conn *c, ms l)\n     /* now actually format the response */\n     buf = c->out_job->body;\n     buf += snprintf(buf, 5, \"---\\n\");\n-    for (i = 0; i < l->used; i++) {\n+    for (i = 0; i < l->len; i++) {\n         t = l->items[i];\n         buf += snprintf(buf, 4 + strlen(t->name), \"- %s\\n\", t->name);\n     }\n@@ -1553,26 +1553,26 @@ dispatch_cmd(Conn *c)\n         TUBE_ASSIGN(t, NULL);\n         if (!r) return reply_serr(c, MSG_OUT_OF_MEMORY);\n \n-        reply_line(c, STATE_SENDWORD, \"WATCHING %zu\\r\\n\", c->watch.used);\n+        reply_line(c, STATE_SENDWORD, \"WATCHING %zu\\r\\n\", c->watch.len);\n         break;\n     case OP_IGNORE:\n         name = c->cmd + CMD_IGNORE_LEN;\n         if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT);\n         op_ct[type]++;\n \n         t = NULL;\n-        for (i = 0; i < c->watch.used; i++) {\n+        for (i = 0; i < c->watch.len; i++) {\n             t = c->watch.items[i];\n             if (strncmp(t->name, name, MAX_TUBE_NAME_LEN) == 0) break;\n             t = NULL;\n         }\n \n-        if (t && c->watch.used < 2) return reply_msg(c, MSG_NOT_IGNORED);\n+        if (t && c->watch.len < 2) return reply_msg(c, MSG_NOT_IGNORED);\n \n         if (t) ms_remove(&c->watch, t); /* may free t if refcount => 0 */\n         t = NULL;\n \n-        reply_line(c, STATE_SENDWORD, \"WATCHING %zu\\r\\n\", c->watch.used);\n+        reply_line(c, STATE_SENDWORD, \"WATCHING %zu\\r\\n\", c->watch.len);\n         break;\n     case OP_QUIT:\n         c->state = STATE_CLOSE;\n@@ -1888,7 +1888,7 @@ prottick(Server *s)\n     }\n \n     size_t i;\n-    for (i = 0; i < tubes.used; i++) {\n+    for (i = 0; i < tubes.len; i++) {\n         t = tubes.items[i];\n         d = t->deadline_at - now;\n         if (t->pause && d <= 0) {\n\ndiff --git a/testms.c b/testms.c\n--- a/testms.c\n+++ b/testms.c\n@@ -0,0 +1,133 @@\n+#include \"dat.h\"\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <sys/time.h>\n+#include \"ct/ct.h\"\n+\n+\n+void\n+cttest_ms_append()\n+{\n+    ms a = new(struct ms);\n+    ms_init(a, NULL, NULL);\n+\n+    int i = 10;\n+\n+    int ok = ms_append(a, &i);\n+    assertf(a->len == 1, \"a should contain one item\");\n+    assertf(ok, \"should be added\"); \n+\n+    ok = ms_append(a, &i);\n+    assertf(a->len == 2, \"a should contain two items\");\n+    assertf(ok, \"should be added\");\n+\n+    ms_clear(a);\n+    assertf(a->len == 0, \"a should be empty\");\n+    free(a);\n+}\n+\n+void\n+cttest_ms_remove()\n+{\n+\n+    ms a = new(struct ms);\n+    ms_init(a, NULL, NULL);\n+\n+    int i = 1;\n+    ms_append(a, &i);\n+\n+    int j = 2;\n+    int ok = ms_remove(a, &j);\n+    assertf(!ok, \"j should not be removed\");\n+\n+    ok = ms_remove(a, &i);\n+    assertf(ok, \"i should be removed\");\n+\n+    ok = ms_remove(a, &i);\n+    assertf(!ok, \"i was already removed\");\n+\n+    assertf(a->len == 0, \"a should be empty\");\n+    free(a);\n+}\n+\n+void\n+cttest_ms_contains()\n+{\n+\n+    ms a = new(struct ms);\n+    ms_init(a, NULL, NULL);\n+\n+    int i = 1;\n+    ms_append(a, &i);\n+    int ok = ms_contains(a, &i);\n+    assertf(ok, \"i should be in a\");\n+\n+    int j = 2;\n+    ok = ms_contains(a, &j);\n+    assertf(!ok, \"j should not be in a\");\n+\n+    ms_clear(a);\n+    free(a);\n+}\n+\n+void\n+cttest_ms_clear_empty()\n+{\n+\n+    ms a = new(struct ms);\n+    ms_init(a, NULL, NULL);\n+\n+    ms_clear(a);\n+    assertf(a->len == 0, \"a should be empty\");\n+    free(a);\n+}\n+\n+void\n+cttest_ms_take()\n+{\n+    ms a = new(struct ms);\n+    ms_init(a, NULL, NULL);\n+\n+    int i = 10;\n+    int j = 20;\n+\n+    ms_append(a, &i);\n+    ms_append(a, &j);\n+\n+    int *n;\n+    n = (int *)ms_take(a);\n+    assertf(n == &i, \"n should point to i\");\n+\n+    n = (int *)ms_take(a);\n+    assertf(n == &j, \"n should point to j\");\n+\n+    n = (int *)ms_take(a);\n+    assertf(n == NULL, \"n should be NULL; ms is empty\");\n+\n+    free(a);\n+}\n+\n+void\n+cttest_ms_take_sequence()\n+{\n+    size_t i;\n+    int s[] = {1, 2, 3, 4, 5, 6};\n+    int e[] = {1, 2, 3, 6, 5, 4};\n+\n+    ms a = new(struct ms);\n+    ms_init(a, NULL, NULL);\n+\n+    size_t n = sizeof(s)/sizeof(s[0]);\n+    for (i = 0; i < n; i++)\n+        ms_append(a, &s[i]);\n+\n+    for (i = 0; i < n; i++) {\n+        int *got = (int *)ms_take(a);\n+        assert(*got == e[i]);\n+    }\n+\n+    free(a);\n+}\n+\n\ndiff --git a/tube.c b/tube.c\n--- a/tube.c\n+++ b/tube.c\n@@ -80,7 +80,7 @@ tube_find(const char *name)\n     tube t;\n     size_t i;\n \n-    for (i = 0; i < tubes.used; i++) {\n+    for (i = 0; i < tubes.len; i++) {\n         t = tubes.items[i];\n         if (strncmp(t->name, name, MAX_TUBE_NAME_LEN) == 0) return t;\n     }\n", "test_patch": "", "problem_statement": "test ms and improve code style of it\nI have renamed ms.used to ms.len, added comments explaining\r\nthe ms structure. Tests were added, including a little confusing\r\nbehaviour of function ms_take. The order of taken elements is\r\nnot the same as the order of inserts.", "version": "1.11", "language": "C", "created_at": "2019-07-21T15:45:12Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-585", "repo": "beanstalkd/beanstalkd", "pull_number": 585, "base_commit": "c82cb5d4ea0545a2346efc50c61dc2c829526dc1", "patch": "diff --git a/main.c b/main.c\n--- a/main.c\n+++ b/main.c\n@@ -39,7 +39,7 @@ su(const char *user)\n static void\n handle_sigterm_pid1()\n {\n-    raise(SIGKILL);\n+    exit(143);\n }\n \n static void\n", "test_patch": "", "problem_statement": "exit when SIGTERM is received and pid is 1\nIn Linux SIGKILL is blocked for the process with pid of 1. Instead of\r\nthe process sending itself SIGKILL just exit at once.\r\n\r\nFixes #527", "version": "1.12", "language": "C", "created_at": "2020-07-01T20:09:56Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-616", "repo": "beanstalkd/beanstalkd", "pull_number": 616, "base_commit": "e53c2701eb68093f035298f6b63437ddd5e4eab1", "patch": "diff --git a/Dockerfile b/Dockerfile\n--- a/Dockerfile\n+++ b/Dockerfile\n@@ -1,21 +1,13 @@\n+ARG BASE=alpine\n FROM alpine as builder\n-\n-RUN \\\n-\tapk -U upgrade --no-cache && \\\n-\tapk add --no-cache build-base git \n-\n+RUN apk add --no-cache build-base git\n COPY . /tmp/beanstalkd\n-RUN \\ \n-\tcd /tmp/beanstalkd && \\\n-\tmake \n+RUN cd /tmp/beanstalkd && make\n \n ################################\n-FROM alpine\n-\n-RUN apk -U upgrade --no-cache \n+ARG BASE\n+FROM ${BASE}\n \n COPY --from=builder /tmp/beanstalkd/beanstalkd /usr/bin/\n-\n-RUN mkdir /beanstalkd\n EXPOSE 11300\n ENTRYPOINT [\"/usr/bin/beanstalkd\"]\n", "test_patch": "", "problem_statement": "Support different base image\nSupport a different base image via build args.\r\n\r\nFixes #603 \r\n\r\n\r\nAllows users who prefer to self-build to use their own base image with our dockerfile:\r\n\r\n`docker build . --build-arg BASE=ubuntu:latest`\r\n\r\nWill build beanstalkd then put it into the specified base image!", "version": "1.12", "language": "C", "created_at": "2022-01-04T09:38:24Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-663", "repo": "beanstalkd/beanstalkd", "pull_number": 663, "base_commit": "f851b5349cd39d947b5917cf74c2af51fa174146", "patch": "diff --git a/main.c b/main.c\n--- a/main.c\n+++ b/main.c\n@@ -37,7 +37,7 @@ su(const char *user)\n }\n \n static void\n-handle_sigterm_pid1()\n+handle_sigterm_pid1(int _unused)\n {\n     exit(143);\n }\n", "test_patch": "", "problem_statement": "Fix handle_sigterm_pid1() signature\nThis is a signal handler, so it should accept a signal number as the only argument, otherwise GCC 15 fails with the following error:\r\n\r\n```\r\n  main.c: In function 'set_sig_handlers':\r\n  main.c:75:23: error: assignment to '__sighandler_t' {aka 'void (*)(int)'} from incompatible pointer type 'void (*)(void)' [-Wincompatible-pointer-types]\r\n     75 |         sa.sa_handler = handle_sigterm_pid1;\r\n        |                       ^\r\n  main.c:40:1: note: 'handle_sigterm_pid1' declared here\r\n     40 | handle_sigterm_pid1()\r\n        | ^~~~~~~~~~~~~~~~~~~\r\n  In file included from main.c:3:\r\n  /usr/include/signal.h:72:16: note: '__sighandler_t' declared here\r\n     72 | typedef void (*__sighandler_t) (int);\r\n        |                ^~~~~~~~~~~~~~\r\n```\r\n\r\nSee also https://bugs.debian.org/1096364.", "version": "1.13", "language": "C", "created_at": "2025-03-17T09:25:22Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-632", "repo": "beanstalkd/beanstalkd", "pull_number": 632, "base_commit": "dcc64bc902bf0dc2f7cd339d2951c78a0c5c5c20", "patch": "diff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -941,7 +941,7 @@ cttest_stats_tube()\n \n     mustsend(fd, \"stats-tube tubea\\r\\n\");\n     ckrespsub(fd, \"OK \");\n-    ckrespsub(fd, \"\\nname: tubea\\n\");\n+    ckrespsub(fd, \"\\nname: \\\"tubea\\\"\\n\");\n     mustsend(fd, \"stats-tube tubea\\r\\n\");\n     ckrespsub(fd, \"OK \");\n     ckrespsub(fd, \"\\ncurrent-jobs-urgent: 0\\n\");\n@@ -984,7 +984,7 @@ cttest_stats_tube()\n \n     mustsend(fd, \"stats-tube default\\r\\n\");\n     ckrespsub(fd, \"OK \");\n-    ckrespsub(fd, \"\\nname: default\\n\");\n+    ckrespsub(fd, \"\\nname: \\\"default\\\"\\n\");\n     mustsend(fd, \"stats-tube default\\r\\n\");\n     ckrespsub(fd, \"OK \");\n     ckrespsub(fd, \"\\ncurrent-jobs-urgent: 0\\n\");\n", "test_patch": "", "problem_statement": "Fix test regression\nFixes #618", "version": "1.12", "language": "C", "created_at": "2022-11-25T14:35:20Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-463", "repo": "beanstalkd/beanstalkd", "pull_number": 463, "base_commit": "be35414c61f4ee6d59c2c173ffcee458a333dce5", "patch": "diff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -1309,7 +1309,7 @@ dispatch_cmd(Conn *c)\n \n         /* So, peek is annoying, because some other connection might free the\n          * job while we are still trying to write it out. So we copy it and\n-         * then free the copy when it's done sending. */\n+         * free the copy when it's done sending, in the \"reset_conn\" function. */\n         j = job_copy(peek_job(id));\n \n         if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD);\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -321,6 +321,137 @@ cttest_too_long_commandline()\n     ckresp(fd, \"BAD_FORMAT\\r\\n\");\n }\n \n+void\n+cttest_put_in_drain()\n+{\n+    enter_drain_mode(SIGUSR1);\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"x\\r\\n\");\n+    ckresp(fd, \"DRAINING\\r\\n\");\n+}\n+\n+void\n+cttest_peek_ok()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"a\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+\n+    mustsend(fd, \"peek 1\\r\\n\");\n+    ckresp(fd, \"FOUND 1 1\\r\\n\");\n+    ckresp(fd, \"a\\r\\n\");\n+}\n+\n+void\n+cttest_peek_not_found()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"a\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+\n+    mustsend(fd, \"peek 2\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+    mustsend(fd, \"peek 18446744073709551615\\r\\n\");  // max uint64\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+}\n+\n+/*\n+  TODO: Enable this test after fixing #464.\n+void\n+cttest_peek_bad_format()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"peek 18446744073709551616\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+\n+    mustsend(fd, \"peek foo111\\r\\n\");\n+    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n+}\n+*/\n+\n+void\n+cttest_peek_delayed()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"peek-delayed\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"A\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+    mustsend(fd, \"put 0 99 1 1\\r\\n\");\n+    mustsend(fd, \"B\\r\\n\");\n+    ckresp(fd, \"INSERTED 2\\r\\n\");\n+    mustsend(fd, \"put 0 1 1 1\\r\\n\");\n+    mustsend(fd, \"C\\r\\n\");\n+    ckresp(fd, \"INSERTED 3\\r\\n\");\n+\n+    mustsend(fd, \"peek-delayed\\r\\n\");\n+    ckresp(fd, \"FOUND 3 1\\r\\n\");\n+    ckresp(fd, \"C\\r\\n\");\n+\n+    mustsend(fd, \"delete 3\\r\\n\");\n+    ckresp(fd, \"DELETED\\r\\n\");\n+\n+    mustsend(fd, \"peek-delayed\\r\\n\");\n+    ckresp(fd, \"FOUND 2 1\\r\\n\");\n+    ckresp(fd, \"B\\r\\n\");\n+\n+    mustsend(fd, \"delete 2\\r\\n\");\n+    ckresp(fd, \"DELETED\\r\\n\");\n+\n+    mustsend(fd, \"peek-delayed\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+}\n+\n+void\n+cttest_peek_buried_kick()\n+{\n+    port = SERVER();\n+    fd = mustdiallocal(port);\n+    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n+    mustsend(fd, \"A\\r\\n\");\n+    ckresp(fd, \"INSERTED 1\\r\\n\");\n+\n+    mustsend(fd, \"bury 1 0\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+\n+    mustsend(fd, \"peek-buried\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+\n+    mustsend(fd, \"reserve-with-timeout 0\\r\\n\");\n+    ckresp(fd, \"RESERVED 1 1\\r\\n\");\n+    ckresp(fd, \"A\\r\\n\");\n+\n+    mustsend(fd, \"bury 1 0\\r\\n\");\n+    ckresp(fd, \"BURIED\\r\\n\");\n+\n+    mustsend(fd, \"peek-buried\\r\\n\");\n+    ckresp(fd, \"FOUND 1 1\\r\\n\");\n+    ckresp(fd, \"A\\r\\n\");\n+\n+    mustsend(fd, \"kick 1\\r\\n\");\n+    ckresp(fd, \"KICKED 1\\r\\n\");\n+\n+    mustsend(fd, \"peek-buried\\r\\n\");\n+    ckresp(fd, \"NOT_FOUND\\r\\n\");\n+\n+    mustsend(fd, \"peek-ready\\r\\n\");\n+    ckresp(fd, \"FOUND 1 1\\r\\n\");\n+    ckresp(fd, \"A\\r\\n\");\n+\n+    mustsend(fd, \"kick 1\\r\\n\");\n+    ckresp(fd, \"KICKED 0\\r\\n\");\n+}\n+\n void\n cttest_pause()\n {\n\ndiff --git a/testserv.c b/testserv.c\n--- a/testserv.c\n+++ b/testserv.c\n@@ -804,6 +804,68 @@ cttest_reserve_with_timeout_2conns()\n     ckresp(fd0, \"TIMED_OUT\\r\\n\");\n }\n \n+void\n+cttest_reserve_ttr_deadline_soon()\n+{\n+    port = SERVER();\n+    int prod = mustdiallocal(port);\n+\n+    mustsend(prod, \"put 0 0 1 1\\r\\n\");\n+    mustsend(prod, \"a\\r\\n\");\n+    ckresp(prod, \"INSERTED 1\\r\\n\");\n+\n+    mustsend(prod, \"reserve-with-timeout 1\\r\\n\");\n+    ckresp(prod, \"RESERVED 1 1\\r\\n\");\n+    ckresp(prod, \"a\\r\\n\");\n+\n+    // After 0.5s the job should be still reserved.\n+    usleep(500000);\n+    mustsend(prod, \"stats-job 1\\r\\n\");\n+    ckrespsub(prod, \"OK \");\n+    ckrespsub(prod, \"\\nstate: reserved\\n\");\n+\n+    mustsend(prod, \"reserve-with-timeout 1\\r\\n\");\n+    ckresp(prod, \"DEADLINE_SOON\\r\\n\");\n+\n+    // Job should be reserved; last \"reserve\" took less than 1s.\n+    mustsend(prod, \"stats-job 1\\r\\n\");\n+    ckrespsub(prod, \"OK \");\n+    ckrespsub(prod, \"\\nstate: reserved\\n\");\n+\n+    // After 0.7s the job should time out and be ready again.\n+    usleep(700000);\n+    mustsend(prod, \"stats-job 1\\r\\n\");\n+    ckrespsub(prod, \"OK \");\n+    ckrespsub(prod, \"\\nstate: ready\\n\");\n+}\n+\n+void\n+cttest_close_frees_job()\n+{\n+    port = SERVER();\n+    int cons = mustdiallocal(port);\n+    int prod = mustdiallocal(port);\n+    mustsend(cons, \"reserve-with-timeout 1\\r\\n\");\n+\n+    mustsend(prod, \"put 0 0 100 1\\r\\n\");\n+    mustsend(prod, \"a\\r\\n\");\n+    ckresp(prod, \"INSERTED 1\\r\\n\");\n+\n+    ckresp(cons, \"RESERVED 1 1\\r\\n\");\n+    ckresp(cons, \"a\\r\\n\");\n+\n+    mustsend(prod, \"stats-job 1\\r\\n\");\n+    ckrespsub(prod, \"OK \");\n+    ckrespsub(prod, \"\\nstate: reserved\\n\");\n+\n+    // Closed consumer connection should make the job ready again.\n+    close(cons);\n+\n+    mustsend(prod, \"stats-job 1\\r\\n\");\n+    ckrespsub(prod, \"OK \");\n+    ckrespsub(prod, \"\\nstate: ready\\n\");\n+}\n+\n void\n cttest_unpause_tube()\n {\n@@ -831,6 +893,49 @@ cttest_unpause_tube()\n     ckresp(fd1, \"\\r\\n\");\n }\n \n+void\n+cttest_list_tube()\n+{\n+    port = SERVER();\n+    int fd0 = mustdiallocal(port);\n+\n+    mustsend(fd0, \"watch w\\r\\n\");\n+    ckresp(fd0, \"WATCHING 2\\r\\n\");\n+\n+    mustsend(fd0, \"use u\\r\\n\");\n+    ckresp(fd0, \"USING u\\r\\n\");\n+\n+    mustsend(fd0, \"list-tubes\\r\\n\");\n+    ckrespsub(fd0, \"OK \");\n+    ckresp(fd0,\n+           \"---\\n\"\n+           \"- default\\n\"\n+           \"- w\\n\"\n+           \"- u\\n\\r\\n\");\n+\n+    mustsend(fd0, \"list-tube-used\\r\\n\");\n+    ckresp(fd0, \"USING u\\r\\n\");\n+\n+    mustsend(fd0, \"list-tubes-watched\\r\\n\");\n+    ckrespsub(fd0, \"OK \");\n+    ckresp(fd0,\n+           \"---\\n\"\n+           \"- default\\n\"\n+           \"- w\\n\\r\\n\");\n+\n+    mustsend(fd0, \"ignore default\\r\\n\");\n+    ckresp(fd0, \"WATCHING 1\\r\\n\");\n+\n+    mustsend(fd0, \"list-tubes-watched\\r\\n\");\n+    ckrespsub(fd0, \"OK \");\n+    ckresp(fd0,\n+           \"---\\n\"\n+           \"- w\\n\\r\\n\");\n+\n+    mustsend(fd0, \"ignore w\\r\\n\");\n+    ckresp(fd0, \"NOT_IGNORED\\r\\n\");\n+}\n+\n void\n cttest_binlog_empty_exit()\n {\n", "test_patch": "", "problem_statement": "test peek* and kick commands\nDrain mode was quickly tested as well.\r\n\r\nThe cttest_peek_bad_format test function is commented\r\nuntil the issue #464 is fixed.\r\n\r\nUpdates #424", "version": "1.11", "language": "C", "created_at": "2019-07-12T19:42:18Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-656", "repo": "beanstalkd/beanstalkd", "pull_number": 656, "base_commit": "8507076533ce3ecf9e2d35799ae4629486445c45", "patch": "diff --git a/.github/workflows/test-clients.yaml b/.github/workflows/test-clients.yaml\n--- a/.github/workflows/test-clients.yaml\n+++ b/.github/workflows/test-clients.yaml\n@@ -41,8 +41,6 @@ jobs:\n         env:\n           SERVER_HOST: localhost\n   greenstalk:\n-    # Disable this test suite until https://github.com/justinmayhew/greenstalk/issues/9 is fixed\n-    if: ${{ false }}\n     name: Test Greenstalk Python\n     runs-on: ubuntu-latest\n     continue-on-error: true\n\ndiff --git a/.github/workflows/test-clients.yaml b/.github/workflows/test-clients.yaml\n--- a/.github/workflows/test-clients.yaml\n+++ b/.github/workflows/test-clients.yaml\n@@ -7,9 +7,9 @@ jobs:\n     name: Build beanstalkd\n     runs-on: ubuntu-latest\n     steps:\n-      - uses: actions/checkout@v3\n+      - uses: actions/checkout@v4\n       - run: make\n-      - uses: actions/upload-artifact@v3\n+      - uses: actions/upload-artifact@v4\n         with:\n           name: beanstalkd\n           path: beanstalkd\n@@ -25,12 +25,12 @@ jobs:\n         with:\n           php-version: '8.1'\n           tools: phpunit\n-      - uses: actions/download-artifact@v3\n+      - uses: actions/download-artifact@v4\n         with:\n           name: beanstalkd\n       - name: Start beanstalkd\n         run: chmod +x ./beanstalkd && ./beanstalkd &\n-      - uses: actions/checkout@v3\n+      - uses: actions/checkout@v4\n         with:\n           repository: pheanstalk/pheanstalk\n           ref: v5\n@@ -54,10 +54,10 @@ jobs:\n         uses: actions/setup-python@v4\n         with:\n           python-version: ${{ matrix.python-version }}\n-      - uses: actions/checkout@v3\n+      - uses: actions/checkout@v4\n         with:\n           repository: justinmayhew/greenstalk\n-      - uses: actions/download-artifact@v3\n+      - uses: actions/download-artifact@v4\n         id: download\n         with:\n           name: beanstalkd\n@@ -88,10 +88,10 @@ jobs:\n         uses: actions/setup-python@v4\n         with:\n           python-version: ${{ matrix.python-version }}\n-      - uses: actions/checkout@v3\n+      - uses: actions/checkout@v4\n         with:\n           repository: EasyPost/pystalk\n-      - uses: actions/download-artifact@v3\n+      - uses: actions/download-artifact@v4\n         id: download\n         with:\n           name: beanstalkd\n", "test_patch": "", "problem_statement": "Greenstalk #9 fixed\nWorks in my repo, so it LGTM.", "version": "1.13", "language": "C", "created_at": "2024-09-08T12:43:15Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-623", "repo": "beanstalkd/beanstalkd", "pull_number": 623, "base_commit": "4c275d5945299e4562389f9f2ca7c326173d6335", "patch": "diff --git a/adm/systemd/beanstalkd.service b/adm/systemd/beanstalkd.service\n--- a/adm/systemd/beanstalkd.service\n+++ b/adm/systemd/beanstalkd.service\n@@ -4,3 +4,6 @@ Description=Beanstalkd is a simple, fast work queue\n [Service]\n User=nobody\n ExecStart=/usr/bin/beanstalkd\n+\n+[Install]\n+WantedBy=multi-user.target\n", "test_patch": "", "problem_statement": "Update beanstalkd.service\nFixes \"The unit files have no installation config (WantedBy, RequiredBy, Also, Alias\r\nsettings in the [Install] section, and DefaultInstance for template units).\"", "version": "1.12", "language": "C", "created_at": "2022-06-21T17:07:36Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-582", "repo": "beanstalkd/beanstalkd", "pull_number": 582, "base_commit": "8c56cd7316fa11f6396f6260490f239fc0e79e7c", "patch": "diff --git a/CHANGELOG.md b/CHANGELOG.md\n--- a/CHANGELOG.md\n+++ b/CHANGELOG.md\n@@ -0,0 +1,33 @@\n+# Changelog\n+All notable changes to this project will be documented in this file.\n+\n+## [Unreleased]\n+### Added\n+- Support of UNIX domain sockets\n+- Solaris/illumos support\n+- the \"reserve-job\" command \n+- draining status to the \"stats\" command\n+\n+### Changed\n+- specify C99 as required compiler\n+- replaced vendored systemd files with libsystemd\n+- systemd usage can be controlled with USE_SYSTEMD=yes/no parameter\n+\n+## [1.11] - 2019-06-29\n+\n+- add automated testing via TravisCI\n+- add System V init script\n+- enable code coverage\n+- misc. fixes and documentation improvements\n+\n+## [1.10] - 2014-08-05\n+\n+- fix crash on suspend or other EINTR (#220)\n+- document touch command\u2019s TTR reset (#188)\n+- add some basic benchmark tests\n+- add DESTDIR support to Makefile\n+\n+\n+[unreleased]: https://github.com/beanstalkd/beanstalkd/compare/v1.11...HEAD\n+[1.11]:       https://github.com/beanstalkd/beanstalkd/compare/v1.10...v1.11\n+[1.10]:       https://github.com/beanstalkd/beanstalkd/compare/v1.9...v1.10\n\ndiff --git a/CHANGELOG.md b/CHANGELOG.md\n--- a/CHANGELOG.md\n+++ b/CHANGELOG.md\n@@ -3,15 +3,18 @@ All notable changes to this project will be documented in this file.\n \n ## [Unreleased]\n ### Added\n+\n - Support of UNIX domain sockets\n - Solaris/illumos support\n-- the \"reserve-job\" command \n+- the \"reserve-job\" command\n - draining status to the \"stats\" command\n \n ### Changed\n+\n - specify C99 as required compiler\n - replaced vendored systemd files with libsystemd\n - systemd usage can be controlled with USE_SYSTEMD=yes/no parameter\n+- when binlog is used, by default it is synced every 50ms instead of never\n \n ## [1.11] - 2019-06-29\n \n\ndiff --git a/CHANGELOG.md b/CHANGELOG.md\n--- a/CHANGELOG.md\n+++ b/CHANGELOG.md\n@@ -2,19 +2,15 @@\n All notable changes to this project will be documented in this file.\n \n ## [Unreleased]\n-### Added\n-\n-- Support of UNIX domain sockets\n-- Solaris/illumos support\n-- the \"reserve-job\" command\n-- draining status to the \"stats\" command\n-\n-### Changed\n \n+- add support of UNIX domain sockets\n+- add support of Solaris/illumos\n+- add the \"reserve-job\" command\n+- add draining status to the \"stats\" command\n+- make fsync turned on by default when binlog is used: it's synced every 50ms instead of never\n+- replace vendored systemd files with libsystemd\n+- systemd usage can be controlled with USE_SYSTEMD=yes/no\n - specify C99 as required compiler\n-- replaced vendored systemd files with libsystemd\n-- systemd usage can be controlled with USE_SYSTEMD=yes/no parameter\n-- when binlog is used, by default it is synced every 50ms instead of never\n \n ## [1.11] - 2019-06-29\n \n\ndiff --git a/doc/beanstalkd.1 b/doc/beanstalkd.1\n--- a/doc/beanstalkd.1\n+++ b/doc/beanstalkd.1\n@@ -1,112 +1,79 @@\n-.\\\" generated with Ronn/v0.7.3\n-.\\\" http://github.com/rtomayko/ronn/tree/0.7.3\n-.\n-.TH \"BEANSTALKD\" \"1\" \"August 2019\" \"\" \"\"\n-.\n+.\\\" generated with Ronn-NG/v0.8.2\n+.\\\" http://github.com/apjanke/ronn-ng/tree/0.8.2\n+.TH \"BEANSTALKD\" \"1\" \"June 2020\" \"\" \"\"\n .SH \"NAME\"\n \\fBbeanstalkd\\fR \\- simple, fast work queue\n-.\n .SH \"SYNOPSIS\"\n \\fBbeanstalkd\\fR [\\fIoptions\\fR]\n-.\n .SH \"DESCRIPTION\"\n \\fBBeanstalkd\\fR is a simple work\\-queue service\\. Its interface is generic, though it was originally designed for reducing the latency of page views in high\\-volume web applications by running time\\-consuming tasks asynchronously\\.\n-.\n .P\n-When started, \\fBbeanstalkd\\fR opens a socket (or uses a file descriptor provided by the init(1) system, see \\fIENVIRONMENT\\fR) and listens for incoming connections\\. For each connection, it reads a sequence of commands to create, reserve, delete, and otherwise manipulate \"jobs\", units of work to be done\\. See file \\fBdoc/protocol\\.txt\\fR in the \\fBbeanstalkd\\fR distribution for a thorough description of the meaning and format of the \\fBbeanstalkd\\fR protocol\\.\n-.\n+When started, \\fBbeanstalkd\\fR opens a socket (or uses a file descriptor provided by the init(1) system, see \\fI\\%#ENVIRONMENT\\fR) and listens for incoming connections\\. For each connection, it reads a sequence of commands to create, reserve, delete, and otherwise manipulate \"jobs\", units of work to be done\\. See file \\fBdoc/protocol\\.txt\\fR in the \\fBbeanstalkd\\fR distribution for a thorough description of the meaning and format of the \\fBbeanstalkd\\fR protocol\\.\n .SH \"OPTIONS\"\n-.\n .TP\n \\fB\\-b\\fR \\fIpath\\fR\n Use a binlog to keep jobs on persistent storage in directory \\fIpath\\fR\\. Upon startup, \\fBbeanstalkd\\fR will recover any binlog that is present in \\fIpath\\fR, then, during normal operation, append new jobs and changes in state to the binlog\\.\n-.\n .TP\n \\fB\\-f\\fR \\fIms\\fR\n Call fsync(2) at most once every \\fIms\\fR milliseconds\\. Larger values for \\fIms\\fR reduce disk activity and improve speed at the cost of safety\\. A power failure could result in the loss of up to \\fIms\\fR milliseconds of history\\.\n-.\n .IP\n A \\fIms\\fR value of 0 will cause \\fBbeanstalkd\\fR to call fsync every time it writes to the binlog\\.\n-.\n+.IP\n+The default behavior is to sync every 50 ms\\.\n .IP\n (This option has no effect without \\fB\\-b\\fR\\.)\n-.\n .TP\n \\fB\\-F\\fR\n Never call fsync(2)\\. Equivalent to \\fB\\-f\\fR with an infinite \\fIms\\fR value\\.\n-.\n-.IP\n-This is the default behavior\\.\n-.\n .IP\n (This option has no effect without \\fB\\-b\\fR\\.)\n-.\n .TP\n \\fB\\-h\\fR\n Show a brief help message and exit\\.\n-.\n .TP\n \\fB\\-l\\fR \\fIaddr\\fR\n Listen on address \\fIaddr\\fR (default is 0\\.0\\.0\\.0)\\.\n-.\n .IP\n When \\fIaddr\\fR starts with \"unix:\", the unprefixed value of it will be used as the local filesystem path to create a UNIX socket instead of a TCP socket\\. In this case the value of \\fB\\-p\\fR will be ignored\\.\n-.\n .IP\n-(Option \\fB\\-l\\fR has no effect if sd\\-daemon(5) socket activation is being used\\. See also \\fIENVIRONMENT\\fR\\.)\n-.\n+(Option \\fB\\-l\\fR has no effect if sd\\-daemon(5) socket activation is being used\\. See also \\fI\\%#ENVIRONMENT\\fR\\.)\n .TP\n \\fB\\-p\\fR \\fIport\\fR\n Listen on TCP port \\fIport\\fR (default is 11300)\\.\n-.\n .IP\n-(Option \\fB\\-p\\fR has no effect if sd\\-daemon(5) socket activation is being used\\. See also \\fIENVIRONMENT\\fR\\.)\n-.\n+(Option \\fB\\-p\\fR has no effect if sd\\-daemon(5) socket activation is being used\\. See also \\fI\\%#ENVIRONMENT\\fR\\.)\n .TP\n \\fB\\-s\\fR \\fIbytes\\fR\n The size in bytes of each binlog file\\.\n-.\n .IP\n (This option has no effect without \\fB\\-b\\fR\\.)\n-.\n .TP\n \\fB\\-u\\fR \\fIuser\\fR\n Become the user \\fIuser\\fR and its primary group\\.\n-.\n .TP\n \\fB\\-V\\fR\n Increase verbosity\\. May be used more than once to produce more verbose output\\. The output format is subject to change\\.\n-.\n .TP\n \\fB\\-v\\fR\n Print the version string and exit\\.\n-.\n .TP\n \\fB\\-z\\fR \\fIbytes\\fR\n The maximum size in bytes of a job\\.\n-.\n .TP\n \\fB\\-c\\fR\n This flag has no effect\\. It is kept for historical compatibility only\\.\n-.\n .TP\n \\fB\\-n\\fR\n This flag has no effect\\. It is kept for historical compatibility only\\.\n-.\n .SH \"ENVIRONMENT\"\n-.\n .TP\n \\fBLISTEN_PID\\fR, \\fBLISTEN_FDS\\fR\n These variables can be set by init(1)\\. See sd_listen_fds(3) for details\\.\n-.\n .SH \"SEE ALSO\"\n-sd\\-daemon(5), sd_listen_fds(5)\n-.\n+sd\\-daemon(3), sd_listen_fds(3)\n .P\n-Files \\fBREADME\\fR and \\fBdoc/protocol\\.txt\\fR in the \\fBbeanstalkd\\fR distribution\\.\n-.\n+Files \\fBREADME\\.md\\fR and \\fBdoc/protocol\\.txt\\fR in the \\fBbeanstalkd\\fR distribution\\.\n .P\n-\\fIhttps://beanstalkd\\.github\\.io/\\fR\n-.\n+\\fI\\%https://beanstalkd\\.github\\.io/\\fR\n .SH \"AUTHOR\"\n-\\fBBeanstalkd\\fR is written by Keith Rarick and maintained by the community at \\fIhttps://github\\.com/beanstalkd/beanstalkd/issues\\fR\n+\\fBBeanstalkd\\fR is written by Keith Rarick and maintained by the community at \\fI\\%https://github\\.com/beanstalkd/beanstalkd/issues\\fR\n\ndiff --git a/doc/beanstalkd.1.html b/doc/beanstalkd.1.html\n--- a/doc/beanstalkd.1.html\n+++ b/doc/beanstalkd.1.html\n@@ -1,8 +1,8 @@\n <!DOCTYPE html>\n <html>\n <head>\n-  <meta http-equiv='content-type' value='text/html;charset=utf8'>\n-  <meta name='generator' value='Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)'>\n+  <meta http-equiv='content-type' content='text/html;charset=utf8'>\n+  <meta name='generator' content='Ronn-NG/v0.8.2 (http://github.com/apjanke/ronn-ng/tree/0.8.2)'>\n   <title>beanstalkd(1) - simple, fast work queue</title>\n   <style type='text/css' media='all'>\n   /* style: man */\n@@ -68,11 +68,12 @@\n     <li class='tr'>beanstalkd(1)</li>\n   </ol>\n \n-  <h2 id=\"NAME\">NAME</h2>\n+  \n+\n+<h2 id=\"NAME\">NAME</h2>\n <p class=\"man-name\">\n   <code>beanstalkd</code> - <span class=\"man-whatis\">simple, fast work queue</span>\n </p>\n-\n <h2 id=\"SYNOPSIS\">SYNOPSIS</h2>\n \n <p><code>beanstalkd</code> [<var>options</var>]</p>\n@@ -95,63 +96,98 @@ <h2 id=\"DESCRIPTION\">DESCRIPTION</h2>\n <h2 id=\"OPTIONS\">OPTIONS</h2>\n \n <dl>\n-<dt class=\"flush\"><code>-b</code> <var>path</var></dt><dd><p>Use a binlog to keep jobs on persistent storage in directory <var>path</var>.\n+<dt>\n+<code>-b</code> <var>path</var>\n+</dt>\n+<dd>Use a binlog to keep jobs on persistent storage in directory <var>path</var>.\n Upon startup, <code>beanstalkd</code> will recover any binlog that is present\n in <var>path</var>, then, during normal operation, append new jobs and\n-changes in state to the binlog.</p></dd>\n-<dt class=\"flush\"><code>-f</code> <var>ms</var></dt><dd><p>Call <span class=\"man-ref\">fsync<span class=\"s\">(2)</span></span> at most once every <var>ms</var> milliseconds. Larger values\n+changes in state to the binlog.</dd>\n+<dt>\n+<code>-f</code> <var>ms</var>\n+</dt>\n+<dd>Call <span class=\"man-ref\">fsync<span class=\"s\">(2)</span></span> at most once every <var>ms</var> milliseconds. Larger values\n for <var>ms</var> reduce disk activity and improve speed at the cost of\n safety. A power failure could result in the loss of up to <var>ms</var>\n-milliseconds of history.</p>\n+milliseconds of history.\n \n <p>A <var>ms</var> value of 0 will cause <code>beanstalkd</code> to call fsync every time\n it writes to the binlog.</p>\n \n-<p>(This option has no effect without <code>-b</code>.)</p></dd>\n-<dt class=\"flush\"><code>-F</code></dt><dd><p>Never call <span class=\"man-ref\">fsync<span class=\"s\">(2)</span></span>. Equivalent to <code>-f</code> with an infinite <var>ms</var> value.</p>\n+<p>The default behavior is to sync every 50 ms.</p>\n \n-<p>This is the default behavior.</p>\n+<p>(This option has no effect without <code>-b</code>.)</p>\n+</dd>\n+<dt><code>-F</code></dt>\n+<dd>Never call <span class=\"man-ref\">fsync<span class=\"s\">(2)</span></span>. Equivalent to <code>-f</code> with an infinite <var>ms</var> value.\n \n-<p>(This option has no effect without <code>-b</code>.)</p></dd>\n-<dt class=\"flush\"><code>-h</code></dt><dd><p>Show a brief help message and exit.</p></dd>\n-<dt class=\"flush\"><code>-l</code> <var>addr</var></dt><dd><p>Listen on address <var>addr</var> (default is 0.0.0.0).</p>\n+<p>(This option has no effect without <code>-b</code>.)</p>\n+</dd>\n+<dt><code>-h</code></dt>\n+<dd>Show a brief help message and exit.</dd>\n+<dt>\n+<code>-l</code> <var>addr</var>\n+</dt>\n+<dd>Listen on address <var>addr</var> (default is 0.0.0.0).\n \n <p>When <var>addr</var> starts with \"unix:\", the unprefixed value of it will be\n used as the local filesystem path to create a UNIX socket instead of\n a TCP socket. In this case the value of <code>-p</code> will be ignored.</p>\n \n <p>(Option <code>-l</code> has no effect if <span class=\"man-ref\">sd-daemon<span class=\"s\">(5)</span></span> socket activation is\n-being used. See also <a href=\"#ENVIRONMENT\" title=\"ENVIRONMENT\" data-bare-link=\"true\">ENVIRONMENT</a>.)</p></dd>\n-<dt class=\"flush\"><code>-p</code> <var>port</var></dt><dd><p>Listen on TCP port <var>port</var> (default is 11300).</p>\n+being used. See also <a href=\"#ENVIRONMENT\" title=\"ENVIRONMENT\" data-bare-link=\"true\">ENVIRONMENT</a>.)</p>\n+</dd>\n+<dt>\n+<code>-p</code> <var>port</var>\n+</dt>\n+<dd>Listen on TCP port <var>port</var> (default is 11300).\n \n <p>(Option <code>-p</code> has no effect if <span class=\"man-ref\">sd-daemon<span class=\"s\">(5)</span></span> socket activation is\n-being used. See also <a href=\"#ENVIRONMENT\" title=\"ENVIRONMENT\" data-bare-link=\"true\">ENVIRONMENT</a>.)</p></dd>\n-<dt><code>-s</code> <var>bytes</var></dt><dd><p>The size in bytes of each binlog file.</p>\n-\n-<p>(This option has no effect without <code>-b</code>.)</p></dd>\n-<dt class=\"flush\"><code>-u</code> <var>user</var></dt><dd><p>Become the user <var>user</var> and its primary group.</p></dd>\n-<dt class=\"flush\"><code>-V</code></dt><dd><p>Increase verbosity. May be used more than once to produce more\n-verbose output. The output format is subject to change.</p></dd>\n-<dt class=\"flush\"><code>-v</code></dt><dd><p>Print the version string and exit.</p></dd>\n-<dt><code>-z</code> <var>bytes</var></dt><dd><p>The maximum size in bytes of a job.</p></dd>\n-<dt class=\"flush\"><code>-c</code></dt><dd><p>This flag has no effect. It is kept for historical compatibility only.</p></dd>\n-<dt class=\"flush\"><code>-n</code></dt><dd><p>This flag has no effect. It is kept for historical compatibility only.</p></dd>\n+being used. See also <a href=\"#ENVIRONMENT\" title=\"ENVIRONMENT\" data-bare-link=\"true\">ENVIRONMENT</a>.)</p>\n+</dd>\n+<dt>\n+<code>-s</code> <var>bytes</var>\n+</dt>\n+<dd>The size in bytes of each binlog file.\n+\n+<p>(This option has no effect without <code>-b</code>.)</p>\n+</dd>\n+<dt>\n+<code>-u</code> <var>user</var>\n+</dt>\n+<dd>Become the user <var>user</var> and its primary group.</dd>\n+<dt><code>-V</code></dt>\n+<dd>Increase verbosity. May be used more than once to produce more\n+verbose output. The output format is subject to change.</dd>\n+<dt><code>-v</code></dt>\n+<dd>Print the version string and exit.</dd>\n+<dt>\n+<code>-z</code> <var>bytes</var>\n+</dt>\n+<dd>The maximum size in bytes of a job.</dd>\n+<dt><code>-c</code></dt>\n+<dd>This flag has no effect. It is kept for historical compatibility only.</dd>\n+<dt><code>-n</code></dt>\n+<dd>This flag has no effect. It is kept for historical compatibility only.</dd>\n </dl>\n \n \n <h2 id=\"ENVIRONMENT\">ENVIRONMENT</h2>\n \n <dl>\n-<dt><code>LISTEN_PID</code>, <code>LISTEN_FDS</code></dt><dd>These variables can be set by <span class=\"man-ref\">init<span class=\"s\">(1)</span></span>. See <span class=\"man-ref\">sd_listen_fds<span class=\"s\">(3)</span></span> for\n+<dt>\n+<code>LISTEN_PID</code>, <code>LISTEN_FDS</code>\n+</dt>\n+<dd>These variables can be set by <span class=\"man-ref\">init<span class=\"s\">(1)</span></span>. See <span class=\"man-ref\">sd_listen_fds<span class=\"s\">(3)</span></span> for\n details.</dd>\n </dl>\n \n \n <h2 id=\"SEE-ALSO\">SEE ALSO</h2>\n \n-<p><span class=\"man-ref\">sd-daemon<span class=\"s\">(5)</span></span>, <span class=\"man-ref\">sd_listen_fds<span class=\"s\">(5)</span></span></p>\n+<p><span class=\"man-ref\">sd-daemon<span class=\"s\">(3)</span></span>, <span class=\"man-ref\">sd_listen_fds<span class=\"s\">(3)</span></span></p>\n \n-<p>Files <code>README</code> and <code>doc/protocol.txt</code> in the <code>beanstalkd</code>\n+<p>Files <code>README.md</code> and <code>doc/protocol.txt</code> in the <code>beanstalkd</code>\n distribution.</p>\n \n <p><a href=\"https://beanstalkd.github.io/\" data-bare-link=\"true\">https://beanstalkd.github.io/</a></p>\n@@ -161,10 +197,9 @@ <h2 id=\"AUTHOR\">AUTHOR</h2>\n <p><code>Beanstalkd</code> is written by Keith Rarick and maintained by the community at\n <a href=\"https://github.com/beanstalkd/beanstalkd/issues\" data-bare-link=\"true\">https://github.com/beanstalkd/beanstalkd/issues</a></p>\n \n-\n   <ol class='man-decor man-foot man foot'>\n     <li class='tl'></li>\n-    <li class='tc'>August 2019</li>\n+    <li class='tc'>June 2020</li>\n     <li class='tr'>beanstalkd(1)</li>\n   </ol>\n \n\ndiff --git a/doc/beanstalkd.ronn b/doc/beanstalkd.ronn\n--- a/doc/beanstalkd.ronn\n+++ b/doc/beanstalkd.ronn\n@@ -37,13 +37,13 @@ and format of the `beanstalkd` protocol.\n   A <ms> value of 0 will cause `beanstalkd` to call fsync every time\n   it writes to the binlog.\n \n+  The default behavior is to sync every 50 ms.\n+\n   (This option has no effect without `-b`.)\n \n * `-F`:\n   Never call fsync(2). Equivalent to `-f` with an infinite <ms> value.\n \n-  This is the default behavior.\n-\n   (This option has no effect without `-b`.)\n \n * `-h`:\n@@ -97,9 +97,9 @@ and format of the `beanstalkd` protocol.\n \n ## SEE ALSO\n \n-sd-daemon(5), sd_listen_fds(5)\n+sd-daemon(3), sd_listen_fds(3)\n \n-Files `README` and `doc/protocol.txt` in the `beanstalkd`\n+Files `README.md` and `doc/protocol.txt` in the `beanstalkd`\n distribution.\n \n <https://beanstalkd.github.io/>\n", "test_patch": "", "problem_statement": "add changelog\nFixes #452", "version": "1.11", "language": "C", "created_at": "2020-06-01T14:42:14Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-600", "repo": "beanstalkd/beanstalkd", "pull_number": 600, "base_commit": "f221cad3d4392fd50f4d0d5195fec4fac1876522", "patch": "diff --git a/conn.c b/conn.c\n--- a/conn.c\n+++ b/conn.c\n@@ -50,7 +50,6 @@ make_conn(int fd, char start_state, Tube *use, Tube *watch)\n     TUBE_ASSIGN(c->use, use);\n     use->using_ct++;\n \n-    c->sock.fd = fd;\n     c->state = start_state;\n     c->pending_timeout = -1;\n     c->tickpos = 0; // Does not mean anything if in_conns is set to 0.\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -278,6 +278,7 @@ static const char * op_names[] = {\n     CMD_RESERVE_JOB,\n };\n \n+static Job *remove_ready_job(Job *j);\n static Job *remove_buried_job(Job *j);\n \n // epollq_add schedules connection c in the s->conns heap, adds c\n@@ -459,11 +460,9 @@ process_queue()\n     int64 now = nanoseconds();\n \n     while ((j = next_awaited_job(now))) {\n-        heapremove(&j->tube->ready, j->heap_index);\n-        ready_ct--;\n-        if (j->r.pri < URGENT_THRESHOLD) {\n-            global_stat.urgent_ct--;\n-            j->tube->stat.urgent_ct--;\n+        j = remove_ready_job(j);\n+        if (j == NULL) {\n+            continue; // precaution\n         }\n \n         Conn *c = ms_take(&j->tube->waiting_conns);\n\ndiff --git a/dat.h b/dat.h\n--- a/dat.h\n+++ b/dat.h\n@@ -326,7 +326,7 @@ extern struct Ms tubes;\n Tube *make_tube(const char *name);\n void  tube_dref(Tube *t);\n void  tube_iref(Tube *t);\n-Tube *tube_find(const char *name);\n+Tube *tube_find(Ms *tubeset, const char *name);\n Tube *tube_find_or_make(const char *name);\n #define TUBE_ASSIGN(a,b) (tube_dref(a), (a) = (b), tube_iref(a))\n \n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -1700,7 +1700,7 @@ dispatch_cmd(Conn *c)\n         }\n         op_ct[type]++;\n \n-        t = tube_find(name);\n+        t = tube_find(&tubes, name);\n         if (!t) {\n             reply_msg(c, MSG_NOTFOUND);\n             return;\n@@ -1794,14 +1794,7 @@ dispatch_cmd(Conn *c)\n         }\n         op_ct[type]++;\n \n-        t = NULL;\n-        for (i = 0; i < c->watch.len; i++) {\n-            t = c->watch.items[i];\n-            if (strncmp(t->name, name, MAX_TUBE_NAME_LEN) == 0)\n-                break;\n-            t = NULL;\n-        }\n-\n+        t = tube_find(&c->watch, name);\n         if (t && c->watch.len < 2) {\n             reply_msg(c, MSG_NOT_IGNORED);\n             return;\n@@ -1830,7 +1823,7 @@ dispatch_cmd(Conn *c)\n             reply_msg(c, MSG_BAD_FORMAT);\n             return;\n         }\n-        t = tube_find(name);\n+        t = tube_find(&tubes, name);\n         if (!t) {\n             reply_msg(c, MSG_NOTFOUND);\n             return;\n\ndiff --git a/tube.c b/tube.c\n--- a/tube.c\n+++ b/tube.c\n@@ -82,12 +82,12 @@ make_and_insert_tube(const char *name)\n }\n \n Tube *\n-tube_find(const char *name)\n+tube_find(Ms *tubeset, const char *name)\n {\n     size_t i;\n \n-    for (i = 0; i < tubes.len; i++) {\n-        Tube *t = tubes.items[i];\n+    for (i = 0; i < tubeset->len; i++) {\n+        Tube *t = tubeset->items[i];\n         if (strncmp(t->name, name, MAX_TUBE_NAME_LEN) == 0)\n             return t;\n     }\n@@ -97,7 +97,7 @@ tube_find(const char *name)\n Tube *\n tube_find_or_make(const char *name)\n {\n-    Tube *t = tube_find(name);\n+    Tube *t = tube_find(&tubes, name);\n     if (t)\n         return t;\n     return make_and_insert_tube(name);\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -461,10 +461,6 @@ process_queue()\n \n     while ((j = next_awaited_job(now))) {\n         j = remove_ready_job(j);\n-        if (j == NULL) {\n-            continue; // precaution\n-        }\n-\n         Conn *c = ms_take(&j->tube->waiting_conns);\n         if (c == NULL) {\n             twarnx(\"waiting_conns is empty\");\n\ndiff --git a/prot.c b/prot.c\n--- a/prot.c\n+++ b/prot.c\n@@ -461,6 +461,10 @@ process_queue()\n \n     while ((j = next_awaited_job(now))) {\n         j = remove_ready_job(j);\n+        if (j == NULL) {\n+            twarnx(\"job not ready\");\n+            continue;\n+        }\n         Conn *c = ms_take(&j->tube->waiting_conns);\n         if (c == NULL) {\n             twarnx(\"waiting_conns is empty\");\n", "test_patch": "", "problem_statement": "Optimize small details to make code cleaner\n### Modification\r\n- Removed duplicated assignment for `conn.fd`\r\n- Reused existed `remove_ready_job` to remove job from ready heap for `process_queue`\r\n- Enhanced `tube_find` to find in specified tube sets and not just the global tubes, use it in `OP_IGNORE` handler.", "version": "1.12", "language": "C", "created_at": "2021-02-25T07:23:21Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-638", "repo": "beanstalkd/beanstalkd", "pull_number": 638, "base_commit": "554d04908d631151fdf6e44d2b62580602321e8b", "patch": "diff --git a/.github/workflows/test-clients.yaml b/.github/workflows/test-clients.yaml\n--- a/.github/workflows/test-clients.yaml\n+++ b/.github/workflows/test-clients.yaml\n@@ -70,3 +70,33 @@ jobs:\n         env:\n           BEANSTALKD_PATH: ${{steps.download.outputs.download-path}}/beanstalkd\n         run: make test\n+  pystalk:\n+    name: Test Pystalk Python\n+    runs-on: ubuntu-latest\n+    strategy:\n+      matrix:\n+        python-version: [ 3.10 ]\n+    needs:\n+      - build\n+    steps:\n+      - name: Set up Python ${{ matrix.python-version }}\n+        uses: actions/setup-python@v2\n+        with:\n+          python-version: ${{ matrix.python-version }}\n+      - uses: actions/checkout@v3\n+        with:\n+          repository: EasyPost/pystalk\n+      - uses: actions/download-artifact@v2\n+        id: download\n+        with:\n+          name: beanstalkd\n+      - name: Make beanstalkd executable\n+        run: chmod +x ${{steps.download.outputs.download-path}}/beanstalkd\n+      - name: Run beanstalkd -v\n+        run: ${{steps.download.outputs.download-path}}/beanstalkd -v\n+      - name: Install dependencies\n+        run: python -m pip install -r requirements-tests.txt -e .\n+      - name: Run tests\n+        env:\n+          BEANSTALKD_PATH: ${{steps.download.outputs.download-path}}/beanstalkd\n+        run: pytest tests/\n\ndiff --git a/.github/workflows/test-clients.yaml b/.github/workflows/test-clients.yaml\n--- a/.github/workflows/test-clients.yaml\n+++ b/.github/workflows/test-clients.yaml\n@@ -75,7 +75,7 @@ jobs:\n     runs-on: ubuntu-latest\n     strategy:\n       matrix:\n-        python-version: [ 3.10 ]\n+        python-version: [ \"3.10\" ]\n     needs:\n       - build\n     steps:\n\ndiff --git a/.github/workflows/test-clients.yaml b/.github/workflows/test-clients.yaml\n--- a/.github/workflows/test-clients.yaml\n+++ b/.github/workflows/test-clients.yaml\n@@ -7,15 +7,16 @@ jobs:\n     name: Build beanstalkd\n     runs-on: ubuntu-latest\n     steps:\n-      - uses: actions/checkout@v2\n+      - uses: actions/checkout@v3\n       - run: make\n-      - uses: actions/upload-artifact@v2\n+      - uses: actions/upload-artifact@v3\n         with:\n           name: beanstalkd\n           path: beanstalkd\n   pheanstalk:\n     name: Test Pheanstalk PHP\n     runs-on: ubuntu-latest\n+    continue-on-error: true\n     needs:\n       - build\n     steps:\n@@ -24,12 +25,12 @@ jobs:\n         with:\n           php-version: '8.1'\n           tools: phpunit\n-      - uses: actions/download-artifact@v2\n+      - uses: actions/download-artifact@v3\n         with:\n           name: beanstalkd\n       - name: Start beanstalkd\n         run: chmod +x ./beanstalkd && ./beanstalkd &\n-      - uses: actions/checkout@v2\n+      - uses: actions/checkout@v3\n         with:\n           repository: pheanstalk/pheanstalk\n           ref: v5\n@@ -40,20 +41,21 @@ jobs:\n   greenstalk:\n     name: Test Greenstalk Python\n     runs-on: ubuntu-latest\n+    continue-on-error: true\n     strategy:\n       matrix:\n         python-version: [ 3.9 ]\n     needs:\n       - build\n     steps:\n       - name: Set up Python ${{ matrix.python-version }}\n-        uses: actions/setup-python@v2\n+        uses: actions/setup-python@v4\n         with:\n           python-version: ${{ matrix.python-version }}\n-      - uses: actions/checkout@v2\n+      - uses: actions/checkout@v3\n         with:\n           repository: justinmayhew/greenstalk\n-      - uses: actions/download-artifact@v2\n+      - uses: actions/download-artifact@v3\n         id: download\n         with:\n           name: beanstalkd\n@@ -73,20 +75,21 @@ jobs:\n   pystalk:\n     name: Test Pystalk Python\n     runs-on: ubuntu-latest\n+    continue-on-error: true\n     strategy:\n       matrix:\n         python-version: [ \"3.10\" ]\n     needs:\n       - build\n     steps:\n       - name: Set up Python ${{ matrix.python-version }}\n-        uses: actions/setup-python@v2\n+        uses: actions/setup-python@v4\n         with:\n           python-version: ${{ matrix.python-version }}\n       - uses: actions/checkout@v3\n         with:\n           repository: EasyPost/pystalk\n-      - uses: actions/download-artifact@v2\n+      - uses: actions/download-artifact@v3\n         id: download\n         with:\n           name: beanstalkd\n\ndiff --git a/.github/workflows/test-clients.yaml b/.github/workflows/test-clients.yaml\n--- a/.github/workflows/test-clients.yaml\n+++ b/.github/workflows/test-clients.yaml\n@@ -36,8 +36,10 @@ jobs:\n           ref: v5\n       - name: Install dependencies including dev-dependencies\n         run: composer install\n-      - name: Run PHPUnit tests\n+      - name: Run tests\n         run: phpunit\n+        env:\n+          SERVER_HOST: localhost\n   greenstalk:\n     name: Test Greenstalk Python\n     runs-on: ubuntu-latest\n\ndiff --git a/.github/workflows/test-clients.yaml b/.github/workflows/test-clients.yaml\n--- a/.github/workflows/test-clients.yaml\n+++ b/.github/workflows/test-clients.yaml\n@@ -41,6 +41,8 @@ jobs:\n         env:\n           SERVER_HOST: localhost\n   greenstalk:\n+    # Disable this test suite until https://github.com/justinmayhew/greenstalk/issues/9 is fixed\n+    if: ${{ false }}\n     name: Test Greenstalk Python\n     runs-on: ubuntu-latest\n     continue-on-error: true\n", "test_patch": "", "problem_statement": "Add pystalk client\nFixes #637, the tests for pheanstalk now run and pass.\r\nAdds PyStalk client tests.\r\n\r\nGreenstalk still fails so I've disabled it for now.", "version": "1.12", "language": "C", "created_at": "2022-12-05T08:48:17Z", "repo_id": 6040}
{"instance_id": "beanstalkd__beanstalkd-662", "repo": "beanstalkd/beanstalkd", "pull_number": 662, "base_commit": "43a834abe8d22eed01520e9f4b0b26705f3fe744", "patch": "diff --git a/.github/workflows/build-latest.yaml b/.github/workflows/build-latest.yaml\n--- a/.github/workflows/build-latest.yaml\n+++ b/.github/workflows/build-latest.yaml\n@@ -1,15 +1,15 @@\n ---\n-name: Continous integration\n+name: Continuous integration\n on:\n   push:\n-    branches:\n-      - master\n+    tags:\n+      - 'v*'\n jobs:\n   tests:\n     name: Tests\n     runs-on: ubuntu-latest\n     steps:\n-      - uses: actions/checkout@v3\n+      - uses: actions/checkout@v4\n       - name: Tests\n         run: make check\n   build:\n@@ -18,12 +18,27 @@ jobs:\n     needs:\n       - tests\n     steps:\n-      - uses: actions/checkout@v3\n+      - name: Set up Docker Buildx with QEMU\n+        uses: docker/setup-buildx-action@v3\n+      - uses: docker/setup-qemu-action@v3\n+      - uses: actions/checkout@v4\n+      - name: Convert relevant environment variables\n+        id: convert\n+        run: |\n+          echo \"REPO=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')\" >> $GITHUB_ENV\n+          echo \"TAG_VERSION=$(echo '${{ github.ref_name }}' | sed 's/^v//')\" >> $GITHUB_ENV\n       - name: Login to GitHub Container Registry\n-        uses: docker/login-action@v2\n+        uses: docker/login-action@v3\n         with:\n           registry: ghcr.io\n-          username: ${{ github.actor }}\n+          username: ${{ github.repository_owner }}\n           password: ${{ secrets.GITHUB_TOKEN }}\n-      - run: docker build . -t `echo ghcr.io/${{ github.repository }}:latest | tr '[:upper:]' '[:lower:]'`\n-      - run: docker push `echo ghcr.io/${{ github.repository }}:latest | tr '[:upper:]' '[:lower:]'`\n+      - name: Build and push Docker image\n+        uses: docker/build-push-action@v6\n+        with:\n+          file: ./Dockerfile\n+          platforms: linux/amd64,linux/arm64\n+          push: true\n+          tags: |\n+            ghcr.io/${{ env.REPO }}:latest\n+            ghcr.io/${{ env.REPO }}:${{ env.TAG_VERSION }}\n\ndiff --git a/.github/workflows/test-clients.yaml b/.github/workflows/test-clients.yaml\n--- a/.github/workflows/test-clients.yaml\n+++ b/.github/workflows/test-clients.yaml\n@@ -7,9 +7,9 @@ jobs:\n     name: Build beanstalkd\n     runs-on: ubuntu-latest\n     steps:\n-      - uses: actions/checkout@v3\n+      - uses: actions/checkout@v4\n       - run: make\n-      - uses: actions/upload-artifact@v3\n+      - uses: actions/upload-artifact@v4\n         with:\n           name: beanstalkd\n           path: beanstalkd\n@@ -25,7 +25,7 @@ jobs:\n         with:\n           php-version: '8.1'\n           tools: phpunit\n-      - uses: actions/download-artifact@v3\n+      - uses: actions/download-artifact@v4\n         with:\n           name: beanstalkd\n       - name: Start beanstalkd\n@@ -56,12 +56,13 @@ jobs:\n         uses: actions/setup-python@v4\n         with:\n           python-version: ${{ matrix.python-version }}\n-      - uses: actions/checkout@v3\n+      - uses: actions/checkout@v4\n         with:\n           repository: justinmayhew/greenstalk\n-      - uses: actions/download-artifact@v3\n+      - uses: actions/download-artifact@v4\n         id: download\n         with:\n+          #include-hidden-files: true\n           name: beanstalkd\n       - name: Make beanstalkd executable\n         run: chmod +x ${{steps.download.outputs.download-path}}/beanstalkd\n@@ -90,10 +91,10 @@ jobs:\n         uses: actions/setup-python@v4\n         with:\n           python-version: ${{ matrix.python-version }}\n-      - uses: actions/checkout@v3\n+      - uses: actions/checkout@v4\n         with:\n           repository: EasyPost/pystalk\n-      - uses: actions/download-artifact@v3\n+      - uses: actions/download-artifact@v4\n         id: download\n         with:\n           name: beanstalkd\n\ndiff --git a/.github/workflows/build-latest.yaml b/.github/workflows/build-latest.yaml\n--- a/.github/workflows/build-latest.yaml\n+++ b/.github/workflows/build-latest.yaml\n@@ -13,6 +13,9 @@ jobs:\n       - name: Tests\n         run: make check\n   build:\n+    permissions:\n+      packages: write\n+      contents: read\n     name: Docker build\n     runs-on: ubuntu-latest\n     needs:\n\ndiff --git a/.github/workflows/build-latest.yaml b/.github/workflows/build-latest.yaml\n--- a/.github/workflows/build-latest.yaml\n+++ b/.github/workflows/build-latest.yaml\n@@ -34,7 +34,7 @@ jobs:\n         uses: docker/login-action@v3\n         with:\n           registry: ghcr.io\n-          username: ${{ github.repository_owner }}\n+          username: ${{ github.actor }}\n           password: ${{ secrets.GITHUB_TOKEN }}\n       - name: Build and push Docker image\n         uses: docker/build-push-action@v6\n\ndiff --git a/.github/workflows/prs.yaml b/.github/workflows/prs.yaml\n--- a/.github/workflows/prs.yaml\n+++ b/.github/workflows/prs.yaml\n@@ -10,6 +10,6 @@ jobs:\n     name: Tests\n     runs-on: ubuntu-latest\n     steps:\n-      - uses: actions/checkout@v3\n+      - uses: actions/checkout@v4\n       - name: Tests\n-        run: make check\n\\ No newline at end of file\n+        run: make check\n\ndiff --git a/.github/workflows/test-clients.yaml b/.github/workflows/test-clients.yaml\n--- a/.github/workflows/test-clients.yaml\n+++ b/.github/workflows/test-clients.yaml\n@@ -30,7 +30,7 @@ jobs:\n           name: beanstalkd\n       - name: Start beanstalkd\n         run: chmod +x ./beanstalkd && ./beanstalkd &\n-      - uses: actions/checkout@v3\n+      - uses: actions/checkout@v4\n         with:\n           repository: pheanstalk/pheanstalk\n           ref: v5\n@@ -41,8 +41,6 @@ jobs:\n         env:\n           SERVER_HOST: localhost\n   greenstalk:\n-    # Disable this test suite until https://github.com/justinmayhew/greenstalk/issues/9 is fixed\n-    if: ${{ false }}\n     name: Test Greenstalk Python\n     runs-on: ubuntu-latest\n     continue-on-error: true\n\ndiff --git a/.github/workflows/build-latest.yaml b/.github/workflows/build-latest.yaml\n--- a/.github/workflows/build-latest.yaml\n+++ b/.github/workflows/build-latest.yaml\n@@ -6,8 +6,11 @@ on:\n       - 'v*'\n jobs:\n   tests:\n-    name: Tests\n-    runs-on: ubuntu-latest\n+    name: Tests on ${{ matrix.runner }}\n+    runs-on: ${{ matrix.runner }}\n+    strategy:\n+        matrix:\n+          runner: [ubuntu-latest, ubuntu-24.04-arm]\n     steps:\n       - uses: actions/checkout@v4\n       - name: Tests\n\ndiff --git a/.github/workflows/prs.yaml b/.github/workflows/prs.yaml\n--- a/.github/workflows/prs.yaml\n+++ b/.github/workflows/prs.yaml\n@@ -7,8 +7,11 @@ on:\n       - master\n jobs:\n   tests:\n-    name: Tests\n-    runs-on: ubuntu-latest\n+    name: Tests on ${{ matrix.runner }}\n+    runs-on: ${{ matrix.runner }}\n+    strategy:\n+      matrix:\n+        runner: [ubuntu-latest, ubuntu-24.04-arm]\n     steps:\n       - uses: actions/checkout@v4\n       - name: Tests\n\ndiff --git a/.github/workflows/test-clients.yaml b/.github/workflows/test-clients.yaml\n--- a/.github/workflows/test-clients.yaml\n+++ b/.github/workflows/test-clients.yaml\n@@ -5,17 +5,23 @@ on:\n jobs:\n   build:\n     name: Build beanstalkd\n-    runs-on: ubuntu-latest\n+    runs-on: ${{ matrix.runner }}\n+    strategy:\n+      matrix:\n+        runner: [ubuntu-latest, ubuntu-24.04-arm]\n     steps:\n       - uses: actions/checkout@v4\n       - run: make\n       - uses: actions/upload-artifact@v4\n         with:\n-          name: beanstalkd\n+          name: beanstalkd-${{ matrix.runner }}\n           path: beanstalkd\n   pheanstalk:\n     name: Test Pheanstalk PHP\n-    runs-on: ubuntu-latest\n+    runs-on: ${{ matrix.runner }}\n+    strategy:\n+      matrix:\n+        runner: [ubuntu-latest, ubuntu-24.04-arm]\n     continue-on-error: true\n     needs:\n       - build\n@@ -27,8 +33,8 @@ jobs:\n           tools: phpunit\n       - uses: actions/download-artifact@v4\n         with:\n-          name: beanstalkd\n-      - name: Start beanstalkd\n+          name: beanstalkd-${{ matrix.runner }}\n+      - name: Start beanstalkd for ${{ matrix.runner }}\n         run: chmod +x ./beanstalkd && ./beanstalkd &\n       - uses: actions/checkout@v4\n         with:\n@@ -42,11 +48,12 @@ jobs:\n           SERVER_HOST: localhost\n   greenstalk:\n     name: Test Greenstalk Python\n-    runs-on: ubuntu-latest\n+    runs-on: ${{ matrix.runner }}\n     continue-on-error: true\n     strategy:\n       matrix:\n         python-version: [ 3.9 ]\n+        runner: [ubuntu-latest, ubuntu-24.04-arm]\n     needs:\n       - build\n     steps:\n@@ -61,8 +68,8 @@ jobs:\n         id: download\n         with:\n           #include-hidden-files: true\n-          name: beanstalkd\n-      - name: Make beanstalkd executable\n+          name: beanstalkd-${{ matrix.runner }}\n+      - name: Make beanstalkd executable for ${{ matrix.runner }}\n         run: chmod +x ${{steps.download.outputs.download-path}}/beanstalkd\n       - name: Run beanstalkd -v\n         run: ${{steps.download.outputs.download-path}}/beanstalkd -v\n@@ -77,11 +84,12 @@ jobs:\n         run: make test\n   pystalk:\n     name: Test Pystalk Python\n-    runs-on: ubuntu-latest\n+    runs-on: ${{ matrix.runner }}\n     continue-on-error: true\n     strategy:\n       matrix:\n         python-version: [ \"3.10\" ]\n+        runner: [ubuntu-latest, ubuntu-24.04-arm]\n     needs:\n       - build\n     steps:\n@@ -95,8 +103,8 @@ jobs:\n       - uses: actions/download-artifact@v4\n         id: download\n         with:\n-          name: beanstalkd\n-      - name: Make beanstalkd executable\n+          name: beanstalkd-${{ matrix.runner }}\n+      - name: Make beanstalkd executable for ${{ matrix.runner }}\n         run: chmod +x ${{steps.download.outputs.download-path}}/beanstalkd\n       - name: Run beanstalkd -v\n         run: ${{steps.download.outputs.download-path}}/beanstalkd -v\n", "test_patch": "", "problem_statement": "Add multi-architecture Docker builds for tagged releases\nThis PR targets the possibility to automate Docker builds for both `linux/amd64` and `linux/arm64` platforms.\r\n\r\nLooking for an easy way to add Beanstalkd to my containerized apps, I realized there were a lot of seldomly maintained repositories on Docker Hub and this repository haven't gotten any version tagged builds as well as no build with the latest release.\r\n\r\nWhile I acknowledge this change might not justify a minor release, I hope this PR could pave the way for a maintainable automated build and push setup.\r\n\r\nMinor changes to the workflow named \"Testing clients\" due to failing pipelines as officially supported actions was deprecated earlier this year. \r\n\r\nFixes #648, fixes #661", "version": "1.13", "language": "C", "created_at": "2025-03-11T12:03:02Z", "repo_id": 6040}
